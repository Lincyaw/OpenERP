# ERP Development Progress

## 2026-01-23 - P0-BE-001: Backend Scaffolding Complete

### Completed
- **P0-BE-001**: 项目脚手架搭建 (Go Module, 目录结构)

### What was done
1. Created Go module at `backend/` with `github.com/erp/backend`
2. Established DDD directory structure:
   - `cmd/server/` - HTTP server entry point
   - `internal/domain/` - Domain layer with bounded contexts (catalog, partner, inventory, trade, finance, shared)
   - `internal/application/` - Application services (placeholder)
   - `internal/infrastructure/` - Infrastructure (config, persistence, eventbus)
   - `internal/interfaces/http/` - HTTP handlers, DTOs, middleware
   - `migrations/` - Database migrations (empty, ready for P0-BE-004)
   - `tests/` - Unit and integration test directories

3. Installed dependencies:
   - gin-gonic/gin (HTTP framework)
   - gorm.io/gorm + postgres driver (ORM)
   - google/uuid (UUIDs)
   - shopspring/decimal (precise decimals)
   - go-playground/validator/v10 (validation)
   - uber/zap (logging, not yet configured)
   - spf13/viper (config, not yet integrated)
   - golang-jwt/jwt/v5 (authentication)
   - redis/go-redis/v9 (cache/queue)
   - testify (testing)

4. Created shared domain components:
   - `BaseEntity` and `BaseAggregateRoot` with version for optimistic locking
   - `TenantAggregateRoot` for multi-tenant support
   - `DomainEvent` interface and `BaseDomainEvent`
   - `Repository` generic interface with `Filter` and `Paginated` types
   - Common domain errors (NotFound, AlreadyExists, InvalidState, etc.)

5. Created HTTP infrastructure:
   - Unified response format (`dto/response.go`)
   - Base handler with error handling (`handler/base.go`)
   - Common middleware (CORS, RequestID, Logger)
   - Health check and ping endpoints

### Files created
- `backend/go.mod`, `backend/go.sum`
- `backend/cmd/server/main.go`
- `backend/internal/domain/shared/*.go` (5 files)
- `backend/internal/domain/{catalog,partner,inventory,trade,finance}/doc.go`
- `backend/internal/infrastructure/config/config.go`
- `backend/internal/interfaces/http/dto/response.go`
- `backend/internal/interfaces/http/handler/base.go`
- `backend/internal/interfaces/http/middleware/common.go`
- `backend/README.md`, `.gitignore`, `.env.example`

### Build Status
- `go build ./...` passes successfully

### Notes for next developer
- P0-BE-002 (Database connection) depends on this and can now be started
- P0-BE-003 (Logger config) depends on this and can now be started
- Config currently uses env vars directly; may integrate Viper in P0-BE-003
- Main server is functional but minimal - add routes as APIs are developed
- Shared kernel is ready for value objects (P0-BE-005)

---

## 2026-01-23 - P0-BE-002: Database Connection Configuration Complete

### Completed
- **P0-BE-002**: 数据库连接配置 (PostgreSQL)

### What was done
1. Created database connection module at `internal/infrastructure/persistence/database.go`:
   - `Database` struct wrapping GORM DB instance
   - `NewDatabase()` and `NewDatabaseWithLogger()` constructors
   - Connection pool configuration (MaxOpenConns, MaxIdleConns, ConnMaxLifetime, ConnMaxIdleTime)
   - `Close()`, `Ping()`, `Stats()` methods for connection management
   - `Transaction()` method for transactional operations
   - `WithTenant()` method for multi-tenant scoping (with empty tenant ID validation)

2. Enhanced configuration with validation:
   - Added `ConnMaxLifetime` and `ConnMaxIdleTime` config options
   - Added production-specific validation (JWT secret, DB password, SSL mode)
   - Added connection pool validation (MaxIdleConns <= MaxOpenConns)
   - Changed DSN format to URL-style for proper escaping of special characters

3. Integrated database into main server:
   - Database connection on startup with graceful close on shutdown
   - Health check endpoint now returns proper HTTP 503 when database is unhealthy
   - Database status included in health response

4. Security improvements:
   - Production requires JWT secret (min 32 chars), DB password, and SSL enabled
   - Empty tenant ID in `WithTenant()` panics to prevent data leakage
   - DSN uses URL encoding to handle special characters in passwords

5. Test coverage:
   - Unit tests for `Database` struct methods using sqlmock
   - Tests for `ConnectionStats` struct
   - Tests for `WithTenant` including SQL injection prevention
   - Tests for `Transaction` with commit and rollback scenarios
   - Config validation tests for both development and production modes
   - DSN generation tests including special character escaping

### Files created/modified
- `backend/internal/infrastructure/persistence/database.go` (new)
- `backend/internal/infrastructure/persistence/database_test.go` (new)
- `backend/internal/infrastructure/config/config.go` (enhanced with validation)
- `backend/internal/infrastructure/config/config_test.go` (new)
- `backend/cmd/server/main.go` (integrated database)
- `backend/.env.example` (added new config options)

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests

### Notes for next developer
- P0-BE-003 (Logger config) can now be started - integrate zap with database logging
- P0-BE-004 (Database migrations) can now be started - database connection is ready
- The `NewDatabaseWithLogger()` function allows custom log levels for debugging
- `WithTenant()` requires non-empty tenant ID - use in middleware after auth
- For integration tests, use testcontainers-go to spin up PostgreSQL
- Health endpoint at `/health` includes database status

---

## 2026-01-23 - P0-BE-003: Logger Framework Configuration Complete

### Completed
- **P0-BE-003**: 日志框架配置

### What was done
1. Created logger package at `internal/infrastructure/logger/` with 4 files:
   - `logger.go` - Core logger initialization with zap, supports different levels (debug/info/warn/error) and formats (json/console)
   - `context.go` - Context helpers for request ID, tenant ID, user ID correlation
   - `gin.go` - Gin middleware for HTTP request logging and panic recovery
   - `gorm.go` - GORM logger adapter that integrates database queries with zap

2. Logger features implemented:
   - Environment-aware logging (development uses console format with colors, production uses JSON)
   - Structured logging with zap fields
   - Request correlation with request_id, tenant_id, user_id
   - HTTP request logging middleware with latency, status codes, client IP, user agent
   - Panic recovery middleware with stack traces
   - GORM query logging with slow query detection (200ms threshold)
   - Log level filtering at both application and database level

3. Configuration added:
   - `LOG_LEVEL` - Log level (debug, info, warn, error)
   - `LOG_FORMAT` - Output format (json, console)
   - `LOG_OUTPUT` - Output destination (stdout, stderr, or file path)

4. Integration completed:
   - Main server uses zap instead of stdlib log
   - Database uses custom GORM logger backed by zap
   - HTTP middleware stack updated: RequestID → Recovery → Logger → CORS
   - Health endpoint now logs warnings on failure

5. Test coverage:
   - 60 unit tests covering all logger functionality
   - Tests for level parsing, encoding, context propagation
   - Tests for Gin middleware (success/error/panic scenarios)
   - Tests for GORM logger (info/warn/error/trace/slow query)

### Files created/modified
- `backend/internal/infrastructure/logger/logger.go` (new)
- `backend/internal/infrastructure/logger/context.go` (new)
- `backend/internal/infrastructure/logger/gin.go` (new)
- `backend/internal/infrastructure/logger/gorm.go` (new)
- `backend/internal/infrastructure/logger/logger_test.go` (new)
- `backend/internal/infrastructure/logger/context_test.go` (new)
- `backend/internal/infrastructure/logger/gin_test.go` (new)
- `backend/internal/infrastructure/logger/gorm_test.go` (new)
- `backend/internal/infrastructure/config/config.go` (added LogConfig)
- `backend/internal/infrastructure/persistence/database.go` (added NewDatabaseWithCustomLogger)
- `backend/cmd/server/main.go` (integrated zap logging)
- `backend/.env.example` (added LOG_* variables)
- `backend/go.mod` (added zap dependency)

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests (60 new tests in logger package)

### Notes for next developer
- P0-BE-004 (Database migrations) can now be started - logger available for migration output
- P0-BE-008 (HTTP framework) is partially done - Gin middleware stack is configured with logging
- Use `logger.GetGinLogger(c)` in HTTP handlers to get request-scoped logger
- Use `logger.FromContext(ctx)` in application services to get context logger
- GORM logs SQL queries at DEBUG level, slow queries (>200ms) at WARN level
- Production mode uses JSON format with ISO8601 timestamps
- Set LOG_LEVEL=debug to see SQL queries in development

---

## 2026-01-23 - P0-BE-004: Database Migration Tool Configuration Complete

### Completed
- **P0-BE-004**: 数据库迁移工具配置 (golang-migrate)

### What was done
1. Integrated golang-migrate library:
   - Added `github.com/golang-migrate/migrate/v4` dependency
   - Added `github.com/lib/pq` for native PostgreSQL driver support in CLI

2. Created migration infrastructure at `internal/infrastructure/migration/`:
   - `migrate.go` - Core Migrator struct wrapping golang-migrate
     - `New()` and `NewFromURL()` constructors
     - `Up()`, `Down()`, `Steps()`, `GoTo()` migration methods
     - `Version()`, `Force()`, `Drop()` utility methods
     - Integrated with zap logger for structured logging
   - `creator.go` - Migration file creation utilities
     - `CreateMigration()` creates up/down SQL file pairs
     - Template-based migration file generation
     - Version format: YYYYMMDDHHMMSS for proper ordering
     - `ListMigrations()` to enumerate available migrations

3. Created migration CLI at `cmd/migrate/`:
   - Full-featured CLI for database migrations
   - Commands: up, down, step, goto, version, force, drop, create, list
   - Configurable migrations path and log level
   - Uses same database config as main server
   - Safety features: drop requires `-confirm` flag

4. Created initial migration:
   - `migrations/000001_init_schema.up.sql`:
     - Enables uuid-ossp and pgcrypto extensions
     - Creates tenants table with multi-tenancy support
     - Implements `update_updated_at_column()` trigger function
     - Adds default tenant for development
   - `migrations/000001_init_schema.down.sql`:
     - Clean rollback of all schema changes

5. Test coverage:
   - Unit tests for migration creator functions
   - Tests for name sanitization
   - Tests for file creation and directory handling
   - Tests for migration listing

### Files created/modified
- `backend/internal/infrastructure/migration/migrate.go` (new)
- `backend/internal/infrastructure/migration/creator.go` (new)
- `backend/internal/infrastructure/migration/creator_test.go` (new)
- `backend/cmd/migrate/main.go` (new)
- `backend/migrations/000001_init_schema.up.sql` (new)
- `backend/migrations/000001_init_schema.down.sql` (new)
- `backend/README.md` (updated with migration documentation)
- `backend/.env.example` (added MIGRATIONS_PATH)
- `backend/go.mod` (added golang-migrate and pq dependencies)

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests

### Usage Examples
```bash
# Build the migration CLI
go build -o bin/migrate cmd/migrate/main.go

# Apply all pending migrations
./bin/migrate up

# Create a new migration
./bin/migrate create add_users_table "Create users table"

# Check current version
./bin/migrate version

# Roll back last migration
./bin/migrate step -1
```

### Notes for next developer
- P0-BE-005 (Value objects) can now be started - migrations are ready for new tables
- P0-BE-006 (Event bus) can now be started - database foundation is complete
- Initial migration creates tenants table for multi-tenancy
- Use `./bin/migrate create <name>` to add new migrations
- Migrations use YYYYMMDDHHMMSS versioning for proper ordering
- The Migrator integrates with zap logger for structured output
- Force command should only be used to fix dirty state
- Drop command is destructive and requires explicit confirmation

---

## 2026-01-23 - P0-BE-005: Common Value Objects Complete

### Completed
- **P0-BE-005**: 通用值对象实现 (Money, Quantity)

### What was done
1. Added shopspring/decimal dependency for precise decimal arithmetic:
   - `github.com/shopspring/decimal v1.4.0`

2. Implemented Money value object at `internal/domain/shared/valueobject/money.go`:
   - Immutable design - all operations return new instances
   - Multiple currency support (CNY, USD, EUR, GBP, JPY, HKD)
   - Factory methods: `NewMoney()`, `NewMoneyFromFloat()`, `NewMoneyFromInt()`, `NewMoneyFromString()`
   - CNY-specific helpers: `NewMoneyCNY()`, `NewMoneyCNYFromFloat()`, `ZeroCNY()`
   - Arithmetic: `Add()`, `Subtract()`, `Multiply()`, `Divide()`, `Negate()`, `Abs()`
   - Comparisons: `Equals()`, `LessThan()`, `GreaterThan()`, `LessThanOrEqual()`, `GreaterThanOrEqual()`
   - Rounding: `Round()`, `RoundBank()`, `Truncate()`
   - Business operations: `Allocate()` (fair division), `CalculatePercentage()`, `ApplyDiscount()`
   - JSON serialization: `MarshalJSON()`, `UnmarshalJSON()`
   - Database support: `Value()` (driver.Valuer), `Scan()` (sql.Scanner)

3. Implemented Quantity value object at `internal/domain/shared/valueobject/quantity.go`:
   - Immutable design - all operations return new instances
   - Non-negative enforcement (prevents negative inventory)
   - Unit of measurement support
   - Factory methods: `NewQuantity()`, `NewQuantityFromFloat()`, `NewQuantityFromInt()`, `NewIntegerQuantity()`
   - Arithmetic: `Add()`, `Subtract()`, `Multiply()`, `Divide()`
   - Unit conversion: `Convert()`, `ConvertByFloat()`
   - Rounding: `Round()`, `Truncate()`, `Ceiling()`, `Floor()`
   - Inventory helpers: `SufficientFor()`, `Deficit()`, `Split()`
   - Allows negative with `SubtractAllowNegative()` for deficit calculation
   - JSON and database support

4. Comprehensive unit tests:
   - `money_test.go`: 27 test cases covering all Money functionality
   - `quantity_test.go`: 25 test cases covering all Quantity functionality
   - Test coverage: 86.3% of statements

### Files created/modified
- `backend/internal/domain/shared/valueobject/money.go` (new)
- `backend/internal/domain/shared/valueobject/money_test.go` (new)
- `backend/internal/domain/shared/valueobject/quantity.go` (new)
- `backend/internal/domain/shared/valueobject/quantity_test.go` (new)
- `backend/go.mod` (added shopspring/decimal)
- `backend/go.sum` (updated)

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests (86.3% coverage for valueobject package)

### Key Design Decisions
1. **Immutability**: All methods return new instances to prevent accidental mutation
2. **Currency safety**: Money operations fail if currencies don't match
3. **Non-negative Quantity**: Standard subtract fails if result would be negative; use `SubtractAllowNegative()` for deficit calculation
4. **Decimal precision**: Uses shopspring/decimal for financial calculations (no floating-point errors)
5. **Database storage**: Values stored as strings to preserve precision

### Usage Examples
```go
// Money
price := NewMoneyCNYFromFloat(99.99)
quantity := 3
total := price.MultiplyByInt(quantity) // 299.97 CNY

discount := total.ApplyDiscount(decimal.NewFromInt(10)) // 10% off
parts, _ := total.Allocate(3) // Fair division for split payments

// Quantity
stock, _ := NewQuantityFromInt(100, "pcs")
ordered, _ := NewQuantityFromInt(30, "pcs")
remaining, _ := stock.Subtract(ordered) // 70 pcs

sufficient, _ := stock.SufficientFor(ordered) // true
deficit, _ := ordered.Deficit(stock) // 0 pcs (no deficit)

// Unit conversion (1000g = 1kg)
grams, _ := NewQuantityFromInt(1000, "g")
kg, _ := grams.Convert("kg", decimal.NewFromFloat(0.001)) // 1 kg
```

### Notes for next developer
- P0-BE-006 (Event bus) can now be started - value objects ready
- P0-BE-008 (HTTP framework) is partially done from P0-BE-003
- Money uses `DefaultCurrency = CNY` when scanning from database without currency
- For multi-currency systems, store currency alongside amount in database
- Use `MustAdd()` / `MustSubtract()` when you're certain units/currencies match (panics on mismatch)
- Quantity's `Convert()` is for unit conversion, not currency conversion

---

## 2026-01-23 - P0-BE-006: Domain Event Infrastructure Complete

### Completed
- **P0-BE-006**: 领域事件基础设施 (EventBus, Outbox)

### What was done
1. Defined domain interfaces in `internal/domain/shared/`:
   - `eventbus.go` - EventHandler, EventPublisher, EventSubscriber, EventBus interfaces
   - `outbox.go` - OutboxEntry entity with status management, OutboxRepository interface
   - `event.go` - DomainEvent interface and BaseDomainEvent implementation

2. Implemented EventBus infrastructure at `internal/infrastructure/event/`:
   - `registry.go` - HandlerRegistry for managing event subscriptions (specific + wildcard handlers)
   - `bus.go` - InMemoryEventBus for synchronous in-process pub/sub
   - `serializer.go` - EventSerializer for JSON serialization/deserialization with type registry

3. Implemented Outbox Pattern for reliable event delivery:
   - `outbox_repository.go` - GormOutboxRepository with FOR UPDATE SKIP LOCKED for concurrent processing
   - `outbox_publisher.go` - OutboxPublisher for transactional event persistence
   - `outbox_processor.go` - Background processor with polling, batch processing, retry logic, and cleanup

4. Created database migration:
   - `migrations/000002_create_outbox_events.up.sql` - Outbox table with proper indexes
   - `migrations/000002_create_outbox_events.down.sql` - Rollback script

5. Test coverage (79.6%):
   - `bus_test.go` - InMemoryEventBus tests (publish, subscribe, unsubscribe, wildcard, error handling)
   - `registry_test.go` - HandlerRegistry tests
   - `serializer_test.go` - EventSerializer round-trip tests
   - `outbox_test.go` - OutboxEntry state machine tests
   - `outbox_repository_test.go` - GormOutboxRepository tests
   - `outbox_publisher_test.go` - OutboxPublisher tests
   - `outbox_processor_test.go` - OutboxProcessor tests

### Key Design Decisions
1. **Outbox Pattern**: Events are persisted to database within the same transaction as aggregate changes, then processed asynchronously for reliable delivery
2. **FOR UPDATE SKIP LOCKED**: Prevents double-processing in multi-instance deployments
3. **Exponential Backoff**: Failed events retry with increasing delays (1s, 2s, 4s, 8s, 16s)
4. **Dead Letter**: Events exceeding max retries (default 5) move to DEAD status for manual review
5. **Automatic Cleanup**: Processed events older than 7 days are automatically deleted

### Files created/modified
- `backend/internal/domain/shared/eventbus.go` (new)
- `backend/internal/domain/shared/outbox.go` (new)
- `backend/internal/infrastructure/event/registry.go` (new)
- `backend/internal/infrastructure/event/bus.go` (new)
- `backend/internal/infrastructure/event/serializer.go` (new)
- `backend/internal/infrastructure/event/outbox_repository.go` (new)
- `backend/internal/infrastructure/event/outbox_publisher.go` (new)
- `backend/internal/infrastructure/event/outbox_processor.go` (new)
- `backend/internal/infrastructure/event/*_test.go` (7 test files)
- `backend/migrations/000002_create_outbox_events.up.sql` (new)
- `backend/migrations/000002_create_outbox_events.down.sql` (new)

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests (79.6% coverage for event package)

### Usage Examples
```go
// Register event type for deserialization
serializer := event.NewEventSerializer()
serializer.Register("ProductCreated", &ProductCreatedEvent{})

// Create event bus
bus := event.NewInMemoryEventBus(logger)
bus.Subscribe(myHandler, "ProductCreated")
bus.Start(ctx)

// Publish events within transaction using OutboxPublisher
publisher := event.NewOutboxPublisher(serializer)
err := db.Transaction(func(tx *gorm.DB) error {
    // Save aggregate
    if err := tx.Save(product).Error; err != nil {
        return err
    }
    // Persist events to outbox (same transaction)
    return publisher.PublishWithTx(ctx, tx, product.Events()...)
})

// Start background processor to deliver events
processor := event.NewOutboxProcessor(repo, bus, serializer, config, logger)
processor.Start(ctx)
```

### Notes for next developer
- P0-BE-007 (Strategy registry) can now be started
- P0-BE-008 (HTTP framework) is partially done from P0-BE-003
- P1-BE-007 (Product domain events) can leverage this infrastructure
- When defining new domain events, remember to register them with EventSerializer
- OutboxProcessor should be started as part of application startup
- For high-throughput scenarios, consider tuning BatchSize and PollInterval
- Test with `go test ./internal/infrastructure/event/... -cover`

---

## 2026-01-23 - P0-BE-008: HTTP Framework Configuration Complete

### Completed
- **P0-BE-008**: HTTP 框架配置 (Gin)

### What was done
1. Added HTTP configuration to config package:
   - `HTTPConfig` struct with ReadTimeout, WriteTimeout, IdleTimeout
   - MaxHeaderBytes, MaxBodySize settings
   - Rate limiting configuration (enabled, requests, window)
   - CORS configuration (origins, methods, headers)
   - Trusted proxies list

2. Implemented common middleware at `internal/interfaces/http/middleware/`:
   - `common.go` - Enhanced with:
     - Configurable CORS middleware (`CORSWithConfig`)
     - Improved RequestID generation using crypto/rand
     - Security headers middleware (`Secure()`) - X-Frame-Options, X-XSS-Protection, etc.
     - Timeout middleware
   - `ratelimit.go` - Token bucket rate limiter:
     - Per-client rate limiting
     - Automatic cleanup of expired entries
     - Tenant-aware rate limiting (X-Tenant-ID header)
     - Custom key extraction support
   - `bodylimit.go` - Request body size limit:
     - Content-Length check
     - MaxBytesReader for streaming protection
   - `validation.go` - Validation helpers:
     - Integration with go-playground/validator
     - Custom error message formatting
     - Structured validation error responses

3. Created router framework at `internal/interfaces/http/router/`:
   - `Router` struct for centralized route registration
   - `RouteRegistrar` interface for modular route registration
   - `DomainGroup` for domain-specific route grouping
   - Support for middleware per group
   - Chained method calls for fluent API
   - Subgroup support for nested routes

4. Updated main.go with:
   - Full middleware stack (RequestID → Recovery → Logger → Security → CORS → BodyLimit → RateLimit)
   - HTTP server configuration from config
   - Domain route groups (catalog, partner, inventory, trade, finance)
   - Ping endpoints for each domain

5. Test coverage:
   - `common_test.go` - 8 test cases for CORS, RequestID, Security, Timeout
   - `ratelimit_test.go` - 10 test cases including concurrent access
   - `bodylimit_test.go` - 4 test cases for body size limiting
   - `validation_test.go` - 4 test cases for validation error handling
   - `router_test.go` - 8 test cases for router and domain groups

### Files created/modified
- `backend/internal/infrastructure/config/config.go` (added HTTPConfig)
- `backend/internal/interfaces/http/middleware/common.go` (enhanced)
- `backend/internal/interfaces/http/middleware/ratelimit.go` (new)
- `backend/internal/interfaces/http/middleware/bodylimit.go` (new)
- `backend/internal/interfaces/http/middleware/validation.go` (new)
- `backend/internal/interfaces/http/middleware/*_test.go` (4 test files)
- `backend/internal/interfaces/http/router/router.go` (new)
- `backend/internal/interfaces/http/router/router_test.go` (new)
- `backend/cmd/server/main.go` (updated with full middleware stack and routes)
- `backend/.env.example` (added HTTP_* and EVENT_* variables)

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests

### API Routes Structure
```
/health                     - Health check (outside versioning)
/api/v1/ping               - Root API ping
/api/v1/catalog/ping       - Catalog service ping
/api/v1/partner/ping       - Partner service ping
/api/v1/inventory/ping     - Inventory service ping
/api/v1/trade/ping         - Trade service ping
/api/v1/finance/ping       - Finance service ping
```

### Middleware Stack Order
1. RequestID - Generate/propagate X-Request-ID
2. Recovery - Catch panics with stack trace logging
3. GinMiddleware - Request logging with zap
4. Secure - Security headers (X-Frame-Options, etc.)
5. CORS - Cross-origin request handling
6. BodyLimit - Request body size limit (default 10MB)
7. RateLimit - Token bucket rate limiting (100 req/min default)

### Notes for next developer
- P0-BE-010 (Unit test framework) is partially done - testify already integrated
- To add new domain APIs, create handlers and register with DomainGroup
- Rate limiter can be customized per route using `RateLimitByKey()`
- CORS can be configured via environment variables
- For production, set HTTP_TRUSTED_PROXIES if behind a reverse proxy
- Validation middleware integrates with Gin's ShouldBindJSON

---

## 2026-01-23 - P0-BE-009: API Response Format Unification Complete

### Completed
- **P0-BE-009**: API 响应格式统一

### What was done
1. Created comprehensive error code constants at `internal/interfaces/http/dto/errors.go`:
   - Standardized error code format: `ERR_<CATEGORY>_<DESCRIPTION>`
   - Categories: General, Validation, Authentication, Resource, Business Rule, Input, Rate Limiting
   - All error codes mapped to appropriate HTTP status codes
   - Legacy error code mapping for backward compatibility with existing domain errors

2. Enhanced Response structure in `internal/interfaces/http/dto/response.go`:
   - `ErrorInfo` now includes:
     - `Code` - Standardized error code
     - `Message` - Human-readable error message
     - `RequestID` - Request correlation ID (from X-Request-ID header)
     - `Timestamp` - When the error occurred
     - `Details` - Array of validation errors (field + message)
     - `Help` - Optional documentation URL
   - New response factory functions:
     - `NewErrorResponseWithRequestID()` - Error with request correlation
     - `NewValidationErrorResponse()` - Validation errors with field details
     - `NewErrorResponseWithDetails()` - Error with additional details
     - `NewErrorResponseWithHelp()` - Error with help URL

3. Updated BaseHandler in `internal/interfaces/http/handler/base.go`:
   - All error methods now include RequestID from context/header
   - New methods: `Unauthorized()`, `Forbidden()`, `Conflict()`, `TooManyRequests()`, `UnprocessableEntity()`
   - `ErrorWithCode()` - Derives HTTP status from error code automatically
   - `ValidationError()` - Sends validation error with field details
   - `HandleError()` - Generic error handler for any error type
   - `HandleDomainError()` - Enhanced to normalize legacy error codes

4. Updated validation middleware in `internal/interfaces/http/middleware/validation.go`:
   - Now uses unified `dto.Response` structure
   - Includes request ID in validation error responses
   - Uses standardized `ERR_VALIDATION` error code

5. Comprehensive test coverage:
   - `dto/errors_test.go` - 14 test cases for error codes, HTTP status mapping, code normalization
   - `handler/base_test.go` - 15 test cases for all handler methods and domain error handling
   - Coverage: dto=88.2%, handler=100%

### Error Code Reference

| Category | Code | HTTP Status |
|----------|------|-------------|
| General | `ERR_UNKNOWN`, `ERR_INTERNAL` | 500 |
| Validation | `ERR_VALIDATION`, `ERR_VALIDATION_*` | 400 |
| Auth | `ERR_UNAUTHORIZED`, `ERR_FORBIDDEN`, `ERR_TOKEN_*` | 401/403 |
| Resource | `ERR_NOT_FOUND`, `ERR_ALREADY_EXISTS`, `ERR_CONFLICT` | 404/409 |
| Business | `ERR_INVALID_STATE`, `ERR_INSUFFICIENT_*` | 422 |
| Input | `ERR_BAD_REQUEST`, `ERR_INVALID_INPUT`, `ERR_INVALID_JSON` | 400 |
| Rate Limit | `ERR_RATE_LIMITED`, `ERR_TOO_MANY_REQUESTS` | 429 |

### Files created/modified
- `backend/internal/interfaces/http/dto/errors.go` (new)
- `backend/internal/interfaces/http/dto/errors_test.go` (new)
- `backend/internal/interfaces/http/dto/response.go` (enhanced)
- `backend/internal/interfaces/http/handler/base.go` (enhanced)
- `backend/internal/interfaces/http/handler/base_test.go` (new)
- `backend/internal/interfaces/http/middleware/validation.go` (updated to use unified response)
- `backend/internal/interfaces/http/middleware/validation_test.go` (updated)

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests

### Example API Response Formats

**Success Response:**
```json
{
  "success": true,
  "data": { "id": "123", "name": "Example" }
}
```

**Success with Pagination:**
```json
{
  "success": true,
  "data": [...],
  "meta": {
    "total": 100,
    "page": 1,
    "page_size": 10,
    "total_pages": 10
  }
}
```

**Error Response:**
```json
{
  "success": false,
  "error": {
    "code": "ERR_NOT_FOUND",
    "message": "Resource not found",
    "request_id": "req-abc-123",
    "timestamp": "2026-01-23T10:30:00Z"
  }
}
```

**Validation Error Response:**
```json
{
  "success": false,
  "error": {
    "code": "ERR_VALIDATION",
    "message": "Request validation failed",
    "request_id": "req-def-456",
    "timestamp": "2026-01-23T10:30:00Z",
    "details": [
      { "field": "email", "message": "Invalid email format" },
      { "field": "age", "message": "Must be at least 18" }
    ]
  }
}
```

### Notes for next developer
- P0-BE-010 (Unit test framework) can now be started - testify already integrated, patterns established
- P0-FE-001 (Frontend scaffolding) can use this error format for consistent error handling
- Legacy domain error codes (e.g., "NOT_FOUND") are automatically normalized to new format (e.g., "ERR_NOT_FOUND")
- Use `dto.GetHTTPStatus(code)` to get the HTTP status for any error code
- Use `dto.NormalizeErrorCode(code)` if you need to convert legacy codes
- All handlers should use `h.HandleError(c, err)` or `h.HandleDomainError(c, err)` for consistent error responses
- Request ID is extracted from `X-Request-ID` header or context - set by RequestID middleware

---

## 2026-01-23 - P0-BE-010: Unit Test Framework Configuration Complete

### Completed
- **P0-BE-010**: 单元测试框架配置

### What was done
1. Testify integration already complete from P0-BE-001:
   - `github.com/stretchr/testify v1.11.1` for assertions
   - `github.com/DATA-DOG/go-sqlmock v1.5.2` for database mocking
   - 24 existing test files with comprehensive coverage

2. Created test coverage tooling:
   - `backend/Makefile` with coverage targets:
     - `make test` - Run all tests
     - `make test-unit` - Run unit tests only
     - `make test-race` - Run with race detector
     - `make test-coverage` - Run with coverage report
     - `make test-coverage-html` - Generate HTML coverage report
     - `make test-coverage-ci` - CI coverage with 80% threshold check
   - Coverage configuration for CI/CD integration

3. Created test utility package at `tests/testutil/`:
   - `testutil.go` - Core test utilities:
     - `NewMockDB(t)` - Creates mock database with sqlmock
     - `NewTestContext(t)` - Creates Gin test context
     - `NewTestUUID(seed)` - Deterministic UUIDs for reproducible tests
     - `TestTenantID()`, `TestUserID()` - Standard test identifiers
     - `ContextWithTimeout()`, `ContextWithCancel()` - Context helpers
     - `AssertEventually()`, `AssertNever()` - Async assertions
   - `http.go` - HTTP testing utilities:
     - `HTTPTestCase` struct for table-driven HTTP tests
     - `RunHTTPTestCases()` - Batch test runner
     - `JSONResponse()`, `JSONResponseAs[T]()` - Response parsing
     - `AssertSuccessResponse()`, `AssertErrorResponse()` - API assertions
     - `ToJSONReader()` - JSON body creation
   - `event.go` - Event testing utilities:
     - `MockEventHandler` - Thread-safe mock event handler
     - `TestEvent` - Simple domain event for testing
     - `NewTestEvent()`, `NewTestEventWithID()` - Event factories
     - `WaitForCondition()`, `WaitForEventCount()` - Async event testing

4. Test coverage for testutil package:
   - `testutil_test.go` - 30 test cases
   - `event_test.go` - 8 test cases
   - Coverage: 81.2% of statements

### Files created/modified
- `backend/Makefile` (new)
- `backend/tests/testutil/testutil.go` (new)
- `backend/tests/testutil/http.go` (new)
- `backend/tests/testutil/event.go` (new)
- `backend/tests/testutil/testutil_test.go` (new)
- `backend/tests/testutil/event_test.go` (new)
- `backend/README.md` (updated with testing documentation)

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests (38 new tests in testutil package)
- `make test-coverage` works correctly

### Current Test Statistics
| Package | Coverage |
|---------|----------|
| valueobject | 86.3% |
| logger | 98.5% |
| strategy | 90.5% |
| dto | 89.5% |
| handler | 100.0% |
| router | 100.0% |
| testutil | 81.2% |
| event | 79.6% |
| config | 74.1% |
| middleware | 72.0% |
| **Overall** | **63.0%** |

### Usage Examples
```go
// Mock database testing
mockDB := testutil.NewMockDB(t)
defer mockDB.Close()
mockDB.Mock.ExpectQuery(...).WillReturnRows(...)

// HTTP handler testing
tc := testutil.NewTestContext(t)
tc.SetRequestID("req-123")
tc.SetTenantID("tenant-456")
handler(tc.Context)
testutil.AssertSuccessResponse(t, tc)

// Event testing
handler := testutil.NewMockEventHandler("ProductCreated")
event := testutil.NewTestEvent("ProductCreated", testutil.TestTenantID())
testutil.WaitForEventCount(t, handler, 1, 5*time.Second)

// Async assertions
testutil.AssertEventually(t, func() bool {
    return someCondition
}, 5*time.Second, 100*time.Millisecond)
```

### Makefile Targets
```bash
make test              # Run all tests
make test-unit         # Run unit tests (./internal/...)
make test-race         # Run with race detector
make test-coverage     # Run with coverage report
make test-coverage-html # Generate HTML report
make test-coverage-ci  # CI with 80% threshold
make test-pkg PKG=./internal/domain/... # Test specific package
make lint              # Run linter
make fmt               # Format code
make ci                # Run all CI checks
```

### Notes for next developer
- P0-FE-001 (Frontend scaffolding) is the next highest priority incomplete task
- All P0 backend tasks are now complete
- Use `make test-coverage-html` to view detailed coverage report in browser
- The testutil package provides helpers for database, HTTP, and event testing
- Coverage threshold is 80% - CI will fail if below this
- Use `testutil.NewTestUUID("seed")` for deterministic UUIDs in tests
- Use `testutil.AssertEventually()` for async assertions instead of `time.Sleep()`

---

## 2026-01-23 - P0-FE-001: Frontend Project Scaffolding Complete

### Completed
- **P0-FE-001**: 前端项目脚手架搭建 (React + TypeScript)

### What was done
1. Created React + TypeScript project using Vite:
   - `npm create vite@latest frontend -- --template react-ts`
   - React 19.2.0, TypeScript 5.9.3, Vite 7.2.4

2. Configured ESLint and Prettier:
   - ESLint with TypeScript, React, React Hooks plugins
   - Prettier integration via eslint-plugin-prettier
   - `.prettierrc` with project conventions (no semicolons, single quotes)
   - `.prettierignore` for build artifacts

3. Established directory structure:
   ```
   frontend/
   ├── src/
   │   ├── assets/          # Static assets (images, fonts)
   │   ├── components/
   │   │   ├── common/      # Reusable UI components
   │   │   └── layout/      # Layout components
   │   ├── features/        # Feature-based modules
   │   │   ├── catalog/     # Products, Categories
   │   │   ├── partner/     # Customers, Suppliers, Warehouses
   │   │   ├── inventory/   # Stock management
   │   │   ├── trade/       # Sales, Purchases, Returns
   │   │   └── finance/     # Receivables, Payables
   │   ├── hooks/           # Custom React hooks
   │   ├── pages/           # Route page components
   │   ├── services/        # API services
   │   ├── store/           # Zustand stores
   │   ├── types/           # TypeScript definitions
   │   └── utils/           # Utility functions
   ├── .env.example
   ├── .prettierrc
   ├── eslint.config.js
   ├── tsconfig.app.json
   └── vite.config.ts
   ```

4. Configured path aliases:
   - `@/*` → `src/*`
   - `@components/*`, `@features/*`, `@hooks/*`, etc.
   - Configured in both `vite.config.ts` and `tsconfig.app.json`

5. Created TypeScript types matching backend:
   - `ApiResponse<T>` - Standard response format
   - `ApiError` - Error structure with code, message, request_id
   - `PaginationMeta`, `PaginationParams` - Pagination support
   - `BaseEntity`, `TenantEntity` - Entity base types

6. Configured Vite:
   - Development server on port 3000
   - API proxy to backend (localhost:8080)
   - Path aliases for clean imports

### Files created/modified
- `frontend/` - Entire frontend directory (new)
- `frontend/package.json` - Project configuration with scripts
- `frontend/eslint.config.js` - ESLint flat config
- `frontend/.prettierrc` - Prettier configuration
- `frontend/.prettierignore` - Prettier ignore patterns
- `frontend/vite.config.ts` - Vite configuration with aliases and proxy
- `frontend/tsconfig.app.json` - TypeScript config with path aliases
- `frontend/src/types/api.ts` - API type definitions
- `frontend/src/App.tsx` - Clean starter app
- Feature directories with placeholder index.ts files

### Build Status
- `npm run type-check` passes
- `npm run lint` passes
- `npm run build` passes (193KB JS bundle gzipped to 61KB)

### NPM Scripts
```bash
npm run dev          # Start dev server (port 3000)
npm run build        # Production build
npm run preview      # Preview production build
npm run lint         # Run ESLint
npm run lint:fix     # Fix ESLint issues
npm run format       # Format with Prettier
npm run format:check # Check formatting
npm run type-check   # TypeScript check
```

### Notes for next developer
- P0-FE-002 (Semi Design UI) is the next highest priority task
- P0-FE-003 (Routing) depends on P0-FE-002 for layout components
- Use `@/` imports for clean module references
- API types match backend `dto/response.go` format
- Dev server proxies `/api` requests to backend on port 8080
- ESLint + Prettier run automatically on lint:fix

---

## 2026-01-23 - P0-API-001: OpenAPI Specification and SDK Auto-Generation Complete

### Completed
- **P0-API-001**: OpenAPI 规范与 SDK 自动生成
- **P0-FE-005**: HTTP 客户端封装 (Axios) - completed as part of this task

### What was done
1. Backend: Integrated swaggo/swag for OpenAPI generation:
   - Added `github.com/swaggo/swag`, `github.com/swaggo/gin-swagger`, `github.com/swaggo/files` dependencies
   - Added general API info annotations to `cmd/server/main.go` (title, version, description, security)
   - Created Swagger UI endpoint at `/swagger/*any`
   - Configured `@securityDefinitions.apikey BearerAuth` for JWT authentication

2. Backend: Created example API with full swagger annotations:
   - `internal/interfaces/http/handler/system.go` - SystemHandler with GetSystemInfo and Ping endpoints
   - Full swagger annotations including `@Summary`, `@Description`, `@Tags`, `@Param`, `@Success`, `@Failure`, `@Router`
   - Unit tests for SystemHandler in `system_test.go`

3. Backend: Updated Makefile with documentation targets:
   - `make docs` - Generate OpenAPI spec from Go annotations
   - `make docs-check` - Verify OpenAPI docs are up-to-date (for CI)
   - Updated `dev-deps` target to install swag CLI
   - Updated CI target to include docs-check

4. Frontend: Integrated orval for TypeScript SDK generation:
   - Installed axios and orval dependencies
   - Created `orval.config.ts` with configuration for tags-split mode
   - Created `src/services/axios-instance.ts` with:
     - Base axios instance with configurable base URL
     - Request interceptor for JWT token injection and request ID
     - Response interceptor for error handling (401, 403, 429, 500)
     - Custom instance function for orval integration

5. Frontend: Added npm scripts for API generation:
   - `npm run api:generate` - Generate TypeScript SDK from OpenAPI spec
   - `npm run api:watch` - Watch mode for continuous generation

6. Generated TypeScript SDK:
   - `src/api/system/system.ts` - System API client with typed functions
   - `src/api/models/*.ts` - TypeScript interfaces for all DTOs
   - Auto-generated from backend OpenAPI spec

### Files created/modified
**Backend:**
- `backend/cmd/server/main.go` (added swagger annotations and imports)
- `backend/internal/interfaces/http/handler/system.go` (new)
- `backend/internal/interfaces/http/handler/system_test.go` (new)
- `backend/docs/swagger.yaml` (generated)
- `backend/docs/swagger.json` (generated)
- `backend/docs/docs.go` (generated)
- `backend/Makefile` (added docs targets)
- `backend/go.mod` (added swagger dependencies)

**Frontend:**
- `frontend/package.json` (added api:generate scripts, axios, orval)
- `frontend/orval.config.ts` (new)
- `frontend/src/services/axios-instance.ts` (new)
- `frontend/src/services/index.ts` (updated with exports)
- `frontend/src/api/**/*.ts` (auto-generated SDK files)

### Build Status
- Backend: `go build ./...` passes
- Backend: `go test ./...` passes all tests
- Frontend: `npm run type-check` passes
- Frontend: `npm run build` passes
- Frontend: `npm run lint` passes

### API Documentation
Available at: `http://localhost:8080/swagger/index.html` when server is running

### Example API Endpoints
```
GET /api/v1/system/info   - Get system information
GET /api/v1/system/ping   - Ping the API
```

### Usage Examples

**Backend: Adding a new API endpoint**
```go
// CreateProduct godoc
// @Summary      Create a new product
// @Description  Create a new product in the catalog
// @Tags         products
// @Accept       json
// @Produce      json
// @Param        request body dto.CreateProductRequest true "Product creation request"
// @Success      201 {object} dto.Response{data=dto.ProductResponse}
// @Failure      400 {object} dto.Response{error=dto.ErrorInfo}
// @Router       /products [post]
func (h *ProductHandler) Create(c *gin.Context) {
    // implementation
}
```

**Frontend: Using the generated SDK**
```typescript
import { getSystem } from '@/services'

const api = getSystem()

// Fetch system info with full type safety
const info = await api.getSystemInfo()
console.log(info.data?.name)    // "ERP Backend API"
console.log(info.data?.version) // "1.0.0"
```

### Workflow for Adding New APIs
1. Add handler with swagger annotations in backend
2. Run `make docs` in backend to regenerate OpenAPI spec
3. Run `npm run api:generate` in frontend to regenerate TypeScript SDK
4. Use the auto-generated typed client in frontend code

### Notes for next developer
- P0-FE-002 (Semi Design UI) is the next highest priority task
- All generated files in `frontend/src/api/` are auto-generated - DO NOT edit manually
- Run `make docs-check` to verify OpenAPI spec is up-to-date before committing
- Swagger UI available at `/swagger/index.html` for API exploration
- The axios instance handles JWT token injection automatically from localStorage
- Use `customInstance` function for orval integration, not `axiosInstance` directly

---

## 2026-01-23 - P0-FE-002: UI Component Library Integration (Semi Design) Complete

### Completed
- **P0-FE-002**: UI 组件库集成 (Semi Design)

### What was done
1. Installed Semi Design packages:
   - `@douyinfe/semi-ui` - Main UI component library
   - `@douyinfe/semi-icons` - Icon library

2. Configured global styles:
   - Created new `index.css` with CSS reset and Semi Design CSS variables
   - Set up base typography using Semi Design's font stack
   - Added custom scrollbar styling using Semi Design colors
   - Configured selection styling with Semi Design theme colors

3. Updated App.tsx with component verification demo:
   - Demonstrates multiple Semi Design components working together
   - Components tested: Button, Card, Typography, Space, Tag, Input, Toast, Table, Avatar, Descriptions
   - Icons tested: IconHome, IconSearch, IconUser, IconSetting, IconGithubLogo
   - Interactive elements (Toast notification on button click)

4. Removed unused App.css file (replaced by Semi Design styling)

### Files created/modified
- `frontend/package.json` (added semi-ui and semi-icons dependencies)
- `frontend/src/index.css` (rewritten for Semi Design)
- `frontend/src/App.tsx` (component demo with Semi Design)
- `frontend/src/App.css` (deleted - no longer needed)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes
- `npm run build` passes (676KB JS bundle, gzipped to 201KB)
- Note: Chunk size warning is expected - can be optimized with code-splitting later

### Components Verified
| Component | Status |
|-----------|--------|
| Button (all types) | Working |
| Card | Working |
| Typography (Title, Text, Paragraph) | Working |
| Space | Working |
| Tag (all colors) | Working |
| Input with prefix icon | Working |
| Toast | Working |
| Table | Working |
| Avatar | Working |
| Descriptions | Working |
| Icons | Working |

### Notes for next developer
- P0-FE-003 (Routing) is the next highest priority task
- P0-FE-004 (Zustand state management) can also be started in parallel
- Semi Design uses CSS variables prefixed with `--semi-color-*`
- For dark mode, Semi Design provides built-in theme switching
- Consider code-splitting Semi Design imports for production optimization
- Toast component works globally without provider setup
---

## 2026-01-23 - P0-FE-003: Route Configuration Complete

### Completed
- **P0-FE-003**: 路由配置 (React Router v6)

### What was done
1. Installed react-router-dom package:
   - `react-router-dom` v7.x for React 19 compatibility

2. Created router infrastructure at `src/router/`:
   - `types.ts` - Type definitions (AppRoute, RouteMeta, MenuItem, BreadcrumbItem)
   - `lazyLoad.tsx` - Lazy loading utilities with Suspense and loading fallback
   - `guards.tsx` - AuthGuard and GuestGuard components for route protection
   - `routes.tsx` - Main route configuration with lazy-loaded pages
   - `index.ts` - Module exports

3. Route features implemented:
   - Lazy loading with React.lazy() and Suspense for code splitting
   - AuthGuard: Redirects unauthenticated users to /login, preserves return URL
   - GuestGuard: Redirects authenticated users away from login
   - Permission checking foundation (ready for P6-FE-003)
   - Breadcrumb generation utility
   - Route metadata support (title, icon, permissions, order)

4. Created placeholder pages:
   - `pages/Dashboard.tsx` - Home dashboard placeholder
   - `pages/Login.tsx` - Login form with mock authentication
   - `pages/NotFound.tsx` - 404 error page
   - `pages/Forbidden.tsx` - 403 access denied page
   - `pages/catalog/Products.tsx`, `pages/catalog/Categories.tsx`
   - `pages/partner/Customers.tsx`, `pages/partner/Suppliers.tsx`, `pages/partner/Warehouses.tsx`
   - `pages/inventory/StockList.tsx`
   - `pages/trade/SalesOrders.tsx`, `pages/trade/PurchaseOrders.tsx`
   - `pages/finance/Receivables.tsx`, `pages/finance/Payables.tsx`

5. Route structure mirrors ERP domain modules:
   ```
   /               - Dashboard (protected)
   /login          - Login page (guest only)
   /catalog/*      - Products, Categories
   /partner/*      - Customers, Suppliers, Warehouses
   /inventory/*    - Stock management
   /trade/*        - Sales, Purchase orders
   /finance/*      - Receivables, Payables
   /403            - Access denied
   /404            - Not found
   ```

6. Updated configuration:
   - Added `@router/*` path alias to vite.config.ts and tsconfig.app.json
   - Updated main.tsx to use createBrowserRouter and RouterProvider

### Files created/modified
- `frontend/package.json` (added react-router-dom)
- `frontend/src/router/types.ts` (new)
- `frontend/src/router/lazyLoad.tsx` (new)
- `frontend/src/router/guards.tsx` (new)
- `frontend/src/router/routes.tsx` (new)
- `frontend/src/router/index.ts` (new)
- `frontend/src/pages/Dashboard.tsx` (new)
- `frontend/src/pages/Login.tsx` (new)
- `frontend/src/pages/NotFound.tsx` (new)
- `frontend/src/pages/Forbidden.tsx` (new)
- `frontend/src/pages/catalog/*.tsx` (new - 2 files)
- `frontend/src/pages/partner/*.tsx` (new - 3 files)
- `frontend/src/pages/inventory/*.tsx` (new - 1 file)
- `frontend/src/pages/trade/*.tsx` (new - 2 files)
- `frontend/src/pages/finance/*.tsx` (new - 2 files)
- `frontend/src/pages/index.ts` (updated)
- `frontend/src/main.tsx` (updated to use router)
- `frontend/vite.config.ts` (added @router alias)
- `frontend/tsconfig.app.json` (added @router alias)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (warnings expected for route config files)
- `npm run build` passes

### Notes for next developer
- P0-FE-004 (Zustand state management) is the next highest priority task
- P0-FE-006 (Layout components) depends on routing and can now be started
- Login page uses mock authentication (stores token in localStorage)
- AuthGuard reads `access_token` from localStorage - integrate with real auth in P6
- Placeholder pages are ready for actual implementation in P1/P2/P3/P4 phases
- Route metadata includes `permissions` field for future permission checks
- Use `lazyLoad()` helper for adding new lazy-loaded routes
- Use `getBreadcrumbs(path)` to generate breadcrumb navigation
- Semi Design illustrations package not compatible with React 19 - using icons instead

---

## 2026-01-23 - P0-FE-004: State Management Configuration (Zustand) Complete

### Completed
- **P0-FE-004**: 状态管理配置 (Zustand)

### What was done
1. Installed Zustand package:
   - `zustand` v5.x for React 19 compatibility

2. Created store directory structure at `src/store/`:
   - `types.ts` - Type definitions (User, AuthState, AuthActions, AppState, AppActions, BreadcrumbItem)
   - `authStore.ts` - Authentication store with persistence
   - `appStore.ts` - Application settings store with persistence
   - `createStore.ts` - Utility for creating stores with auto-selectors
   - `index.ts` - Module exports

3. Implemented Auth Store features:
   - User state (id, username, displayName, permissions, roles)
   - JWT token management (accessToken, refreshToken)
   - Persistent storage using Zustand's persist middleware
   - Permission checking utilities (hasPermission, hasAnyPermission, hasAllPermissions)
   - Login/logout actions
   - Backward compatibility with localStorage for existing guards
   - Devtools integration for debugging

4. Implemented App Store features:
   - Sidebar collapsed state (persistent)
   - Theme switching (light/dark) with Semi Design integration
   - Locale settings (persistent)
   - Page title and breadcrumbs (non-persistent)
   - Devtools integration for debugging

5. Selector hooks for common access patterns:
   - `useUser()`, `useIsAuthenticated()`, `useAuthLoading()` - Auth selectors
   - `useSidebarCollapsed()`, `useTheme()`, `useLocale()`, `useBreadcrumbs()`, `usePageTitle()` - App selectors

6. Updated existing components to use Zustand:
   - `Login.tsx` - Uses `useAuthStore().login()` instead of direct localStorage
   - `Dashboard.tsx` - Displays user info using `useUser()`, logout with `useAuthStore().logout()`
   - `router/guards.tsx` - Uses `useAuthStore()` for authentication and permission checks

### Files created/modified
- `frontend/package.json` (added zustand dependency)
- `frontend/src/store/types.ts` (new)
- `frontend/src/store/authStore.ts` (new)
- `frontend/src/store/appStore.ts` (new)
- `frontend/src/store/createStore.ts` (new)
- `frontend/src/store/index.ts` (updated with exports)
- `frontend/src/pages/Login.tsx` (updated to use auth store)
- `frontend/src/pages/Dashboard.tsx` (updated to show user info and logout)
- `frontend/src/router/guards.tsx` (updated to use auth store)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (warnings from existing route files, not new code)
- `npm run build` passes

### Usage Examples

**Auth Store:**
```tsx
import { useAuthStore, useUser, useIsAuthenticated } from '@/store'

// Get current user
const user = useUser()

// Check if authenticated
const isAuthenticated = useIsAuthenticated()

// Login
const login = useAuthStore((state) => state.login)
login({ id: '1', username: 'admin' }, 'jwt-token')

// Logout
const logout = useAuthStore((state) => state.logout)
logout()

// Check permissions
const { hasPermission, hasAnyPermission } = useAuthStore()
if (hasPermission('products:create')) {
  // User can create products
}
```

**App Store:**
```tsx
import { useAppStore, useTheme, useSidebarCollapsed } from '@/store'

// Get theme
const theme = useTheme()

// Toggle sidebar
const { toggleSidebar, setSidebarCollapsed } = useAppStore()
toggleSidebar()

// Toggle theme
const { toggleTheme, setTheme } = useAppStore()
toggleTheme()
setTheme('dark')

// Set page title (updates document.title)
const { setPageTitle } = useAppStore()
setPageTitle('Products')
```

### Notes for next developer
- P0-FE-006 (Layout components) is the next highest priority task
- P0-FE-007 (Form components) and P0-FE-008 (Table components) can also be started
- Auth store persists to localStorage under key `erp-auth`
- App store persists to localStorage under key `erp-app-settings`
- Theme changes automatically apply `theme-mode` attribute to document body for Semi Design
- Zustand devtools are available in React DevTools for debugging
- Use selector hooks (`useUser()`, `useTheme()`, etc.) for better performance
- The `createStoreWithSelectors` utility can be used for new stores with auto-selectors


---

## 2026-01-23 - P0-FE-006: Layout Components (Header, Sidebar, Content) Complete

### Completed
- **P0-FE-006**: 布局组件 (Header, Sidebar, Content)

### What was done
1. Created MainLayout component at `src/components/layout/MainLayout.tsx`:
   - Wraps protected routes with consistent layout structure
   - Uses React Router's `<Outlet>` for nested route rendering
   - Responsive margin adjustments based on sidebar collapse state

2. Created Sidebar component at `src/components/layout/Sidebar.tsx`:
   - Collapsible sidebar with Semi Design's Nav component
   - Dynamic navigation menu generated from route configuration
   - Active state highlighting based on current path
   - Nested menu support for domain modules
   - Logo area with ERP System branding
   - Collapse button integrated with Zustand app store

3. Created Header component at `src/components/layout/Header.tsx`:
   - Fixed header with breadcrumb navigation
   - Theme toggle (light/dark mode)
   - Notification bell placeholder
   - User avatar with dropdown menu (Profile, Settings, Logout)
   - Responsive design for mobile

4. Updated routes to use layout route pattern:
   - Public routes (login, error pages) render without layout
   - Protected routes wrapped in AuthGuard + MainLayout
   - Cleaner route configuration with metadata-driven approach

5. Added CSS variables for layout dimensions in `index.css`:
   - `--header-height: 60px`
   - `--sidebar-width: 220px`
   - `--sidebar-collapsed-width: 60px`

6. Updated Dashboard page:
   - Removed logout button (now in header)
   - Added statistics cards with icons
   - Added quick action buttons

### Files created/modified
- `frontend/src/components/layout/MainLayout.tsx` (new)
- `frontend/src/components/layout/MainLayout.css` (new)
- `frontend/src/components/layout/Sidebar.tsx` (new)
- `frontend/src/components/layout/Sidebar.css` (new)
- `frontend/src/components/layout/Header.tsx` (new)
- `frontend/src/components/layout/Header.css` (new)
- `frontend/src/components/layout/index.ts` (updated with exports)
- `frontend/src/router/routes.tsx` (updated to use MainLayout)
- `frontend/src/pages/Dashboard.tsx` (updated UI)
- `frontend/src/index.css` (added CSS variables)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (warnings expected for lazy-loaded routes)
- `npm run build` passes

### Layout Structure
```
+----------------------------------+
|          Header (fixed)          |
+--------+-------------------------+
|        |                         |
| Side-  |       Content           |
| bar    |       (Outlet)          |
| (fixed)|                         |
|        |                         |
+--------+-------------------------+
```

### Key Features
- Sidebar collapse persists via Zustand (localStorage)
- Theme toggle applies `theme-mode` attribute for Semi Design
- Breadcrumbs auto-generated from route path
- User dropdown with profile, settings, logout options
- Responsive design with mobile breakpoints

### Notes for next developer
- P0-FE-007 (Form components) is the next highest priority task
- P0-FE-008 (Table components) can also be started
- To add new pages, simply add route to appRoutes and corresponding page component
- Sidebar navigation auto-updates from route configuration
- Use `getBreadcrumbs(path)` utility for custom breadcrumb generation
- Semi Design Nav uses `isCollapsed` prop, not CSS for collapse state



---

## 2026-01-23 - P0-FE-007: Common Form Components Complete

### Completed
- **P0-FE-007**: 通用表单组件

### What was done
1. Installed form dependencies:
   - `react-hook-form` v7.71.1 - Form state management
   - `zod` v4.3.6 - Schema validation
   - `@hookform/resolvers` v5.2.2 - Zod resolver for react-hook-form

2. Created form components at `src/components/common/form/`:
   - `TextField.tsx` - Text input field with validation
   - `NumberField.tsx` - Number input field with min/max/precision
   - `TextAreaField.tsx` - Multi-line text field with character count
   - `SelectField.tsx` - Dropdown select with search support
   - `DateField.tsx` - Date picker with multiple output formats (ISO string, Date, timestamp)
   - `CheckboxField.tsx` - Single checkbox with label
   - `CheckboxGroupField.tsx` - Multiple checkboxes for multi-select
   - `RadioGroupField.tsx` - Radio button group with button/card styles
   - `SwitchField.tsx` - Toggle switch with custom text
   - `TreeSelectField.tsx` - Hierarchical tree select for categories

3. Created form layout components:
   - `Form.tsx` - Form wrapper with loading spinner
   - `FormActions.tsx` - Submit/Cancel button bar with alignment options
   - `FormSection.tsx` - Grouped form sections with title/description
   - `FormRow.tsx` - Grid-based multi-column field layout (1-4 columns)
   - `FormFieldWrapper.tsx` - Consistent label/error/helper styling

4. Created form utilities:
   - `useFormWithValidation.ts` - Custom hook wrapping react-hook-form with:
     - Zod schema validation integration
     - Server-side error handling
     - Toast notifications on success/error
     - Reset on success option
   - `validation.ts` - Pre-built validation schemas and helpers:
     - Common validation messages (Chinese localized)
     - Regex patterns (phone, SKU, barcode, etc.)
     - Pre-built schemas (email, phone, money, quantity, etc.)
     - Schema factory functions (createStringSchema, createNumberSchema, createEnumSchema)
     - Coercion helpers for form inputs

5. Created TypeScript types:
   - `types.ts` - Shared types for controlled fields, options, form config

### Files created
- `frontend/src/components/common/form/types.ts`
- `frontend/src/components/common/form/validation.ts`
- `frontend/src/components/common/form/FormFieldWrapper.tsx`
- `frontend/src/components/common/form/FormFieldWrapper.css`
- `frontend/src/components/common/form/TextField.tsx`
- `frontend/src/components/common/form/NumberField.tsx`
- `frontend/src/components/common/form/TextAreaField.tsx`
- `frontend/src/components/common/form/SelectField.tsx`
- `frontend/src/components/common/form/DateField.tsx`
- `frontend/src/components/common/form/CheckboxField.tsx`
- `frontend/src/components/common/form/RadioGroupField.tsx`
- `frontend/src/components/common/form/SwitchField.tsx`
- `frontend/src/components/common/form/TreeSelectField.tsx`
- `frontend/src/components/common/form/Form.tsx`
- `frontend/src/components/common/form/Form.css`
- `frontend/src/components/common/form/useFormWithValidation.ts`
- `frontend/src/components/common/form/index.ts`
- `frontend/src/components/common/index.ts` (updated)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only warnings from existing route files)
- `npm run build` passes

### Usage Examples

**Basic form with validation:**
```tsx
import { z } from 'zod'
import { useFormWithValidation, Form, FormActions, FormRow, TextField, NumberField, SelectField } from '@/components/common'

const schema = z.object({
  name: z.string().min(1, '名称为必填项'),
  price: z.number().positive('价格必须为正数'),
  category: z.string().min(1, '请选择分类'),
})

type FormData = z.infer<typeof schema>

function ProductForm() {
  const { control, handleFormSubmit, isSubmitting } = useFormWithValidation<FormData>({
    schema,
    successMessage: '保存成功',
  })

  const onSubmit = async (data: FormData) => {
    await api.createProduct(data)
  }

  return (
    <Form onSubmit={handleFormSubmit(onSubmit)} isSubmitting={isSubmitting}>
      <FormRow cols={2}>
        <TextField name="name" control={control} label="名称" required />
        <NumberField name="price" control={control} label="价格" min={0} precision={2} required />
      </FormRow>
      <SelectField
        name="category"
        control={control}
        label="分类"
        options={[
          { label: '电子产品', value: 'electronics' },
          { label: '服装', value: 'clothing' },
        ]}
        required
      />
      <FormActions isSubmitting={isSubmitting} onCancel={() => navigate(-1)} />
    </Form>
  )
}
```

### Notes for next developer
- P0-FE-008 (Table components) is the next highest priority task
- P0-FE-009 (Vitest testing) can also be started
- All form fields use Semi Design components under the hood
- Zod 4.x has a slightly different API than Zod 3 - use `message` instead of `invalid_type_error` for number schemas
- The `useFormWithValidation` hook handles server-side validation errors automatically if API returns `details` array
- Use `schemas.*` for common field types (email, phone, money, etc.)
- Use `patterns.*` for regex patterns (phone, SKU, barcode, etc.)
- Form fields support `labelPosition` ('top', 'left', 'inset') for different layouts
- TreeSelectField is ready for category hierarchies in P1-FE-003



---

## 2026-01-24 - P0-FE-DS: Frontend Design System Complete

### Completed
- **P0-FE-DS**: 前端设计规范体系 (Design System)

### What was done
1. Created comprehensive design token system at `src/styles/tokens/`:
   - `breakpoints.css` - Responsive breakpoint system (375px/768px/1024px/1440px)
   - `colors.css` - Color palette with semantic tokens, dark mode, and elder-friendly theme support
   - `spacing.css` - 4px-based spacing scale with component-specific spacing
   - `typography.css` - Font families, sizes, weights, line heights with font scaling
   - `shadows.css` - Elevation shadow system with dark mode variants
   - `animations.css` - Duration, easing, and keyframe animations with reduced motion support

2. Created accessibility utilities at `src/styles/accessibility.css`:
   - Focus management (:focus-visible, focus-within)
   - Skip links for keyboard navigation
   - Screen reader utilities (sr-only, aria-live)
   - High contrast mode support (@media prefers-contrast)
   - Forced colors mode support (Windows High Contrast)
   - Touch target sizing (44x44px minimum)
   - Color blind safe status indicators

3. Created responsive layout components at `src/components/common/layout/`:
   - `Container.tsx` - Responsive centered container with configurable max-widths
   - `Grid.tsx` - CSS Grid component with responsive column support and GridItem
   - `Flex.tsx` - Flexbox utilities including Stack, Row, Spacer, and Divider components

4. Created theme management hooks at `src/hooks/useTheme.ts`:
   - `useThemeManager()` - Theme switching (light/dark/elder)
   - `useFontScale()` - Font scaling for accessibility
   - `useAccessibilityPreferences()` - Detect reduced motion and high contrast preferences
   - System theme detection and auto-switching

5. Created responsive grid CSS utilities at `src/styles/utilities/grid.css`:
   - Responsive grid column classes for all breakpoints
   - Mobile-first approach

6. Updated frontend/README.md with comprehensive design system documentation:
   - Technology stack overview
   - Responsive design guidelines and breakpoints
   - CSS architecture and conventions
   - Design tokens reference (colors, spacing, typography, shadows, animations)
   - Layout component usage examples
   - Theme system documentation
   - Accessibility (WCAG 2.1 AA) requirements and utilities
   - Interaction design principles
   - Component guidelines and best practices
   - File structure reference

7. Updated root CLAUDE.md:
   - Added reference to frontend/README.md as required reading
   - Added frontend development guidelines section
   - Emphasized design token usage, responsive design, and accessibility requirements

### Files created
- `frontend/src/styles/tokens/breakpoints.css`
- `frontend/src/styles/tokens/colors.css`
- `frontend/src/styles/tokens/spacing.css`
- `frontend/src/styles/tokens/typography.css`
- `frontend/src/styles/tokens/shadows.css`
- `frontend/src/styles/tokens/animations.css`
- `frontend/src/styles/tokens/index.css`
- `frontend/src/styles/accessibility.css`
- `frontend/src/styles/utilities/grid.css`
- `frontend/src/styles/index.css`
- `frontend/src/components/common/layout/Container.tsx`
- `frontend/src/components/common/layout/Grid.tsx`
- `frontend/src/components/common/layout/Flex.tsx`
- `frontend/src/components/common/layout/index.ts`
- `frontend/src/hooks/useTheme.ts`

### Files modified
- `frontend/src/main.tsx` (imports design system styles)
- `frontend/src/hooks/index.ts` (exports theme hooks)
- `frontend/src/components/common/index.ts` (exports layout components)
- `frontend/vite.config.ts` (added @styles alias)
- `frontend/tsconfig.app.json` (added @styles path alias)
- `frontend/README.md` (complete rewrite with design system documentation)
- `CLAUDE.md` (added frontend guidelines and README reference)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only warnings from existing router files)
- `npm run build` passes

### Design System Summary

| Feature | Implementation |
|---------|----------------|
| Breakpoints | Mobile 375px / Tablet 768px / Desktop 1024px / Wide 1440px |
| CSS Architecture | CSS Variables + CSS Modules + BEM naming |
| Color Tokens | 10-level scales for primary/success/warning/danger/neutral |
| Spacing | 4px grid system with component-specific tokens |
| Typography | rem-based font sizes with 4 scale levels |
| Shadows | 5-level elevation system |
| Animations | Duration/easing tokens with reduced motion support |
| Themes | Light, Dark, Elder-friendly |
| Accessibility | WCAG 2.1 AA, focus management, screen reader support |
| Layout Components | Container, Grid, GridItem, Flex, Stack, Row, Spacer, Divider |

### Usage Examples

```tsx
// Layout with responsive grid
import { Container, Grid, Stack, Row, Spacer } from '@/components/common'

<Container size="lg">
  <Grid cols={{ mobile: 1, tablet: 2, desktop: 4 }} gap="md">
    <Card>Item 1</Card>
    <Card>Item 2</Card>
  </Grid>
</Container>

// Theme management
import { useThemeManager, useFontScale } from '@/hooks'

const { theme, setTheme } = useThemeManager()
const { fontScale, setFontScale } = useFontScale()
```

### Notes for next developer
- P0-FE-008 (Table components) is the next highest priority task
- P0-FE-009 (Vitest testing) can also be started
- Always use design tokens via CSS variables (e.g., `--spacing-4`, `--color-primary`)
- Test components in all three themes (light, dark, elder)
- Layout components (Container, Grid, Flex) should be used for all page layouts
- Accessibility utilities (`sr-only`, `skip-link`, etc.) are available globally
- Font scaling works via `data-font-scale` attribute on `<html>` element
- Reduced motion is automatically respected via CSS `prefers-reduced-motion` media query


---

## 2026-01-24 - P0-FE-008: Common Table Components Complete

### Completed
- **P0-FE-008**: 通用表格组件

### What was done
1. Created comprehensive table component system at `src/components/common/table/`:
   - `types.ts` - Type definitions for DataTable, columns, actions, filters, sorting
   - `useTableState.ts` - Hook for managing pagination, sorting, and filtering state
   - `DataTable.tsx` - Main table component based on Semi Design Table
   - `DataTable.css` - Styles following design system tokens
   - `TableActions.tsx` - Row action buttons with dropdown overflow and confirmation support
   - `TableActions.css` - Action button styles
   - `TableToolbar.tsx` - Search, filters, and action buttons toolbar
   - `TableToolbar.css` - Toolbar styles
   - `index.ts` - Module exports

2. DataTable features implemented:
   - Server-side pagination with configurable page sizes
   - Column sorting (click to toggle asc/desc/none)
   - Row selection with checkbox/radio support
   - Row actions with automatic overflow to dropdown menu
   - Confirmation dialogs for dangerous actions
   - Loading state with spinner overlay
   - Empty state with customizable content
   - Sticky header support
   - Resizable columns
   - Expandable rows

3. useTableState hook features:
   - Manages pagination, sort, and filter state
   - Resets to page 1 when sort/filter changes
   - `toApiParams()` converts state to API request parameters
   - `handleStateChange()` for controlled updates from DataTable

4. TableToolbar component:
   - Search input with debounce support
   - Primary action button (e.g., "Add New")
   - Secondary action buttons
   - Filter slot for custom filter components
   - Bulk action bar when rows are selected

5. TableActions component:
   - Direct action buttons (up to 3 visible by default)
   - Overflow dropdown for additional actions
   - Popconfirm for actions requiring confirmation
   - Modal fallback for dropdown items with confirmation
   - Supports disabled/hidden states per record

### Files created
- `frontend/src/components/common/table/types.ts`
- `frontend/src/components/common/table/useTableState.ts`
- `frontend/src/components/common/table/DataTable.tsx`
- `frontend/src/components/common/table/DataTable.css`
- `frontend/src/components/common/table/TableActions.tsx`
- `frontend/src/components/common/table/TableActions.css`
- `frontend/src/components/common/table/TableToolbar.tsx`
- `frontend/src/components/common/table/TableToolbar.css`
- `frontend/src/components/common/table/index.ts`

### Files modified
- `frontend/src/components/common/index.ts` (added table exports)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings)
- `npm run build` passes

### Usage Examples

**Basic DataTable:**
```tsx
import { DataTable, useTableState, DataTableColumn, TableAction } from '@/components/common'

interface Product {
  id: string
  name: string
  sku: string
  price: number
  status: 'active' | 'inactive'
}

const columns: DataTableColumn<Product>[] = [
  { title: '商品名称', dataIndex: 'name', sortable: true },
  { title: 'SKU', dataIndex: 'sku', width: 120 },
  { title: '价格', dataIndex: 'price', align: 'right', sortable: true },
  { title: '状态', dataIndex: 'status', render: (status) => <StatusTag status={status} /> },
]

const actions: TableAction<Product>[] = [
  { key: 'edit', label: '编辑', onClick: (record) => handleEdit(record) },
  {
    key: 'delete',
    label: '删除',
    type: 'danger',
    onClick: (record) => handleDelete(record),
    confirm: { title: '确认删除', content: '删除后无法恢复' },
  },
]

function ProductList() {
  const { state, handleStateChange, toApiParams } = useTableState({
    defaultPageSize: 20,
    defaultSortField: 'created_at',
    defaultSortOrder: 'desc',
  })

  const { data, isLoading } = useQuery(['products', toApiParams()], () =>
    fetchProducts(toApiParams())
  )

  return (
    <DataTable
      data={data?.data || []}
      columns={columns}
      rowKey="id"
      loading={isLoading}
      pagination={data?.meta}
      actions={actions}
      onStateChange={handleStateChange}
      sortState={state.sort}
    />
  )
}
```

**With TableToolbar:**
```tsx
import { TableToolbar, BulkActionBar, DataTable } from '@/components/common'

function ProductListPage() {
  const [selectedRowKeys, setSelectedRowKeys] = useState<string[]>([])

  return (
    <div>
      <TableToolbar
        searchValue={keyword}
        onSearchChange={setKeyword}
        searchPlaceholder="搜索商品名称、SKU..."
        primaryAction={{
          label: '新增商品',
          onClick: () => navigate('/catalog/products/new'),
        }}
      />

      {selectedRowKeys.length > 0 && (
        <BulkActionBar
          selectedCount={selectedRowKeys.length}
          onCancel={() => setSelectedRowKeys([])}
        >
          <Button onClick={handleBulkEnable}>批量启用</Button>
          <Button type="danger" onClick={handleBulkDelete}>批量删除</Button>
        </BulkActionBar>
      )}

      <DataTable
        data={products}
        columns={columns}
        rowKey="id"
        rowSelection={{
          selectedRowKeys,
          onChange: setSelectedRowKeys,
        }}
      />
    </div>
  )
}
```

### Notes for next developer
- P0-FE-009 (Vitest testing) is the next highest priority task
- P1-FE-001 (Product list page) can now use these table components
- All table components follow the design system tokens from `src/styles/tokens/`
- DataTable requires `rowKey` prop (string field name or function)
- Use `useTableState` hook for server-side pagination/sorting
- Actions with `confirm` property show Popconfirm before executing
- For large datasets, enable `sticky` prop for sticky header
- Row selection uses string[] for selectedRowKeys (convert from API if needed)


---

## 2026-01-24 - P0-FE-009: Frontend Test Framework Configuration (Vitest) Complete

### Completed
- **P0-FE-009**: 前端测试框架配置 (Vitest)

### What was done
1. Installed testing dependencies:
   - `vitest` v4.x - Test runner compatible with Vite
   - `@testing-library/react` v16.x - React component testing utilities
   - `@testing-library/jest-dom` v6.x - Custom DOM matchers
   - `@testing-library/user-event` v14.x - User interaction simulation
   - `@vitest/coverage-v8` v4.x - Code coverage with V8 provider
   - `jsdom` v27.x - DOM environment for tests

2. Configured Vitest in `vite.config.ts`:
   - Using `vitest/config` for proper TypeScript support
   - JSDOM environment for browser-like testing
   - Global test APIs (describe, it, expect)
   - Coverage configuration with 80% threshold
   - Proper exclusions for auto-generated files and test files

3. Created test setup at `src/tests/setup.ts`:
   - Jest-DOM matchers integration
   - Auto-cleanup after each test
   - Browser API mocks (matchMedia, ResizeObserver, IntersectionObserver)
   - Storage mocks (localStorage, sessionStorage)
   - Console suppression for cleaner test output

4. Created test utilities at `src/tests/`:
   - `utils.tsx` - Custom render functions with providers:
     - `renderWithProviders()` - Renders with Router context
     - `renderWithUser()` - Renders with user-event setup
     - Mock API response helpers (success, error, paginated)
   - `index.ts` - Re-exports for convenient importing

5. Added path alias `@tests/*` in both Vite and TypeScript configs

6. Added npm scripts:
   - `npm run test` - Interactive watch mode
   - `npm run test:run` - Single run for CI
   - `npm run test:ui` - Vitest UI (requires @vitest/ui)
   - `npm run test:coverage` - Run with coverage report
   - `npm run test:watch` - Watch mode

7. Created example tests:
   - `src/store/authStore.test.ts` - 10 tests for Zustand auth store
   - `src/components/common/form/validation.test.ts` - 27 tests for validation schemas
   - `src/tests/utils.test.tsx` - 12 tests for test utilities

### Files created/modified
- `frontend/package.json` (added test dependencies and scripts)
- `frontend/vite.config.ts` (added Vitest configuration)
- `frontend/tsconfig.app.json` (added vitest types and @tests alias)
- `frontend/src/tests/setup.ts` (new)
- `frontend/src/tests/utils.tsx` (new)
- `frontend/src/tests/index.ts` (new)
- `frontend/src/tests/utils.test.tsx` (new)
- `frontend/src/store/authStore.test.ts` (new)
- `frontend/src/components/common/form/validation.test.ts` (new)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings)
- `npm run build` passes
- `npm run test:run` passes (49 tests)

### Test Statistics
| Test File | Tests |
|-----------|-------|
| authStore.test.ts | 10 |
| validation.test.ts | 27 |
| utils.test.tsx | 12 |
| **Total** | **49** |

### Usage Examples

**Running tests:**
```bash
npm run test           # Interactive watch mode
npm run test:run       # Single run (CI)
npm run test:coverage  # With coverage report
```

**Writing a component test:**
```tsx
import { describe, it, expect } from 'vitest'
import { renderWithProviders, screen, waitFor } from '@tests'

describe('MyComponent', () => {
  it('should render correctly', async () => {
    const { user } = renderWithProviders(<MyComponent />)
    
    expect(screen.getByText('Hello')).toBeInTheDocument()
    
    await user.click(screen.getByRole('button'))
    
    await waitFor(() => {
      expect(screen.getByText('Clicked!')).toBeInTheDocument()
    })
  })
})
```

**Writing a store test:**
```tsx
import { describe, it, expect, beforeEach } from 'vitest'
import { act } from '@testing-library/react'
import { useMyStore } from '@store/myStore'

describe('useMyStore', () => {
  beforeEach(() => {
    // Reset store state
    act(() => {
      useMyStore.getState().reset()
    })
  })

  it('should update state', () => {
    act(() => {
      useMyStore.getState().setValue('test')
    })
    
    expect(useMyStore.getState().value).toBe('test')
  })
})
```

### Notes for next developer
- All P0 frontend tasks are now complete (except prototype design tasks P0-PD-*)
- P1-FE-* tasks (Product/Partner features) can now begin
- Use `@tests` import alias for test utilities
- Run `npm run test:coverage` to check coverage (80% threshold enforced)
- Browser API mocks are pre-configured in setup.ts
- For async tests, use `waitFor()` instead of `setTimeout()`
- Storage mocks reset before each test automatically

---

## 2026-01-24 - P1-BE-001: Category Aggregate Implementation Complete

### Completed
- **P1-BE-001**: Category 聚合实现

### What was done
1. Created Category aggregate root at `internal/domain/catalog/category.go`:
   - `Category` struct with TenantAggregateRoot embedding for multi-tenant support
   - Tree structure using materialized path pattern (`path` field stores ancestor chain)
   - `NewCategory()` - Creates root category
   - `NewChildCategory()` - Creates child category under a parent
   - `Update()`, `UpdateCode()` - Updates category information
   - `Activate()`, `Deactivate()` - Status management
   - `SetSortOrder()` - Display order management
   - `IsRoot()`, `IsActive()` - State queries
   - `GetAncestorIDs()`, `IsAncestorOf()`, `IsDescendantOf()` - Tree traversal helpers
   - Maximum depth enforcement (5 levels)
   - Validation for code (alphanumeric + underscore/hyphen) and name

2. Created domain events at `internal/domain/catalog/category_events.go`:
   - `CategoryCreatedEvent` - Published when category is created
   - `CategoryUpdatedEvent` - Published when category is updated
   - `CategoryStatusChangedEvent` - Published on activate/deactivate
   - `CategoryDeletedEvent` - For deletion tracking

3. Created repository interface at `internal/domain/catalog/category_repository.go`:
   - `CategoryRepository` interface with methods for:
     - CRUD operations (`FindByID`, `FindByCode`, `Save`, `Delete`)
     - Tree queries (`FindChildren`, `FindRootCategories`, `FindDescendants`)
     - Multi-tenant support (`FindByIDForTenant`, `FindAllForTenant`)
     - Existence checks (`ExistsByCode`, `HasChildren`, `HasProducts`)
     - Path management (`UpdatePath` for moving categories)

4. Created GORM repository implementation at `internal/infrastructure/persistence/category_repository.go`:
   - `GormCategoryRepository` implementing `CategoryRepository`
   - Full CRUD with tenant scoping
   - Tree operations using materialized path queries
   - Filter support (search, status, parent_id, level)
   - Pagination and ordering

5. Created database migration:
   - `migrations/000003_create_categories.up.sql`
     - Categories table with tenant_id, code, name, parent_id, path, level, sort_order, status
     - Indexes for efficient tree and tenant queries
     - Check constraints for status and level
     - Unique constraint on (tenant_id, code)
   - `migrations/000003_create_categories.down.sql` - Rollback script

6. Created comprehensive unit tests at `internal/domain/catalog/category_test.go`:
   - 38 test cases covering all category functionality
   - Tests for creation, updates, status changes
   - Tests for tree structure (parent-child, ancestors, descendants)
   - Tests for validation (code, name)
   - Tests for domain events

### Files created
- `backend/internal/domain/catalog/category.go`
- `backend/internal/domain/catalog/category_events.go`
- `backend/internal/domain/catalog/category_repository.go`
- `backend/internal/domain/catalog/category_test.go`
- `backend/internal/infrastructure/persistence/category_repository.go`
- `backend/migrations/000003_create_categories.up.sql`
- `backend/migrations/000003_create_categories.down.sql`

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests (38 new tests in catalog package)

### Key Design Decisions
1. **Materialized Path**: Uses `/`-separated UUID path for efficient tree queries
   - Example: `parentID/childID/grandchildID`
   - Supports prefix matching for descendant queries
   - Updates require path propagation to descendants
2. **Max Depth**: 5 levels to prevent overly deep hierarchies
3. **Code Uniqueness**: Unique per tenant, stored in uppercase
4. **Optimistic Locking**: Version field for concurrent update handling
5. **Soft Status**: Active/Inactive instead of hard delete for data integrity

### Usage Examples
```go
// Create root category
electronics, _ := catalog.NewCategory(tenantID, "ELECTRONICS", "Electronics")

// Create child category
phones, _ := catalog.NewChildCategory(tenantID, "PHONES", "Phones", electronics)

// Update category
phones.Update("Smartphones", "All smartphone products")

// Status management
phones.Deactivate()
phones.Activate()

// Tree queries
ancestors := phones.GetAncestorIDs()       // [electronics.ID]
isChild := electronics.IsAncestorOf(phones) // true
```

### Notes for next developer
- P1-BE-002 (Product aggregate) can now be started - it depends on Category
- Category code is automatically uppercased on creation/update
- Path format: `uuid1/uuid2/uuid3` (no leading or trailing slash)
- Repository's `HasProducts()` returns false until Product is implemented
- Run `./bin/migrate up` to apply the categories migration
- For moving categories to new parent, use `UpdatePath()` method


---

## 2026-01-24 - P1-BE-002: Product Aggregate Root Implementation Complete

### Completed
- **P1-BE-002**: Product 聚合根实现

### What was done
1. Created Product aggregate root at `internal/domain/catalog/product.go`:
   - `Product` struct extending `TenantAggregateRoot` for multi-tenant support
   - Fields: Code, Name, Description, Barcode, CategoryID, Unit, PurchasePrice, SellingPrice, MinStock, Status, SortOrder, Attributes
   - `NewProduct()` - Factory for creating products with validation
   - `NewProductWithPrices()` - Factory with prices
   - `Update()`, `UpdateCode()`, `SetBarcode()`, `SetCategory()` - Basic updates
   - `SetPrices()`, `UpdatePurchasePrice()`, `UpdateSellingPrice()` - Price management
   - `SetMinStock()`, `SetSortOrder()`, `SetAttributes()` - Additional settings
   - `Activate()`, `Deactivate()`, `Discontinue()` - Status management (three states: active/inactive/discontinued)
   - `GetProfitMargin()`, `GetPurchasePriceMoney()`, `GetSellingPriceMoney()` - Business calculations
   - Validation for code (alphanumeric + underscore/hyphen), name (max 200 chars), unit (max 20 chars)

2. Created domain events at `internal/domain/catalog/product_events.go`:
   - `ProductCreatedEvent` - Published on creation
   - `ProductUpdatedEvent` - Published on updates
   - `ProductStatusChangedEvent` - Published on status changes
   - `ProductPriceChangedEvent` - Published on price changes
   - `ProductDeletedEvent` - For deletion tracking
   - All events embed `BaseDomainEvent` with tenant support

3. Created ProductRepository interface at `internal/domain/catalog/product_repository.go`:
   - Standard CRUD: `FindByID`, `FindByIDForTenant`, `Save`, `Delete`, `DeleteForTenant`
   - Query methods: `FindByCode`, `FindByBarcode`, `FindAll`, `FindAllForTenant`
   - Category queries: `FindByCategory`, `FindByCategories`
   - Status queries: `FindActive`, `FindByStatus`
   - Batch operations: `FindByIDs`, `FindByCodes`, `SaveBatch`
   - Count methods: `Count`, `CountForTenant`, `CountByCategory`, `CountByStatus`
   - Existence checks: `ExistsByCode`, `ExistsByBarcode`

4. Created GORM repository implementation at `internal/infrastructure/persistence/product_repository.go`:
   - Full implementation of ProductRepository interface
   - Tenant scoping on all queries
   - Filter support: search (name/code/barcode), status, category_id, unit, min_price, max_price, has_barcode
   - Pagination and ordering support
   - Default ordering by sort_order, name

5. Created database migration `000004_create_products`:
   - Products table with tenant foreign key
   - Composite unique index on (tenant_id, code)
   - Foreign key to categories
   - Decimal fields for prices (18,4 precision)
   - JSONB for custom attributes
   - Indexes for efficient querying (tenant, category, barcode, status)
   - Trigger for updated_at timestamp

6. Comprehensive unit tests at `internal/domain/catalog/product_test.go`:
   - 67 test cases covering all Product functionality
   - Tests for creation, updates, status changes
   - Tests for price management
   - Tests for validation (code, name, unit)
   - Tests for domain events
   - Tests for business calculations (profit margin)

### Files created
- `backend/internal/domain/catalog/product.go`
- `backend/internal/domain/catalog/product_events.go`
- `backend/internal/domain/catalog/product_repository.go`
- `backend/internal/domain/catalog/product_test.go`
- `backend/internal/infrastructure/persistence/product_repository.go`
- `backend/migrations/000004_create_products.up.sql`
- `backend/migrations/000004_create_products.down.sql`

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests (67 new tests in product)

### Key Design Decisions
1. **Three-state status**: Active, Inactive, Discontinued (discontinued cannot be reactivated)
2. **Decimal prices**: Using `decimal.Decimal` for precision, 4 decimal places in DB
3. **JSONB attributes**: Flexible custom attributes stored as JSON
4. **Code normalization**: Codes stored uppercase for consistency
5. **Category reference**: Soft reference to Category (SET NULL on delete)

### Usage Examples
```go
// Create product
product, _ := catalog.NewProduct(tenantID, "SKU-001", "Widget", "pcs")

// Set prices
purchasePrice := valueobject.NewMoneyCNYFromFloat(50.00)
sellingPrice := valueobject.NewMoneyCNYFromFloat(100.00)
product.SetPrices(purchasePrice, sellingPrice)

// Set category
product.SetCategory(&categoryID)

// Status management
product.Deactivate()
product.Activate()
product.Discontinue() // Cannot reactivate after this

// Calculate profit margin
margin := product.GetProfitMargin() // 100% for (100-50)/50*100
```

### Notes for next developer
- P1-BE-003 (Product Repository) is also done as part of this task
- P1-BE-004 (Product Application Service) can now be started
- P1-BE-007 (Product domain events) is also done as part of this task
- Product code is automatically uppercased on creation/update
- Use `NewProductWithPrices()` when you need to set prices during creation
- Discontinued products cannot be activated or deactivated
- Repository implements interface check: `var _ catalog.ProductRepository = (*GormProductRepository)(nil)`
- Run `./bin/migrate up` to apply the products migration



---

## 2026-01-24 - P1-BE-004: Product Application Service Complete

### Completed
- **P1-BE-004**: Product Application Service
- **P1-BE-003**: Product Repository 接口 + 实现 (was already done in P1-BE-002, marking as complete)
- **P1-BE-007**: Product 领域事件发布 (was already done in P1-BE-002, marking as complete)

### What was done
1. Created application service directory structure at `internal/application/catalog/`

2. Created product DTOs at `internal/application/catalog/dto.go`:
   - `CreateProductRequest` - Request for creating new products
   - `UpdateProductRequest` - Request for updating products (partial updates)
   - `UpdateProductCodeRequest` - Request for changing product code
   - `ProductResponse` - Full product response with all fields including profit margin
   - `ProductListResponse` - Simplified response for list views
   - `ProductListFilter` - Filter options for product listing
   - Converter functions: `ToProductResponse()`, `ToProductListResponse()`, `ToProductListResponses()`

3. Created Product Application Service at `internal/application/catalog/product_service.go`:
   - `ProductService` struct with ProductRepository and CategoryRepository dependencies
   - `Create()` - Create product with validation (duplicate code/barcode, category existence)
   - `GetByID()` - Get product by ID for tenant
   - `GetByCode()` - Get product by code for tenant
   - `List()` - List products with filtering, pagination, and sorting
   - `Update()` - Partial update of product fields
   - `UpdateCode()` - Update product code with duplicate check
   - `Delete()` - Delete product (with existence check)
   - `Activate()` - Activate inactive product
   - `Deactivate()` - Deactivate active product
   - `Discontinue()` - Discontinue product (cannot be reactivated)
   - `GetByCategory()` - Get products by category ID
   - `CountByStatus()` - Get product counts grouped by status

4. Created comprehensive unit tests at `internal/application/catalog/product_service_test.go`:
   - 23 test cases covering all service methods
   - Mock implementations for ProductRepository and CategoryRepository
   - Tests for success cases, validation errors, and domain errors
   - Tests for status transitions and business rules

### Files created
- `backend/internal/application/catalog/dto.go`
- `backend/internal/application/catalog/product_service.go`
- `backend/internal/application/catalog/product_service_test.go`

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests (23 new tests in application/catalog package)

### Key Design Decisions
1. **Separate DTOs from Domain**: Application layer has its own DTOs to decouple from domain models
2. **Tenant Scoping**: All operations are scoped to tenant ID from context
3. **Validation at Service Level**: Business rule validation (duplicate code/barcode, category existence) in service
4. **Partial Updates**: UpdateProductRequest uses pointers for optional fields
5. **Repository Injection**: Service depends on interfaces, not implementations (DI ready)

### Usage Examples
```go
// Create service
productRepo := persistence.NewGormProductRepository(db)
categoryRepo := persistence.NewGormCategoryRepository(db)
productService := catalog.NewProductService(productRepo, categoryRepo)

// Create product
req := catalog.CreateProductRequest{
    Code: "SKU-001",
    Name: "Widget",
    Unit: "pcs",
    PurchasePrice: decimal.NewFromFloat(50.00),
    SellingPrice: decimal.NewFromFloat(100.00),
}
product, err := productService.Create(ctx, tenantID, req)

// List products with filters
filter := catalog.ProductListFilter{
    Search:   "widget",
    Status:   "active",
    Page:     1,
    PageSize: 20,
}
products, total, err := productService.List(ctx, tenantID, filter)

// Update product
updateReq := catalog.UpdateProductRequest{
    Name: stringPtr("Updated Widget"),
}
updated, err := productService.Update(ctx, tenantID, productID, updateReq)

// Status changes
_, err = productService.Deactivate(ctx, tenantID, productID)
_, err = productService.Activate(ctx, tenantID, productID)
_, err = productService.Discontinue(ctx, tenantID, productID)
```

### Notes for next developer
- P1-BE-005 (Product API) can now be started - service layer is ready
- Application service handles validation and orchestration
- Domain events are already published by the domain layer (P1-BE-002)
- Use the DTOs for HTTP request/response handling
- Service methods return domain errors which can be converted to HTTP errors using handlers


---

## 2026-01-24 - P1-BE-005: Product API (CRUD + enable/disable) Complete

### Completed
- **P1-BE-005**: Product API (CRUD + enable/disable)

### What was done
1. Created Product HTTP handler at `internal/interfaces/http/handler/product.go`:
   - Full CRUD operations: Create, GetByID, GetByCode, List, Update, UpdateCode, Delete
   - Status management: Activate, Deactivate, Discontinue
   - Utility endpoints: CountByStatus, GetByCategory
   - Complete Swagger/OpenAPI annotations for all endpoints

2. Created Swagger-friendly DTOs at `internal/interfaces/http/handler/product_dto.go`:
   - `ProductResponse` with swagger example annotations
   - `ProductListResponse` for list views
   - `ProductListItem` for paginated responses

3. Created helper functions at `internal/interfaces/http/handler/helpers.go`:
   - `toDecimalPtr()` - Convert float64 to *decimal.Decimal
   - `toDecimal()` - Convert float64 to decimal.Decimal

4. Registered routes in `cmd/server/main.go`:
   - Initialized repositories (product, category)
   - Initialized ProductService with dependencies
   - Initialized ProductHandler
   - Registered all routes under `/api/v1/catalog/products`

5. Regenerated OpenAPI documentation:
   - `backend/docs/swagger.yaml`
   - `backend/docs/swagger.json`
   - `backend/docs/docs.go`

6. Created comprehensive unit tests at `internal/interfaces/http/handler/product_test.go`:
   - 17 test cases covering all handler methods
   - Mock implementations for ProductRepository and CategoryRepository
   - Tests for success cases, validation errors, not found errors

### Files created
- `backend/internal/interfaces/http/handler/product.go`
- `backend/internal/interfaces/http/handler/product_dto.go`
- `backend/internal/interfaces/http/handler/helpers.go`
- `backend/internal/interfaces/http/handler/product_test.go`

### Files modified
- `backend/cmd/server/main.go` - Route registration
- `backend/docs/swagger.yaml` - OpenAPI spec
- `backend/docs/swagger.json` - OpenAPI spec
- `backend/docs/docs.go` - Swagger embed

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests (17 new handler tests)

### API Endpoints

| Method | Path | Description |
|--------|------|-------------|
| POST | /api/v1/catalog/products | Create a new product |
| GET | /api/v1/catalog/products | List products with filters |
| GET | /api/v1/catalog/products/:id | Get product by ID |
| GET | /api/v1/catalog/products/code/:code | Get product by code |
| PUT | /api/v1/catalog/products/:id | Update product |
| PUT | /api/v1/catalog/products/:id/code | Update product code |
| DELETE | /api/v1/catalog/products/:id | Delete product |
| PUT | /api/v1/catalog/products/:id/activate | Activate product |
| PUT | /api/v1/catalog/products/:id/deactivate | Deactivate product |
| PUT | /api/v1/catalog/products/:id/discontinue | Discontinue product |
| GET | /api/v1/catalog/products/count-by-status | Count products by status |
| GET | /api/v1/catalog/products/category/:category_id | Get products by category |

### Key Design Decisions
1. **X-Tenant-ID Header**: All endpoints require tenant ID via header for multi-tenancy
2. **Swagger Annotations**: Full OpenAPI 3.0 documentation for frontend SDK generation
3. **Error Handling**: Uses BaseHandler's error methods for consistent error responses
4. **Separation of DTOs**: Handler-level DTOs for Swagger, application-level DTOs for service

### Usage Examples
```bash
# Create product
curl -X POST http://localhost:8080/api/v1/catalog/products \
  -H "Content-Type: application/json" \
  -H "X-Tenant-ID: 550e8400-e29b-41d4-a716-446655440000" \
  -d '{"code":"SKU-001","name":"Widget","unit":"pcs"}'

# List products with filters
curl "http://localhost:8080/api/v1/catalog/products?search=widget&status=active&page=1&page_size=20" \
  -H "X-Tenant-ID: 550e8400-e29b-41d4-a716-446655440000"

# Activate product
curl -X PUT http://localhost:8080/api/v1/catalog/products/123/activate \
  -H "X-Tenant-ID: 550e8400-e29b-41d4-a716-446655440000"
```

### Notes for next developer
- P1-FE-001 (Product List Page) can now be started - API is ready
- Run `npm run api:generate` in frontend to generate TypeScript SDK from updated OpenAPI spec
- All endpoints are documented in Swagger UI at /swagger/index.html
- Handler tests use mock repositories - integration tests will need real database

---

## 2026-01-24 - P1-FE-001: Product List Page Complete

### Completed
- **P1-FE-001**: 商品列表页面 (Product List Page)

### What was done
1. Regenerated TypeScript SDK from backend OpenAPI spec using `npm run api:generate`
2. Updated axios-instance.ts to include X-Tenant-ID header from user data in localStorage
3. Created comprehensive Product list page (`frontend/src/pages/catalog/Products.tsx`) with:
   - DataTable integration with full pagination and sorting
   - Search functionality (name, code, barcode)
   - Status filter dropdown (全部状态/启用/禁用/停售)
   - Row actions: view, edit, activate, deactivate, discontinue, delete
   - Bulk actions: batch activate/deactivate selected products
   - Confirmation modals for destructive actions (discontinue, delete)
   - Proper TypeScript types with DataTable compatibility
4. Created Products.css for product page styling
5. Fixed all TypeScript and ESLint errors

### Files created/modified
- `frontend/src/pages/catalog/Products.tsx` - Complete rewrite with full functionality
- `frontend/src/pages/catalog/Products.css` - New styling file
- `frontend/src/services/axios-instance.ts` - Added X-Tenant-ID header support
- `frontend/src/api/` - Regenerated SDK from backend OpenAPI spec

### Technical decisions
- Created intersection type `type Product = HandlerProductListResponse & Record<string, unknown>` for DataTable generic constraint compatibility
- Used callbacks with useCallback for all handlers to prevent unnecessary re-renders
- Status filter uses Semi Design Select component with consistent styling
- Bulk actions use Promise.all for parallel API calls

### Notes for next developer
- P1-FE-002 (Product Form) is the natural next step
- The product list page navigates to `/catalog/products/new` and `/catalog/products/:id/edit` which need to be implemented
- Product view page at `/catalog/products/:id` also needs implementation
- Consider adding category filter once P1-FE-003 (Category Management) is complete
- Build passes with expected chunk size warnings (vendor chunk ~693KB)


---

## 2026-01-24 - P1-FE-002: Product Add/Edit Form Complete

### Completed
- **P1-FE-002**: 商品新增/编辑表单 (Product Add/Edit Form)

### What was done
1. Created ProductForm component at `src/features/catalog/ProductForm.tsx`:
   - Zod schema validation for all form fields
   - Form sections: Basic Info, Pricing, Inventory Settings
   - Create mode (new products) and Edit mode (existing products)
   - API integration with proper error handling
   - useFormWithValidation hook for form state management
   
2. Created page components:
   - `src/pages/catalog/ProductNew.tsx` - Product creation page
   - `src/pages/catalog/ProductEdit.tsx` - Product edit page with data loading

3. Updated routing:
   - Added lazy-loaded page components for ProductNew and ProductEdit
   - Registered routes at `/catalog/products/new` and `/catalog/products/:id/edit`
   - Routes are detail pages (not shown in navigation menu)

4. Form validation rules:
   - Code: required, max 50 chars, alphanumeric + underscore/hyphen
   - Name: required, max 200 chars
   - Unit: required, max 20 chars
   - Barcode: optional, max 50 chars
   - Description: optional, max 2000 chars
   - Purchase price: optional, non-negative
   - Selling price: optional, non-negative
   - Min stock: optional, non-negative integer
   - Sort order: optional, non-negative integer

5. Edit mode restrictions:
   - Code is disabled (cannot be changed after creation)
   - Unit is disabled (cannot be changed after creation)

### Files created
- `frontend/src/features/catalog/ProductForm.tsx`
- `frontend/src/features/catalog/ProductForm.css`
- `frontend/src/pages/catalog/ProductNew.tsx`
- `frontend/src/pages/catalog/ProductEdit.tsx`

### Files modified
- `frontend/src/router/routes.tsx` - Added routes and lazy imports
- `frontend/src/pages/catalog/Products.tsx` - Prettier formatting fix

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings)
- `npm run build` passes

### Notes for next developer
- P1-FE-003 (Category Management) is the next catalog feature
- P1-BE-010 through P1-BE-015 (Partner module backend) could be started
- Product form navigates back to `/catalog/products` on success/cancel
- Category selection is not yet implemented (depends on P1-FE-003)
- Form uses Semi Design components via the common form components
- Validation messages are in Chinese to match UI language



---

## 2026-01-24 - P1-BE-010: Customer Aggregate Implementation Complete

### Completed
- **P1-BE-010**: Customer 聚合根实现 (Customer Aggregate Root Implementation)

### What was done
1. Created Customer aggregate root at `internal/domain/partner/customer.go`:
   - Implements `TenantAggregateRoot` for multi-tenant support
   - Status management: active, inactive, suspended
   - Customer types: individual, organization
   - Customer levels: normal, silver, gold, platinum, vip
   - Contact information: name, phone, email
   - Address information: address, city, province, postal code, country
   - Business fields: tax ID, credit limit, prepaid balance
   - Custom attributes as JSON

2. Created domain events at `internal/domain/partner/customer_events.go`:
   - CustomerCreatedEvent
   - CustomerUpdatedEvent
   - CustomerStatusChangedEvent
   - CustomerLevelChangedEvent
   - CustomerBalanceChangedEvent
   - CustomerDeletedEvent

3. Created repository interface at `internal/domain/partner/customer_repository.go`:
   - Full CRUD operations with tenant-scoped variants
   - Query methods: FindByPhone, FindByEmail, FindByType, FindByLevel, FindByStatus
   - Batch operations: FindByIDs, FindByCodes, SaveBatch
   - Existence checks: ExistsByCode, ExistsByPhone, ExistsByEmail
   - Count methods for aggregations

4. Created database migration:
   - `migrations/000005_create_customers.up.sql` - Creates customers table with:
     - Unique constraint on (tenant_id, code)
     - Check constraints for type, level, status, credit_limit, balance
     - Indexes for common queries (tenant, status, type, level, phone, email)
     - GIN index for JSONB attributes
     - Pattern indexes for ILIKE searches
     - Auto-update trigger for updated_at
   - `migrations/000005_create_customers.down.sql` - Rollback script

5. Created comprehensive unit tests at `internal/domain/partner/customer_test.go`:
   - 30+ test cases covering all functionality
   - Test coverage: 81.9%

### Key Features
- **Customer Types**: Individual (B2C) and Organization (B2B)
- **Customer Levels**: 5-tier system (normal → silver → gold → platinum → vip)
- **Balance Management**: Prepaid balance with recharge, deduction, refund operations
- **Credit Limit**: Maximum credit allowed per customer
- **Validation**: Code format, phone format, email format validation
- **Full Address**: Formatted full address generation

### Files created
- `backend/internal/domain/partner/customer.go`
- `backend/internal/domain/partner/customer_events.go`
- `backend/internal/domain/partner/customer_repository.go`
- `backend/internal/domain/partner/customer_test.go`
- `backend/migrations/000005_create_customers.up.sql`
- `backend/migrations/000005_create_customers.down.sql`

### Build Status
- `go build ./...` passes
- `go test ./...` passes all tests
- Test coverage for partner domain: 81.9%

### Notes for next developer
- P1-BE-011 (Supplier aggregate) can now be started - similar pattern to Customer
- P1-BE-012 (Warehouse aggregate) can follow after Supplier
- P1-BE-013 (Partner repositories) depends on P1-BE-010/011/012
- Customer balance operations generate events for downstream processing
- The balance field represents prepaid/deposit balance (not accounts receivable)
- Use CustomerType to differentiate B2C (individual) from B2B (organization) workflows
- TaxID field is for VAT invoice requirements (Chinese 增值税)


---

## 2026-01-24 - P1-BE-011: Supplier Aggregate Implementation Complete

### Completed
- **P1-BE-011**: Supplier 聚合根实现 (Supplier Aggregate Root Implementation)

### What was done
1. Created Supplier aggregate root at `internal/domain/partner/supplier.go`:
   - Implements `TenantAggregateRoot` for multi-tenant support
   - Status management: active, inactive, blocked
   - Supplier types: manufacturer, distributor, retailer, service
   - Contact information: name, phone, email
   - Address information: address, city, province, postal code, country
   - Financial fields: tax ID, bank name, bank account
   - Payment terms: credit days, credit limit
   - Accounts payable balance tracking
   - Supplier rating (0-5 scale)
   - Custom attributes as JSON

2. Created domain events at `internal/domain/partner/supplier_events.go`:
   - SupplierCreatedEvent
   - SupplierUpdatedEvent
   - SupplierStatusChangedEvent
   - SupplierPaymentTermsChangedEvent
   - SupplierBalanceChangedEvent
   - SupplierDeletedEvent

3. Created repository interface at `internal/domain/partner/supplier_repository.go`:
   - Full CRUD operations with tenant-scoped variants
   - Query methods: FindByPhone, FindByEmail, FindByType, FindByStatus
   - Batch operations: FindByIDs, FindByCodes, SaveBatch
   - Special queries: FindWithOutstandingBalance, FindOverCreditLimit
   - Existence checks: ExistsByCode, ExistsByPhone, ExistsByEmail
   - Count methods for aggregations

4. Created database migration:
   - `migrations/000006_create_suppliers.up.sql` - Creates suppliers table with:
     - Unique constraint on (tenant_id, code)
     - Check constraints for type, status, credit_days, credit_limit, balance, rating
     - Indexes for common queries (tenant, status, type, phone, email)
     - GIN index for JSONB attributes
     - Pattern indexes for ILIKE searches
     - Index for balance and over-credit queries
     - Auto-update trigger for updated_at
   - `migrations/000006_create_suppliers.down.sql` - Rollback script

5. Created comprehensive unit tests at `internal/domain/partner/supplier_test.go`:
   - 45+ test cases covering all functionality
   - Test coverage: 89.6% for partner domain

### Key Features
- **Supplier Types**: Manufacturer, Distributor, Retailer, Service
- **Payment Terms**: Credit days (0-365) and credit limit configuration
- **Balance Management**: Accounts payable tracking with purchase, payment, adjustment operations
- **Credit Control**: GetAvailableCredit(), IsOverCreditLimit() helpers
- **Bank Information**: Bank name and account for payments
- **Rating System**: 0-5 scale supplier rating
- **Validation**: Code format, phone format, email format validation
- **Full Address**: Formatted full address generation

### Key Differences from Customer
- No customer levels (suppliers have rating instead)
- Balance represents accounts payable (what we owe), not prepaid balance
- Payment terms (credit days/limit) instead of customer balance operations
- Bank information fields for payment processing
- "blocked" status instead of "suspended" (for quality/payment issues)

### Files created
- `backend/internal/domain/partner/supplier.go`
- `backend/internal/domain/partner/supplier_events.go`
- `backend/internal/domain/partner/supplier_repository.go`
- `backend/internal/domain/partner/supplier_test.go`
- `backend/migrations/000006_create_suppliers.up.sql`
- `backend/migrations/000006_create_suppliers.down.sql`

### Build Status
- `go build ./...` passes
- `go test ./...` passes all tests
- Test coverage for partner domain: 89.6%

### Notes for next developer
- P1-BE-012 (Warehouse aggregate) is the next priority - completes the partner context aggregates
- P1-BE-013 (Partner repositories) depends on all three aggregates being complete
- Supplier balance operations generate events for downstream finance processing
- The balance field represents accounts payable (money we owe the supplier)
- Use SupplierType to categorize supply chain relationship
- Payment terms (credit_days, credit_limit) control purchasing credit
- Bank information is for generating payment vouchers
- Rating can be used for supplier performance evaluation


---

## 2026-01-24 - P1-BE-012: Warehouse Aggregate Implementation Complete

### Completed
- **P1-BE-012**: Warehouse 聚合根实现 (Warehouse Aggregate Root Implementation)

### What was done
1. Created Warehouse aggregate root at `internal/domain/partner/warehouse.go`:
   - Implements `TenantAggregateRoot` for multi-tenant support
   - Status management: active, inactive
   - Warehouse types: physical, virtual, consign, transit
   - Contact information: contact name, phone, email
   - Address information: address, city, province, postal code, country
   - Default warehouse flag (only one per tenant)
   - Capacity field for storage limits
   - Custom attributes as JSON

2. Created domain events at `internal/domain/partner/warehouse_events.go`:
   - WarehouseCreatedEvent
   - WarehouseUpdatedEvent
   - WarehouseStatusChangedEvent
   - WarehouseSetAsDefaultEvent
   - WarehouseDeletedEvent

3. Created repository interface at `internal/domain/partner/warehouse_repository.go`:
   - Full CRUD operations with tenant-scoped variants
   - Query methods: FindByCode, FindByType, FindByStatus, FindDefault
   - Batch operations: FindByIDs, FindByCodes, SaveBatch
   - Special methods: ClearDefault (for managing single default per tenant)
   - Existence checks: ExistsByCode
   - Count methods for aggregations

4. Created database migration:
   - `migrations/000007_create_warehouses.up.sql` - Creates warehouses table with:
     - Unique constraint on (tenant_id, code)
     - Partial unique index ensuring only one default warehouse per tenant
     - Check constraints for type, status, capacity
     - Indexes for common queries (tenant, status, type, is_default)
     - GIN index for JSONB attributes
     - Pattern indexes for ILIKE searches
     - Auto-update trigger for updated_at
   - `migrations/000007_create_warehouses.down.sql` - Rollback script

5. Created comprehensive unit tests at `internal/domain/partner/warehouse_test.go`:
   - 50+ test cases covering all functionality
   - Test coverage: 91.9% for partner domain

### Key Features
- **Warehouse Types**: Physical (standard), Virtual (logical), Consign (consignment), Transit (in-transit)
- **Default Warehouse**: Only one warehouse can be default per tenant; default cannot be disabled
- **Capacity Management**: Optional capacity limit (0 = unlimited)
- **Enable/Disable**: Simple status toggle with business rule protection (cannot disable default)
- **Validation**: Code format, name length, contact validation
- **Full Address**: Formatted full address generation

### Key Differences from Customer/Supplier
- Simpler status model (only active/inactive, no suspended/blocked)
- No financial fields (balance, credit)
- Has `is_default` flag for identifying primary warehouse
- Has `capacity` field for storage planning
- Unique partial index ensures only one default per tenant

### Files created
- `backend/internal/domain/partner/warehouse.go`
- `backend/internal/domain/partner/warehouse_events.go`
- `backend/internal/domain/partner/warehouse_repository.go`
- `backend/internal/domain/partner/warehouse_test.go`
- `backend/migrations/000007_create_warehouses.up.sql`
- `backend/migrations/000007_create_warehouses.down.sql`

### Build Status
- `go build ./...` passes
- `go test ./...` passes all tests
- Test coverage for partner domain: 91.9%

### Notes for next developer
- P1-BE-013 (Partner repositories implementation) can now be started - all three aggregates are complete
- All Partner context aggregates (Customer, Supplier, Warehouse) are now done
- When implementing ClearDefault, use a transaction to clear other defaults before setting new one
- The partial unique index `idx_warehouses_tenant_default` ensures database-level constraint
- For inventory operations, warehouse must be active and is determined by `IsActive()` method
- Virtual warehouses can represent logical locations like "Returns" or "Defective"
- Transit warehouses track goods in transit between physical locations

---

## 2026-01-24: P1-BE-013 Partner Repository 接口 + 实现

### Summary
Implemented GORM-based repository implementations for all three Partner context aggregates: Customer, Supplier, and Warehouse.

### What was done
1. **GormCustomerRepository** - Complete implementation of CustomerRepository interface
   - FindByID, FindByIDForTenant, FindByCode, FindByPhone, FindByEmail
   - FindAll, FindAllForTenant, FindByType, FindByLevel, FindByStatus, FindActive
   - FindByIDs, FindByCodes, FindWithPositiveBalance
   - Save, SaveBatch, Delete, DeleteForTenant
   - Count, CountForTenant, CountByType, CountByLevel, CountByStatus
   - ExistsByCode, ExistsByPhone, ExistsByEmail
   - Filter support with search, pagination, ordering

2. **GormSupplierRepository** - Complete implementation of SupplierRepository interface
   - Same pattern as CustomerRepository
   - Additional: FindWithOutstandingBalance, FindOverCreditLimit
   - Supplier-specific filters: min_rating, max_rating

3. **GormWarehouseRepository** - Complete implementation of WarehouseRepository interface
   - Same pattern as other repositories
   - Special methods: FindDefault, ClearDefault
   - Default ordering puts default warehouse first (is_default DESC)

### Implementation Details
- All repositories use GORM with PostgreSQL
- Multi-tenant scoping with tenant_id on all tenant-aware queries
- Code/email normalization (ToUpper for codes, ToLower for emails)
- Error handling converts gorm.ErrRecordNotFound to shared.ErrNotFound
- Filter system supports search across multiple fields (name, code, phone, email)
- Pagination and ordering with sensible defaults

### Files created
- `backend/internal/infrastructure/persistence/customer_repository.go`
- `backend/internal/infrastructure/persistence/supplier_repository.go`
- `backend/internal/infrastructure/persistence/warehouse_repository.go`
- `backend/internal/infrastructure/persistence/customer_repository_test.go`
- `backend/internal/infrastructure/persistence/supplier_repository_test.go`
- `backend/internal/infrastructure/persistence/warehouse_repository_test.go`

### Build & Test Status
- `go build ./...` passes
- All repository tests pass
- Tests use go-sqlmock for database mocking
- Interface compliance verified at compile time

### Notes for next developer
- P1-BE-014 (Partner Application Service) can now be started
- Repository interfaces are defined in domain layer, implementations in infrastructure
- All repositories follow the same pattern for consistency
- ClearDefault uses GORM's Update with map to avoid updating all fields
- Consider adding transaction support in application service layer
- FindByIDs/FindByCodes return empty slice (not error) for empty input

---

## 2026-01-24 - P1-BE-014: Partner Application Service Complete

### Completed
- **P1-BE-014**: Partner Application Service (客户/供应商/仓库应用服务)

### What was done
1. **Created DTOs** (`backend/internal/application/partner/dto.go`):
   - Request DTOs: CreateCustomerRequest, UpdateCustomerRequest, CreateSupplierRequest, UpdateSupplierRequest, CreateWarehouseRequest, UpdateWarehouseRequest
   - Response DTOs: CustomerResponse, CustomerListResponse, SupplierResponse, SupplierListResponse, WarehouseResponse, WarehouseListResponse
   - Filter DTOs: CustomerListFilter, SupplierListFilter, WarehouseListFilter
   - Conversion functions: ToCustomerResponse, ToSupplierResponse, ToWarehouseResponse, etc.

2. **CustomerService** (`backend/internal/application/partner/customer_service.go`):
   - Create customer with unique code/phone/email validation
   - GetByID, GetByCode, List with filtering and pagination
   - Update, UpdateCode with duplicate validation
   - Delete with balance check (cannot delete customer with balance)
   - Activate, Deactivate, Suspend status management
   - AddBalance, DeductBalance, RefundBalance for balance operations
   - SetLevel for customer level management
   - CountByStatus, CountByLevel, CountByType for analytics

3. **SupplierService** (`backend/internal/application/partner/supplier_service.go`):
   - Create supplier with unique code/phone/email validation
   - GetByID, GetByCode, List with filtering and pagination
   - Update, UpdateCode with duplicate validation
   - Delete with balance check
   - Activate, Deactivate, Block status management
   - SetRating for supplier rating (1-5)
   - SetPaymentTerms for credit days and limit
   - CountByStatus, CountByType for analytics

4. **WarehouseService** (`backend/internal/application/partner/warehouse_service.go`):
   - Create warehouse with unique code validation
   - GetByID, GetByCode, GetDefault, List with filtering
   - Update, UpdateCode with duplicate validation
   - Delete (cannot delete default warehouse)
   - Enable, Disable status management
   - SetDefault with auto-clearing of other defaults
   - CountByStatus, CountByType for analytics

5. **Unit Tests** (`backend/internal/application/partner/customer_service_test.go`):
   - 19 unit tests for CustomerService
   - MockCustomerRepository implementation using testify/mock
   - Tests cover: Create, Create_WithAllFields, Create_DuplicateCode, Create_DuplicatePhone, GetByID, List, Update, UpdateCode, Delete, Delete_HasBalance, Activate, Deactivate, Suspend, AddBalance, SetLevel, CountByStatus, ToCustomerResponse, ToCustomerListResponses

### Implementation Details
- Services follow DDD Application Service pattern
- Each service takes repository interface as dependency (dependency injection)
- Services orchestrate domain operations without exposing domain entities
- Response DTOs hide internal domain structure
- Validation occurs at service level before domain operations
- Duplicate checks use repository methods (ExistsByCode, ExistsByPhone, ExistsByEmail)
- Balance operations preserve atomicity through domain aggregate methods
- Default warehouse management ensures only one default per tenant

### Files created
- `backend/internal/application/partner/dto.go`
- `backend/internal/application/partner/customer_service.go`
- `backend/internal/application/partner/supplier_service.go`
- `backend/internal/application/partner/warehouse_service.go`
- `backend/internal/application/partner/customer_service_test.go`

### Build & Test Status
- `go build ./...` passes
- All 19 tests pass: `go test ./internal/application/partner/...`
- No linting errors (fixed interface{} to any)

### Notes for next developer
- P1-BE-015 (Partner API) can now be started using these services
- Services are ready for HTTP handler integration
- Consider adding SupplierService and WarehouseService tests (same pattern)
- Transaction support may be needed for complex operations
- Event publishing can be added for domain events

---

## 2026-01-24 - P1-BE-015: Partner API Implementation Complete

### Completed
- **P1-BE-015**: Partner API (Customer/Supplier/Warehouse)

### What was done
1. **Customer Handler** (`backend/internal/interfaces/http/handler/customer.go`):
   - Create, GetByID, GetByCode, List with pagination and filtering
   - Update, UpdateCode for customer modifications
   - Delete with balance validation
   - Activate, Deactivate, Suspend status operations
   - AddBalance, DeductBalance for prepaid balance management
   - SetLevel for customer tier management
   - CountByStatus for analytics dashboard

2. **Supplier Handler** (`backend/internal/interfaces/http/handler/supplier.go`):
   - Create, GetByID, GetByCode, List with filtering
   - Update, UpdateCode for supplier modifications
   - Delete with validation
   - Activate, Deactivate, Block status operations
   - SetRating for supplier quality tracking (0-5)
   - SetPaymentTerms for credit days and limit management
   - CountByStatus for analytics dashboard

3. **Warehouse Handler** (`backend/internal/interfaces/http/handler/warehouse.go`):
   - Create, GetByID, GetByCode, GetDefault, List with filtering
   - Update, UpdateCode for warehouse modifications
   - Delete (prevents deletion of default warehouse)
   - Enable, Disable status operations
   - SetDefault for default warehouse management
   - CountByStatus for analytics dashboard

4. **Swagger Documentation** (handler DTOs):
   - Created `customer_dto.go` with CustomerResponse, CustomerListResponse
   - Created `supplier_dto.go` with SupplierResponse, SupplierListResponse
   - Created `warehouse_dto.go` with WarehouseResponse, WarehouseListResponse
   - All handlers have complete Swagger annotations for API documentation

5. **Route Registration** (`backend/cmd/server/main.go`):
   - Added partnerapp import for application services
   - Initialized customer, supplier, warehouse repositories
   - Initialized customer, supplier, warehouse services
   - Initialized customer, supplier, warehouse handlers
   - Registered 46 partner routes under /api/v1/partner:
     - 14 customer routes (/customers/*)
     - 14 supplier routes (/suppliers/*)
     - 12 warehouse routes (/warehouses/*)

### API Endpoints Implemented

**Customer Endpoints** (`/api/v1/partner/customers`):
- `POST /customers` - Create customer
- `GET /customers` - List customers with filtering
- `GET /customers/stats/count` - Get customer counts by status
- `GET /customers/:id` - Get customer by ID
- `GET /customers/code/:code` - Get customer by code
- `PUT /customers/:id` - Update customer
- `PUT /customers/:id/code` - Update customer code
- `DELETE /customers/:id` - Delete customer
- `POST /customers/:id/activate` - Activate customer
- `POST /customers/:id/deactivate` - Deactivate customer
- `POST /customers/:id/suspend` - Suspend customer
- `POST /customers/:id/balance/add` - Add to prepaid balance
- `POST /customers/:id/balance/deduct` - Deduct from prepaid balance
- `PUT /customers/:id/level` - Set customer tier level

**Supplier Endpoints** (`/api/v1/partner/suppliers`):
- `POST /suppliers` - Create supplier
- `GET /suppliers` - List suppliers with filtering
- `GET /suppliers/stats/count` - Get supplier counts by status
- `GET /suppliers/:id` - Get supplier by ID
- `GET /suppliers/code/:code` - Get supplier by code
- `PUT /suppliers/:id` - Update supplier
- `PUT /suppliers/:id/code` - Update supplier code
- `DELETE /suppliers/:id` - Delete supplier
- `POST /suppliers/:id/activate` - Activate supplier
- `POST /suppliers/:id/deactivate` - Deactivate supplier
- `POST /suppliers/:id/block` - Block supplier
- `PUT /suppliers/:id/rating` - Set supplier rating
- `PUT /suppliers/:id/payment-terms` - Set payment terms

**Warehouse Endpoints** (`/api/v1/partner/warehouses`):
- `POST /warehouses` - Create warehouse
- `GET /warehouses` - List warehouses with filtering
- `GET /warehouses/stats/count` - Get warehouse counts by status
- `GET /warehouses/default` - Get default warehouse
- `GET /warehouses/:id` - Get warehouse by ID
- `GET /warehouses/code/:code` - Get warehouse by code
- `PUT /warehouses/:id` - Update warehouse
- `PUT /warehouses/:id/code` - Update warehouse code
- `DELETE /warehouses/:id` - Delete warehouse
- `POST /warehouses/:id/enable` - Enable warehouse
- `POST /warehouses/:id/disable` - Disable warehouse
- `POST /warehouses/:id/set-default` - Set as default warehouse

### Files created
- `backend/internal/interfaces/http/handler/customer.go`
- `backend/internal/interfaces/http/handler/customer_dto.go`
- `backend/internal/interfaces/http/handler/supplier.go`
- `backend/internal/interfaces/http/handler/supplier_dto.go`
- `backend/internal/interfaces/http/handler/warehouse.go`
- `backend/internal/interfaces/http/handler/warehouse_dto.go`

### Files modified
- `backend/cmd/server/main.go` - Added partner handler initialization and routes
- `backend/docs/swagger.json` - Regenerated with partner API endpoints
- `backend/docs/swagger.yaml` - Regenerated with partner API endpoints

### Build & Documentation Status
- `go build ./...` passes successfully
- Swagger documentation regenerated with `swag init`
- All partner API endpoints documented with full Swagger annotations

### Notes for next developer
- Frontend (P1-FE-004 to P1-FE-008) can now integrate with these APIs
- Consider adding request validation middleware for additional security
- Unit tests for handlers (P1-QA-004) are next priority
- Integration tests should verify full request/response cycle

---

## 2026-01-24 - P1-FE-004: Customer List Page Implementation Complete

### Completed
- **P1-FE-004**: 客户列表页面 (Customer List Page)

### What was done
1. **Regenerated Frontend API SDK**:
   - Ran `npm run api:generate` to generate TypeScript clients for Partner APIs
   - Generated `src/api/customers/`, `src/api/suppliers/`, `src/api/warehouses/` directories
   - All API models now available in `src/api/models/`

2. **Customer List Page** (`frontend/src/pages/partner/Customers.tsx`):
   - Full customer list with pagination (20 per page default)
   - Search by name, code, phone, email
   - Filter by status (active, inactive, suspended)
   - Filter by type (individual, organization)
   - Filter by level (normal, silver, gold, platinum, vip)
   - Sortable columns: code, name, level, created_at
   - Row selection with bulk operations

3. **Customer Status Operations**:
   - Activate: Enable inactive/suspended customers
   - Deactivate: Disable active customers
   - Suspend: Temporarily pause customer (with confirmation modal)
   - Delete: Remove customer (with confirmation modal, validates no balance)
   - Bulk activate/deactivate for selected rows

4. **Table Features**:
   - Customer code with monospace styling
   - Customer name with short name display
   - Type badge (individual=light-blue, organization=blue)
   - Contact info (phone + email in stacked layout)
   - Location (province + city)
   - Level badge with color coding (normal, silver, gold, platinum, vip)
   - Status badge (active=green, inactive=grey, suspended=orange)
   - Row actions: view, edit, activate, deactivate, suspend, delete

5. **CSS Styling** (`frontend/src/pages/partner/Customers.css`):
   - Follows design system tokens (--spacing-*, --semi-color-*, etc.)
   - Responsive layout for mobile/tablet
   - Consistent with Products page styling

### Files created/modified
- `frontend/src/pages/partner/Customers.tsx` (rewritten)
- `frontend/src/pages/partner/Customers.css` (new)
- `frontend/src/api/customers/*.ts` (auto-generated)
- `frontend/src/api/suppliers/*.ts` (auto-generated)
- `frontend/src/api/warehouses/*.ts` (auto-generated)
- `frontend/src/api/models/*.ts` (updated with partner models)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings in router files)
- `npm run build` passes

### Usage
Navigate to `/partner/customers` in the application to access the customer list.

### Notes for next developer
- P1-FE-005 (Customer form) is the next priority - enables create/edit customers
- P1-FE-006 (Supplier list) can follow the same pattern as this implementation
- Customer balance display is not yet implemented (requires P1-BE-016 CustomerBalance feature)
- The edit/view navigation goes to `/partner/customers/:id/edit` and `/partner/customers/:id` - these routes need form components
- Generated API files in `src/api/` should never be manually edited


---

## 2026-01-24 - P1-FE-005: Customer Form (Create/Edit) Implementation Complete

### Completed
- **P1-FE-005**: 客户新增/编辑表单 (Customer Add/Edit Form)

### What was done
1. **Created CustomerForm component** (`frontend/src/features/partner/CustomerForm.tsx`):
   - Comprehensive customer form with Zod schema validation
   - Create mode for new customers
   - Edit mode for existing customers (loads data via API)
   - Form sections: Basic Info, Contact Info, Address Info, Other Settings
   - Fields: code, name, short_name, type, level (edit only), contact_name, phone, email, tax_id, country, province, city, postal_code, address, credit_limit, sort_order, notes
   - Client code is disabled in edit mode (immutable after creation)
   - Type field is disabled in edit mode
   - Level can only be changed in edit mode

2. **Created page wrappers**:
   - `frontend/src/pages/partner/CustomerNew.tsx` - Create mode wrapper
   - `frontend/src/pages/partner/CustomerEdit.tsx` - Edit mode with data fetching

3. **Updated routing** (`frontend/src/router/routes.tsx`):
   - Added lazy-loaded imports for CustomerNewPage and CustomerEditPage
   - Added routes: `/partner/customers/new` and `/partner/customers/:id/edit`

4. **Form validation schema**:
   - Code: required, max 50 chars, alphanumeric with underscores/dashes
   - Name: required, max 200 chars
   - Email: optional but validated format
   - Credit limit: non-negative number
   - Uses `createEnumSchema` helper for type and level fields

5. **CSS styling** (`frontend/src/features/partner/CustomerForm.css`):
   - Follows design system tokens
   - Max width 800px container
   - Consistent with ProductForm styling

### Files created
- `frontend/src/features/partner/CustomerForm.tsx`
- `frontend/src/features/partner/CustomerForm.css`
- `frontend/src/pages/partner/CustomerNew.tsx`
- `frontend/src/pages/partner/CustomerEdit.tsx`

### Files modified
- `frontend/src/features/partner/index.ts` - Added CustomerForm export
- `frontend/src/router/routes.tsx` - Added customer form routes

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings)
- `npm run build` passes

### Usage
- Navigate to `/partner/customers` and click "新增客户" to create new customer
- Click "编辑" action on customer row to edit existing customer
- Form validates on submit and shows errors inline

### Notes for next developer
- P1-FE-006 (Supplier list page) is the next high-priority frontend task
- P1-FE-007 (Supplier form) can follow the same pattern as CustomerForm
- P1-FE-008 (Warehouse management page) is also high priority
- Customer view page (`/partner/customers/:id`) is not yet implemented - only edit exists
- The form uses `createEnumSchema` from validation.ts for type safety with Zod 4

---

## 2026-01-24 - P1-FE-006: Supplier List Page Implementation Complete

### Completed
- **P1-FE-006**: 供应商列表页面 (Supplier List Page)

### What was done
1. **Supplier List Page** (`frontend/src/pages/partner/Suppliers.tsx`):
   - Full supplier list with pagination (20 per page default)
   - Search by name, code, phone, email
   - Filter by status (active, inactive, blocked)
   - Filter by type (manufacturer, distributor, retailer, service)
   - Sortable columns: code, name, rating, payment_term_days, created_at
   - Row selection with bulk operations

2. **Supplier Status Operations**:
   - Activate: Enable inactive/blocked suppliers
   - Deactivate: Disable active suppliers
   - Block: Block supplier from business (with confirmation modal)
   - Delete: Remove supplier (with confirmation modal)
   - Bulk activate/deactivate for selected rows

3. **Table Features**:
   - Supplier code with monospace styling
   - Supplier name with short name display
   - Contact info (phone + email in stacked layout)
   - Location (province + city)
   - Rating display using Semi Design Rating component (5-star system)
   - Payment term days column
   - Status badge (active=green, inactive=grey, blocked=red)
   - Row actions: view, edit, activate, deactivate, block, delete

4. **CSS Styling** (`frontend/src/pages/partner/Suppliers.css`):
   - Follows design system tokens (--spacing-*, --semi-color-*, etc.)
   - Responsive layout for mobile/tablet
   - Consistent with Customers page styling
   - Rating component styling for table cells

### Files created/modified
- `frontend/src/pages/partner/Suppliers.tsx` (rewritten from placeholder)
- `frontend/src/pages/partner/Suppliers.css` (new)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings in router files)
- `npm run build` passes

### Usage
Navigate to `/partner/suppliers` in the application to access the supplier list.

### Notes for next developer
- P1-FE-007 (Supplier form) is the next priority - enables create/edit suppliers
- P1-FE-008 (Warehouse management page) is also high priority
- The edit/view navigation goes to `/partner/suppliers/:id/edit` and `/partner/suppliers/:id` - these routes need form components
- Supplier page follows the same pattern as Customers page for consistency
- Rating component displays supplier rating as 5-star visual
- Payment terms displayed in days column

---

## 2026-01-24 - P1-FE-007: Supplier Form (Create/Edit) Implementation Complete

### Completed
- **P1-FE-007**: 供应商新增/编辑表单 (Supplier Add/Edit Form)

### What was done
1. **Created SupplierForm component** (`frontend/src/features/partner/SupplierForm.tsx`):
   - Comprehensive supplier form with Zod schema validation
   - Create mode for new suppliers
   - Edit mode for existing suppliers (loads data via API)
   - Form sections: Basic Info, Contact Info, Address Info, Banking Info, Purchase Settings
   - Fields: code, name, short_name, type, contact_name, phone, email, tax_id, country, province, city, postal_code, address, bank_name, bank_account, credit_limit, credit_days, rating, sort_order, notes
   - Supplier code is disabled in edit mode (immutable after creation)
   - Type field is disabled in edit mode
   - Rating uses Semi Design Rating component (5-star visual)

2. **Created page wrappers**:
   - `frontend/src/pages/partner/SupplierNew.tsx` - Create mode wrapper
   - `frontend/src/pages/partner/SupplierEdit.tsx` - Edit mode with data fetching

3. **Updated routing** (`frontend/src/router/routes.tsx`):
   - Added lazy-loaded imports for SupplierNewPage and SupplierEditPage
   - Added routes: `/partner/suppliers/new` and `/partner/suppliers/:id/edit`

4. **Form validation schema**:
   - Code: required, max 50 chars, alphanumeric with underscores/dashes
   - Name: required, max 200 chars
   - Email: optional but validated format
   - Credit limit: non-negative number
   - Credit days: non-negative integer
   - Rating: 0-5 range
   - Uses `createEnumSchema` helper for type field

5. **CSS styling** (`frontend/src/features/partner/SupplierForm.css`):
   - Follows design system tokens
   - Max width 800px container
   - Custom styling for Rating field component
   - Consistent with CustomerForm styling

### Files created
- `frontend/src/features/partner/SupplierForm.tsx`
- `frontend/src/features/partner/SupplierForm.css`
- `frontend/src/pages/partner/SupplierNew.tsx`
- `frontend/src/pages/partner/SupplierEdit.tsx`

### Files modified
- `frontend/src/features/partner/index.ts` - Added SupplierForm export
- `frontend/src/router/routes.tsx` - Added supplier form routes

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings)
- `npm run build` passes

### Usage
- Navigate to `/partner/suppliers` and click "新增供应商" to create new supplier
- Click "编辑" action on supplier row to edit existing supplier
- Form validates on submit and shows errors inline

### Notes for next developer
- P1-FE-008 (Warehouse management page) is the next high-priority frontend task
- P1-FE-009 (Customer balance management) requires backend P1-BE-016 CustomerBalance feature first
- Supplier view page (`/partner/suppliers/:id`) is not yet implemented - only edit exists
- The form uses `createEnumSchema` from validation.ts for type safety with Zod 4
- Rating component has custom styling in SupplierForm.css
- Banking info section is specific to suppliers for payment purposes

## 2026-01-24 - P1-FE-008: Warehouse Management Page

### Completed
- **P1-FE-008**: 仓库管理页面 (Warehouse management page)

### What was done

1. **Created Warehouses list page** (`frontend/src/pages/partner/Warehouses.tsx`):
   - Full CRUD operations (create, edit, enable/disable, set default, delete)
   - Pagination with configurable page size (10, 20, 50)
   - Search by code, name, and short name
   - Filter by status (enabled/disabled)
   - Filter by type (physical, virtual, consign, transit)
   - Bulk selection and bulk delete
   - Set default warehouse action
   - Displays: code, name, short name, type, manager, contact info, location, status
   - Actions: edit, enable/disable, set default, delete

2. **Created WarehouseForm component** (`frontend/src/features/partner/WarehouseForm.tsx`):
   - Create and edit modes
   - Zod schema validation
   - Form sections:
     - Basic Info: code, name, short name, type
     - Contact Info: manager name, phone, email
     - Address Info: country, province, city, postal code, address
     - Settings: capacity, sort order, default warehouse toggle, notes
   - Type options: physical (普通仓库), virtual (虚拟仓库), consign (寄售仓库), transit (中转仓库)
   - Default country set to "中国"
   - Code is disabled in edit mode (immutable)
   - Type is disabled in edit mode (immutable)

3. **Created page wrappers**:
   - `frontend/src/pages/partner/WarehouseNew.tsx` - Create mode wrapper
   - `frontend/src/pages/partner/WarehouseEdit.tsx` - Edit mode with data fetching

4. **Updated routing** (`frontend/src/router/routes.tsx`):
   - Added lazy-loaded imports for WarehouseNewPage and WarehouseEditPage
   - Added routes: `/partner/warehouses/new` and `/partner/warehouses/:id/edit`

5. **Form validation schema**:
   - Code: required, max 50 chars, alphanumeric with underscores/dashes
   - Name: required, max 200 chars
   - Short name: optional, max 100 chars
   - Type: required, one of physical/virtual/consign/transit
   - Contact name: optional, max 100 chars
   - Phone: optional, max 50 chars
   - Email: optional, valid email format
   - Country/Province/City: optional, max 100 chars each
   - Postal code: optional, max 20 chars
   - Address: optional, max 500 chars
   - Capacity: optional, non-negative integer
   - Sort order: optional, non-negative integer
   - Notes: optional, max 2000 chars

6. **CSS styling**:
   - `frontend/src/pages/partner/Warehouses.css` - List page styling
   - `frontend/src/features/partner/WarehouseForm.css` - Form styling with default toggle field

### Files created
- `frontend/src/pages/partner/Warehouses.tsx`
- `frontend/src/pages/partner/Warehouses.css`
- `frontend/src/features/partner/WarehouseForm.tsx`
- `frontend/src/features/partner/WarehouseForm.css`
- `frontend/src/pages/partner/WarehouseNew.tsx`
- `frontend/src/pages/partner/WarehouseEdit.tsx`

### Files modified
- `frontend/src/features/partner/index.ts` - Added WarehouseForm export
- `frontend/src/router/routes.tsx` - Added warehouse form routes

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings)
- `npm run build` passes

### Usage
- Navigate to `/partner/warehouses` to view warehouse list
- Click "新增仓库" to create new warehouse
- Click "编辑" action on warehouse row to edit existing warehouse
- Click "启用/禁用" to toggle warehouse status
- Click "设为默认" to make warehouse the default
- Use checkboxes for bulk selection and "批量删除"
- Filter by status and type using dropdowns
- Search by code/name/short name using search input

### Notes for next developer
- P1-FE-009 (Customer balance management) is the next frontend task but requires backend P1-BE-016 first
- Warehouse types use API values: physical, virtual, consign, transit
- The is_default field uses a Switch component instead of checkbox for better UX
- Form uses capacity field (API model supports it) but mapping from initialData uses sort_order as placeholder since API doesn't return capacity

---

## 2026-01-24 - P2-BE-001, P2-BE-002, P2-BE-006, P2-BE-010: InventoryItem Aggregate Implementation Complete

### Completed
- **P2-BE-001**: InventoryItem 聚合根实现
- **P2-BE-002**: StockBatch 实体实现
- **P2-BE-006**: StockLock 实现 (乐观锁)
- **P2-BE-010**: 库存领域事件实现

### What was done
1. **InventoryItem aggregate root** (`backend/internal/domain/inventory/inventory_item.go`):
   - Core inventory aggregate with WarehouseID + ProductID composite identifier
   - Fields: AvailableQuantity, LockedQuantity, UnitCost, MinQuantity, MaxQuantity
   - Moving weighted average cost calculation on stock increase
   - Methods: IncreaseStock, LockStock, UnlockStock, DeductStock, AdjustStock
   - Helper methods: TotalQuantity, CanFulfill, IsBelowMinimum, IsAboveMaximum, GetTotalValue
   - Active and expired lock management with ReleaseExpiredLocks

2. **StockBatch entity** (`backend/internal/domain/inventory/stock_batch.go`):
   - Batch tracking with BatchNumber, ProductionDate, ExpiryDate
   - Quantity and UnitCost per batch
   - Expiry detection: IsExpired, WillExpireWithin, DaysUntilExpiry
   - Quantity management: Deduct, Add methods
   - Availability check: HasStock, IsAvailable

3. **StockLock entity** (`backend/internal/domain/inventory/stock_lock.go`):
   - Lock reservation for pending orders
   - Fields: Quantity, SourceType, SourceID, ExpireAt
   - Status tracking: Released, Consumed, ReleasedAt
   - Methods: IsActive, IsExpired, Release, Consume, TimeUntilExpiry

4. **Domain events** (`backend/internal/domain/inventory/inventory_events.go`):
   - StockIncreasedEvent: When stock is received
   - StockLockedEvent: When stock is reserved
   - StockUnlockedEvent: When reservation is cancelled
   - StockDeductedEvent: When locked stock is shipped/consumed
   - StockAdjustedEvent: When stock is adjusted via stock taking
   - InventoryCostChangedEvent: When unit cost changes
   - StockBelowThresholdEvent: When stock falls below minimum

5. **Unit tests** (`backend/internal/domain/inventory/inventory_item_test.go`):
   - 37 test cases covering all aggregate functionality
   - Tests for: creation, stock increase, locking, unlocking, deduction, adjustment
   - Tests for: threshold checks, fulfillment checks, event emission
   - 100% pass rate

### Key Design Decisions
1. **Composite identifier**: InventoryItem is uniquely identified by WarehouseID + ProductID
2. **Stock locking pattern**: Orders must first lock stock, then deduct when shipping
3. **Moving weighted average cost**: Cost recalculated on each stock increase
4. **Invariants enforced**:
   - availableQuantity >= 0
   - lockedQuantity >= 0
   - Deduction requires valid lock
   - Adjustment requires no outstanding locks
5. **Lock expiration**: Locks have ExpireAt and can be automatically released

### Files created
- `backend/internal/domain/inventory/inventory_item.go`
- `backend/internal/domain/inventory/stock_batch.go`
- `backend/internal/domain/inventory/stock_lock.go`
- `backend/internal/domain/inventory/inventory_events.go`
- `backend/internal/domain/inventory/inventory_item_test.go`

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests

### Usage Examples
```go
// Create inventory item
item, err := NewInventoryItem(tenantID, warehouseID, productID)

// Increase stock with batch
batchInfo := &BatchInfo{
    BatchNumber: "BATCH-001",
    ExpiryDate:  &expiryDate,
}
err = item.IncreaseStock(decimal.NewFromInt(100), valueobject.NewMoneyCNYFromFloat(10.00), batchInfo)

// Lock stock for order
lock, err := item.LockStock(decimal.NewFromInt(30), "sales_order", "SO-001", time.Now().Add(time.Hour))

// Deduct when shipping
err = item.DeductStock(lock.ID)

// Or unlock if order cancelled
err = item.UnlockStock(lock.ID)

// Adjust during stock taking
err = item.AdjustStock(decimal.NewFromInt(95), "Stock taking - missing 5 units")
```

### Notes for next developer
- **P2-BE-003** (Cost calculation strategies): Can now be integrated with InventoryItem.IncreaseStock
- **P2-BE-004** (Batch management strategies): Can now be integrated with StockBatch
- **P2-BE-005** (InventoryTransaction): Should be created to record all inventory movements
- **P2-BE-007** (Repository): Should implement persistence for InventoryItem, StockBatch, StockLock
- Database migration needed to create tables for inventory_items, stock_batches, stock_locks
- Events should be registered with EventSerializer for Outbox pattern
- Consider adding product name/code denormalization for query performance


---

## 2026-01-24 - P2-BE-003: Cost Calculation Strategies Implementation Complete

### Completed
- **P2-BE-003**: 成本计算策略实现 (移动加权/FIFO)

### What was done
1. Verified existing cost calculation strategy implementation in `backend/internal/infrastructure/strategy/cost/`:
   - `moving_average.go` - Moving Weighted Average cost strategy
   - `fifo.go` - FIFO (First-In-First-Out) cost strategy

2. Created comprehensive unit tests for both strategies:
   - `moving_average_test.go` - 15 test cases covering:
     - Strategy initialization and metadata
     - CalculateAverageCost with various scenarios
     - CalculateCost with partial, full, and exceeding quantities
     - Real-world inventory scenario simulation
   - `fifo_test.go` - 18 test cases covering:
     - Strategy initialization and metadata
     - CalculateAverageCost (for reporting)
     - CalculateCost with FIFO ordering verification
     - Spanning multiple batches
     - Handling insufficient stock
     - Date-based sorting verification
     - Real-world FIFO scenario simulation
     - Comparison between FIFO and Moving Average results

3. Key features verified:
   - **Moving Weighted Average**: Uses weighted average cost across all stock entries
   - **FIFO**: Consumes oldest stock first, sorted by EntryDate
   - Both implement `CostCalculationStrategy` interface from shared domain
   - Both registered in `defaults.go` with Moving Average as default

### Strategy Interface
```go
type CostCalculationStrategy interface {
    Strategy
    Method() CostMethod
    CalculateCost(ctx context.Context, costCtx CostContext, entries []StockEntry) (CostResult, error)
    CalculateAverageCost(ctx context.Context, entries []StockEntry) (decimal.Decimal, error)
}
```

### Files created
- `backend/internal/infrastructure/strategy/cost/moving_average_test.go`
- `backend/internal/infrastructure/strategy/cost/fifo_test.go`

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests
- Test coverage: 98.1% for cost strategy package

### Usage Examples
```go
// Get strategy from registry
registry, _ := strategy.NewRegistryWithDefaults()
movingAvg, _ := registry.GetCostStrategy("moving_average")
fifo, _ := registry.GetCostStrategy("fifo")

// Prepare stock entries
entries := []strategy.StockEntry{
    {ID: "1", Quantity: decimal.NewFromInt(100), UnitCost: decimal.NewFromFloat(10.00), TotalCost: decimal.NewFromFloat(1000.00), EntryDate: time.Now().Add(-48*time.Hour)},
    {ID: "2", Quantity: decimal.NewFromInt(100), UnitCost: decimal.NewFromFloat(20.00), TotalCost: decimal.NewFromFloat(2000.00), EntryDate: time.Now().Add(-24*time.Hour)},
}

// Calculate cost for 50 units using FIFO
ctx := context.Background()
costCtx := strategy.CostContext{Quantity: decimal.NewFromInt(50)}
result, err := fifo.CalculateCost(ctx, costCtx, entries)

// FIFO result: $10.00 * 50 = $500.00 (uses oldest stock first)
// Moving Avg: $15.00 * 50 = $750.00 (uses weighted average)
```

### Cost Method Comparison
| Scenario | FIFO | Moving Average |
|----------|------|----------------|
| Rising prices | Lower COGS, higher profit | Higher COGS, lower profit |
| Falling prices | Higher COGS, lower profit | Lower COGS, higher profit |
| Tax implications | May defer taxes | Smoother tax impact |
| Inventory valuation | Reflects recent costs | Smooths cost fluctuations |

### Notes for next developer
- **P2-BE-004** (Batch management strategies): Similar pattern can be used for batch selection
- **P2-BE-005** (InventoryTransaction): Should record which cost method was used for each transaction
- **P2-BE-007** (Repository): Needs to provide stock entries sorted appropriately for each strategy
- Default cost strategy is Moving Average (can be changed via `registry.SetDefault`)
- FIFO always sorts entries by EntryDate before processing
- Both strategies handle insufficient stock gracefully (returns RemainingQty)


---

## 2026-01-24 - P2-BE-005: InventoryTransaction Implementation Complete

### Completed
- **P2-BE-005**: InventoryTransaction 实现

### What was done
1. Created `InventoryTransaction` entity at `internal/domain/inventory/inventory_transaction.go`:
   - Immutable record of all inventory movements
   - Transaction types: INBOUND, OUTBOUND, ADJUSTMENT_INCREASE, ADJUSTMENT_DECREASE, TRANSFER_IN, TRANSFER_OUT, RETURN, LOCK, UNLOCK
   - Source types: PURCHASE_ORDER, SALES_ORDER, SALES_RETURN, PURCHASE_RETURN, STOCK_TAKING, MANUAL_ADJUSTMENT, TRANSFER, INITIAL_STOCK
   - Tracks quantity, unit cost, total cost, balance before/after
   - Links to source documents (sourceType, sourceID, sourceLineID)
   - Optional links to batches and locks
   - Reference and reason fields for audit
   - Operator tracking

2. Key features implemented:
   - **Immutability**: Transactions are append-only, cannot be modified or deleted
   - **Transaction types** with helper methods:
     - `IsValid()` - Validates transaction type
     - `IsIncrease()` - Returns true for types that increase available quantity
     - `IsDecrease()` - Returns true for types that decrease available quantity
   - **Signed quantity/cost methods**:
     - `GetSignedQuantity()` - Returns positive/negative based on type
     - `GetSignedTotalCost()` - Returns positive/negative based on type
   - **Fluent builder pattern** for creating transactions with optional fields
   - **Helper functions**: `CreateInboundTransaction()`, `CreateOutboundTransaction()`, `CreateAdjustmentTransaction()`

3. Created comprehensive unit tests at `inventory_transaction_test.go`:
   - 19 test cases covering all transaction types
   - Validation tests for all required fields
   - Tests for builder pattern
   - Tests for helper functions
   - Coverage: ~75% of inventory domain

4. Created database migration:
   - `000008_create_inventory_transactions.up.sql`:
     - Created `transaction_type` and `source_type` enums
     - Created `inventory_transactions` table with proper indexes
     - Added triggers to prevent UPDATE and DELETE (immutable audit log)
     - Added CHECK constraints for data integrity
   - `000008_create_inventory_transactions.down.sql`:
     - Clean rollback of all objects

### Transaction Type Reference

| Type | Direction | Use Case |
|------|-----------|----------|
| INBOUND | + | Purchase receiving, returns from customer |
| OUTBOUND | - | Sales shipment |
| ADJUSTMENT_INCREASE | + | Positive stock adjustment |
| ADJUSTMENT_DECREASE | - | Negative stock adjustment |
| TRANSFER_IN | + | Stock received from another warehouse |
| TRANSFER_OUT | - | Stock sent to another warehouse |
| RETURN | + | Customer returns, defect returns |
| LOCK | - | Stock reserved for pending orders |
| UNLOCK | + | Released reservation (cancelled order) |

### Source Type Reference

| Source Type | Description |
|-------------|-------------|
| PURCHASE_ORDER | Stock from purchase order receiving |
| SALES_ORDER | Stock reduction from sales shipment |
| SALES_RETURN | Stock return from customer |
| PURCHASE_RETURN | Stock return to supplier |
| STOCK_TAKING | Adjustment from inventory count |
| MANUAL_ADJUSTMENT | Manual correction |
| TRANSFER | Inter-warehouse transfer |
| INITIAL_STOCK | Initial inventory setup |

### Files created
- `backend/internal/domain/inventory/inventory_transaction.go`
- `backend/internal/domain/inventory/inventory_transaction_test.go`
- `backend/migrations/000008_create_inventory_transactions.up.sql`
- `backend/migrations/000008_create_inventory_transactions.down.sql`

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests
- Test coverage: 74.8% for inventory domain

### Usage Examples

```go
// Create inbound transaction
tx, err := inventory.CreateInboundTransaction(
    tenantID, inventoryItemID, warehouseID, productID,
    quantity, unitCost,
    balanceBefore, balanceAfter,
    inventory.SourceTypePurchaseOrder, "PO-2024-001",
)
tx.WithReference("REF-001").
   WithReason("Purchase receiving").
   WithOperatorID(userID)

// Create adjustment transaction
tx, err := inventory.CreateAdjustmentTransaction(
    tenantID, inventoryItemID, warehouseID, productID,
    decimal.NewFromInt(10), unitCost,
    decimal.NewFromInt(100), decimal.NewFromInt(110),
    inventory.SourceTypeStockTaking, "ST-2024-001",
    "Stock count variance",
)

// Using builder pattern
tx, err := inventory.NewTransactionBuilder(
    tenantID, inventoryItemID, warehouseID, productID,
    inventory.TransactionTypeOutbound,
    quantity, unitCost,
    balanceBefore, balanceAfter,
    inventory.SourceTypeSalesOrder, "SO-2024-001",
).
    WithLockID(lockID).
    WithSourceLineID("LINE-001").
    WithOperatorID(userID).
    Build()
```

### Notes for next developer
- **P2-BE-007** (Inventory Repository): Should include methods for querying transactions
- **P2-BE-008** (Application Service): Should create transactions when performing inventory operations
- The transaction table is immutable - corrections must be made with new reverse transactions
- Consider adding indexes for common query patterns (date range, product, warehouse)
- Transaction types like LOCK/UNLOCK don't change physical stock but track reservation movements
- Balance fields track available quantity, not total quantity (available + locked)


---

## 2026-01-24 - P2-BE-007: Inventory Repository Interface + Implementation Complete

### Completed
- **P2-BE-007**: Inventory Repository 接口 + 实现

### What was done
1. Created repository interfaces in `internal/domain/inventory/repository.go`:
   - `InventoryItemRepository` - Full CRUD and query operations for inventory items
     - FindByID, FindByIDForTenant, FindByWarehouseAndProduct
     - FindByWarehouse, FindByProduct, FindAllForTenant
     - FindBelowMinimum, FindWithAvailableStock, FindByIDs
     - Save, SaveWithLock (optimistic locking), Delete, DeleteForTenant
     - CountForTenant, CountByWarehouse, CountByProduct
     - SumQuantityByProduct, SumValueByWarehouse
     - ExistsByWarehouseAndProduct, GetOrCreate
   - `StockBatchRepository` - Batch management operations
     - FindByID, FindByInventoryItem, FindAvailable
     - FindExpiringSoon, FindExpired, FindByBatchNumber
     - Save, SaveBatch, Delete, CountByInventoryItem
   - `StockLockRepository` - Lock management operations
     - FindByID, FindByInventoryItem, FindActive
     - FindExpired, FindBySource
     - Save, Delete, ReleaseExpired
   - `InventoryTransactionRepository` - Transaction (audit log) operations
     - FindByID, FindByInventoryItem, FindByWarehouse, FindByProduct
     - FindBySource, FindByDateRange, FindByType, FindForTenant
     - Create, CreateBatch (no Update/Delete - append-only)
     - CountForTenant, CountByInventoryItem
     - SumQuantityByTypeAndDateRange
   - `InventoryFilter` and `TransactionFilter` - Extended filter types

2. Created database migration `000009_create_inventory_items`:
   - `inventory_items` table with unique constraint on (tenant_id, warehouse_id, product_id)
   - `stock_batches` table with foreign key to inventory_items
   - `stock_locks` table with foreign key to inventory_items
   - Added foreign keys from inventory_transactions to inventory_items, stock_batches, stock_locks
   - Proper indexes for common query patterns
   - Update triggers for updated_at columns

3. Implemented GORM repositories in `internal/infrastructure/persistence/`:
   - `inventory_repository.go` - GormInventoryItemRepository
     - Full filter support (warehouse_id, product_id, below_minimum, has_stock, etc.)
     - Optimistic locking with version check in SaveWithLock
     - GetOrCreate using ON CONFLICT DO NOTHING for race condition handling
   - `stock_batch_repository.go` - GormStockBatchRepository
     - FEFO (First Expired, First Out) ordering for FindAvailable
     - Expiry date based queries
   - `stock_lock_repository.go` - GormStockLockRepository
     - Bulk release of expired locks
   - `inventory_transaction_repository.go` - GormInventoryTransactionRepository
     - Create only (no Update/Delete as per audit log requirements)
     - Full filtering by warehouse, product, type, source, date range

4. Wrote comprehensive unit tests (36 test cases):
   - `inventory_repository_test.go` covering all four repositories
   - Tests for CRUD operations, counts, existence checks
   - Interface compliance tests

### Files created
- `backend/internal/domain/inventory/repository.go`
- `backend/migrations/000009_create_inventory_items.up.sql`
- `backend/migrations/000009_create_inventory_items.down.sql`
- `backend/internal/infrastructure/persistence/inventory_repository.go`
- `backend/internal/infrastructure/persistence/stock_batch_repository.go`
- `backend/internal/infrastructure/persistence/stock_lock_repository.go`
- `backend/internal/infrastructure/persistence/inventory_transaction_repository.go`
- `backend/internal/infrastructure/persistence/inventory_repository_test.go`

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests (36 new tests for inventory repositories)

### Repository Interface Summary

| Repository | Key Methods |
|------------|-------------|
| InventoryItemRepository | FindByWarehouseAndProduct, GetOrCreate, SaveWithLock |
| StockBatchRepository | FindAvailable (FEFO), FindExpiringSoon |
| StockLockRepository | FindActive, FindExpired, ReleaseExpired |
| InventoryTransactionRepository | Create, FindBySource, SumQuantityByTypeAndDateRange |

### Key Design Decisions
1. **Optimistic Locking**: `SaveWithLock` checks version before update to prevent lost updates
2. **GetOrCreate**: Uses PostgreSQL `ON CONFLICT DO NOTHING` for race-safe upsert
3. **FEFO Ordering**: Stock batches ordered by expiry date for proper inventory rotation
4. **Append-Only Transactions**: No Update/Delete methods on transaction repository
5. **Multi-dimensional Queries**: Support for filtering by warehouse, product, type, date range

### Notes for next developer
- **P2-BE-008** (Inventory Application Service): Can now use these repositories
- **P2-BE-009** (Inventory API): Depends on P2-BE-008
- Run `./bin/migrate up` to apply migration 000009
- Use `SaveWithLock` when modifying quantities to prevent race conditions
- Use `GetOrCreate` when you need to ensure inventory item exists
- Transaction repository only supports Create - corrections require new reverse transactions
- Consider using `FindBelowMinimum` for stock alert functionality
- `SumQuantityByProduct` useful for showing total stock across warehouses


---

## 2026-01-24 - P2-BE-008: Inventory Application Service Complete

### Completed
- **P2-BE-008**: Inventory Application Service

### What was done
1. Created DTOs at `internal/application/inventory/dto.go`:
   - `InventoryItemResponse` - Full inventory item response
   - `InventoryListItemResponse` - List item response (lighter weight)
   - `InventoryListFilter` - Query filters with pagination
   - `IncreaseStockRequest` - Request to add stock
   - `LockStockRequest` / `LockStockResponse` - Stock locking
   - `UnlockStockRequest` - Release locked stock
   - `DeductStockRequest` - Consume locked stock
   - `AdjustStockRequest` - Stock count adjustment
   - `SetThresholdsRequest` - Min/max quantity thresholds
   - `StockLockResponse` - Lock details
   - `TransactionResponse` - Audit log transaction
   - `TransactionListFilter` - Transaction query filters
   - `InventorySummaryResponse` / `WarehouseSummary` - Statistics
   - Conversion functions for all domain objects to DTOs

2. Created `InventoryService` at `internal/application/inventory/inventory_service.go`:
   - **Query Operations:**
     - `GetByID()` - Get inventory by ID
     - `GetByWarehouseAndProduct()` - Get by warehouse-product combo
     - `List()` - List with filtering (warehouse, product, below minimum, has stock)
     - `ListByWarehouse()` - List all items in a warehouse
     - `ListByProduct()` - List all warehouses for a product
     - `ListBelowMinimum()` - Items below threshold
     - `GetTotalQuantityByProduct()` - Sum across warehouses
     - `GetTotalValueByWarehouse()` - Total inventory value
     - `CheckAvailability()` - Check if quantity can be fulfilled
   
   - **Stock Operations:**
     - `IncreaseStock()` - Add stock with moving weighted average cost
     - `LockStock()` - Reserve stock for pending orders (30min default expiry)
     - `UnlockStock()` - Release locked stock (order cancelled)
     - `DeductStock()` - Consume locked stock (order fulfilled)
     - `AdjustStock()` - Stock count adjustment
     - `SetThresholds()` - Set min/max quantity alerts
   
   - **Lock Management:**
     - `GetActiveLocks()` - Get active locks for an item
     - `GetLockByID()` - Get specific lock
     - `ReleaseExpiredLocks()` - Batch release expired locks
   
   - **Transaction Queries:**
     - `ListTransactions()` - List with filtering
     - `ListTransactionsByInventoryItem()` - Transactions for specific item
     - `GetTransactionByID()` - Get specific transaction

3. Created comprehensive unit tests at `internal/application/inventory/inventory_service_test.go`:
   - Mock implementations for all 4 repository interfaces
   - 23 test cases covering:
     - Service instantiation
     - GetByID (success, not found)
     - GetByWarehouseAndProduct (success, not found)
     - List (with defaults, with filters)
     - IncreaseStock (success, invalid source type)
     - LockStock (success, insufficient stock, no inventory)
     - UnlockStock (success, lock not found)
     - AdjustStock (increase, decrease, with locked stock)
     - SetThresholds
     - CheckAvailability (sufficient, insufficient, no inventory)
     - ListTransactions
     - DTO conversion functions

### Service Method Reference

| Category | Method | Description |
|----------|--------|-------------|
| Query | GetByID | Get inventory item by ID |
| Query | GetByWarehouseAndProduct | Get by warehouse-product |
| Query | List | List with filtering |
| Query | CheckAvailability | Check if quantity available |
| Stock | IncreaseStock | Add stock with cost recalc |
| Stock | LockStock | Reserve stock for order |
| Stock | UnlockStock | Release reservation |
| Stock | DeductStock | Consume locked stock |
| Stock | AdjustStock | Stock count adjustment |
| Threshold | SetThresholds | Set min/max alerts |
| Lock | GetActiveLocks | Get active locks |
| Lock | ReleaseExpiredLocks | Cleanup expired locks |
| Transaction | ListTransactions | Query audit log |

### Files created
- `backend/internal/application/inventory/dto.go`
- `backend/internal/application/inventory/inventory_service.go`
- `backend/internal/application/inventory/inventory_service_test.go`

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests (23 new tests for inventory service)

### Usage Examples

```go
// Create service
service := inventory.NewInventoryService(invRepo, batchRepo, lockRepo, txRepo)

// Query inventory
items, total, err := service.List(ctx, tenantID, inventory.InventoryListFilter{
    WarehouseID: &warehouseID,
    HasStock:    &[]bool{true}[0],
    Page:        1,
    PageSize:    20,
})

// Increase stock (purchase receiving)
resp, err := service.IncreaseStock(ctx, tenantID, inventory.IncreaseStockRequest{
    WarehouseID: warehouseID,
    ProductID:   productID,
    Quantity:    decimal.NewFromInt(100),
    UnitCost:    decimal.NewFromFloat(15.50),
    SourceType:  "PURCHASE_ORDER",
    SourceID:    "PO-2024-001",
})

// Lock stock for sales order
lockResp, err := service.LockStock(ctx, tenantID, inventory.LockStockRequest{
    WarehouseID: warehouseID,
    ProductID:   productID,
    Quantity:    decimal.NewFromInt(10),
    SourceType:  "sales_order",
    SourceID:    "SO-2024-001",
})

// Deduct stock (shipment)
err = service.DeductStock(ctx, tenantID, inventory.DeductStockRequest{
    LockID:     lockResp.LockID,
    SourceType: "SALES_ORDER",
    SourceID:   "SO-2024-001",
})

// Adjust stock (stock count)
resp, err = service.AdjustStock(ctx, tenantID, inventory.AdjustStockRequest{
    WarehouseID:    warehouseID,
    ProductID:      productID,
    ActualQuantity: decimal.NewFromInt(95),
    Reason:         "Stock count variance - 5 units damaged",
})
```

### Notes for next developer
- **P2-BE-009** (Inventory API): Can now implement HTTP handlers using this service
- All stock operations create transaction records for audit
- Lock expiry defaults to 30 minutes (configurable via `ExpireAt` field)
- Adjust stock fails if there are outstanding locks (prevents inconsistency)
- Transaction records are append-only - corrections require new transactions
- Use `CheckAvailability()` before `LockStock()` for early validation
- Consider running `ReleaseExpiredLocks()` as a periodic job

---

## 2026-01-24 - P2-BE-009: Inventory API Implementation

### Completed
- **P2-BE-009**: Inventory API (查询/锁定/调整)

### What was done
1. Created `InventoryHandler` at `internal/interfaces/http/handler/inventory.go`:
   - 20+ HTTP endpoints for inventory management
   - Full swag annotations for OpenAPI documentation
   - Proper request validation and error handling
   - Multi-tenant support via X-Tenant-ID header

2. Registered inventory routes in `cmd/server/main.go`:
   - Added inventory repositories initialization
   - Added inventory service initialization
   - Added inventory handler initialization
   - Registered 26 routes under `/api/v1/inventory/`

3. Created comprehensive unit tests at `internal/interfaces/http/handler/inventory_test.go`:
   - Mock implementations for all 4 repository interfaces
   - 14 test cases covering all handler operations

4. Generated OpenAPI documentation with swag

### API Endpoints Reference

| Category | Method | Endpoint | Description |
|----------|--------|----------|-------------|
| Query | GET | /inventory/items | List inventory items with filtering |
| Query | GET | /inventory/items/:id | Get inventory item by ID |
| Query | GET | /inventory/items/lookup | Get by warehouse and product |
| Query | GET | /inventory/items/alerts/low-stock | List items below minimum |
| Query | GET | /inventory/items/:id/transactions | List transactions by item |
| Query | GET | /inventory/warehouses/:warehouse_id/items | List by warehouse |
| Query | GET | /inventory/products/:product_id/items | List by product |
| Stock Ops | POST | /inventory/availability/check | Check stock availability |
| Stock Ops | POST | /inventory/stock/increase | Increase stock (purchase/return) |
| Stock Ops | POST | /inventory/stock/lock | Lock stock (reserve) |
| Stock Ops | POST | /inventory/stock/unlock | Unlock stock (cancel) |
| Stock Ops | POST | /inventory/stock/deduct | Deduct stock (shipment) |
| Stock Ops | POST | /inventory/stock/adjust | Adjust stock (count) |
| Threshold | PUT | /inventory/thresholds | Set min/max thresholds |
| Locks | GET | /inventory/locks | Get active locks |
| Locks | GET | /inventory/locks/:id | Get lock by ID |
| Audit | GET | /inventory/transactions | List all transactions |
| Audit | GET | /inventory/transactions/:id | Get transaction by ID |

### Request/Response DTOs

Handler defines these local types for swagger documentation:
- `InventoryItemResponse` - Full inventory item details
- `CheckAvailabilityRequest/Response` - Availability check
- `IncreaseStockRequest` - Stock increase operation
- `LockStockRequest/Response` - Stock lock operation
- `UnlockStockRequest` - Stock unlock operation
- `DeductStockRequest` - Stock deduction operation
- `AdjustStockRequest` - Stock adjustment operation
- `SetThresholdsRequest` - Threshold configuration
- `StockLockResponse` - Stock lock details
- `TransactionResponse` - Transaction audit record

### Files created/modified
- `backend/internal/interfaces/http/handler/inventory.go` (created)
- `backend/internal/interfaces/http/handler/inventory_test.go` (created)
- `backend/cmd/server/main.go` (modified - added inventory routes)
- `backend/docs/swagger.yaml` (regenerated)
- `backend/docs/swagger.json` (regenerated)

### Build & Test Status
- `go build ./...` passes successfully
- `go test ./internal/interfaces/http/handler/...` passes all 14 inventory tests
- `swag init` generates OpenAPI docs without errors

### Usage Examples

```bash
# List inventory items
curl -X GET "http://localhost:8080/api/v1/inventory/items?page=1&page_size=20" \
  -H "X-Tenant-ID: 00000000-0000-0000-0000-000000000001"

# Check stock availability
curl -X POST "http://localhost:8080/api/v1/inventory/availability/check" \
  -H "Content-Type: application/json" \
  -H "X-Tenant-ID: 00000000-0000-0000-0000-000000000001" \
  -d '{
    "warehouse_id": "550e8400-e29b-41d4-a716-446655440000",
    "product_id": "550e8400-e29b-41d4-a716-446655440001",
    "quantity": 10
  }'

# Increase stock (purchase receiving)
curl -X POST "http://localhost:8080/api/v1/inventory/stock/increase" \
  -H "Content-Type: application/json" \
  -H "X-Tenant-ID: 00000000-0000-0000-0000-000000000001" \
  -d '{
    "warehouse_id": "550e8400-e29b-41d4-a716-446655440000",
    "product_id": "550e8400-e29b-41d4-a716-446655440001",
    "quantity": 100,
    "unit_cost": 15.50,
    "source_type": "PURCHASE_ORDER",
    "source_id": "PO-2024-001"
  }'

# Lock stock for order
curl -X POST "http://localhost:8080/api/v1/inventory/stock/lock" \
  -H "Content-Type: application/json" \
  -H "X-Tenant-ID: 00000000-0000-0000-0000-000000000001" \
  -d '{
    "warehouse_id": "550e8400-e29b-41d4-a716-446655440000",
    "product_id": "550e8400-e29b-41d4-a716-446655440001",
    "quantity": 10,
    "source_type": "sales_order",
    "source_id": "SO-2024-001"
  }'

# Set thresholds
curl -X PUT "http://localhost:8080/api/v1/inventory/thresholds" \
  -H "Content-Type: application/json" \
  -H "X-Tenant-ID: 00000000-0000-0000-0000-000000000001" \
  -d '{
    "warehouse_id": "550e8400-e29b-41d4-a716-446655440000",
    "product_id": "550e8400-e29b-41d4-a716-446655440001",
    "min_quantity": 20,
    "max_quantity": 500
  }'
```

### Notes for next developer
- **P2-FE-001** (库存查询列表页面): Can now implement frontend using these APIs
- All endpoints return standardized `dto.Response` format
- Stock operations require valid source_type values (e.g., PURCHASE_ORDER, SALES_ORDER)
- Lock expiry defaults to 30 minutes if not specified
- Adjust stock fails if there are active locks (to prevent inconsistency)
- Transaction list supports filtering by type, source, and date range
- Low stock alert endpoint (`/alerts/low-stock`) returns items below minimum threshold

---

## 2026-01-24 - P2-FE-001: Inventory Stock List Page Complete

### Completed
- **P2-FE-001**: 库存查询列表页面

### What was done
1. Regenerated frontend TypeScript SDK from OpenAPI spec:
   - New `src/api/inventory/` directory with typed API client
   - Generated types: `HandlerInventoryItemResponse`, `GetInventoryItemsParams`, etc.
   - All inventory endpoints available: list, lookup, lock, unlock, adjust, etc.

2. Implemented Stock List page at `src/pages/inventory/StockList.tsx`:
   - Full inventory listing with DataTable component
   - Server-side pagination support
   - Sortable columns (available_quantity, locked_quantity, total_quantity, unit_cost, total_value, updated_at)
   - Warehouse name and product name resolution from IDs
   - Row actions: View detail, View transactions, Adjust stock

3. Implemented filtering:
   - Warehouse dropdown filter (fetches active warehouses)
   - Stock status filter: All / Has stock / Low stock warning / No stock
   - Search input for product search

4. Quantity display features:
   - Available quantity with low stock warning icon
   - Locked quantity with special styling
   - Total quantity display
   - Unit cost and total value columns
   - Status tags: 正常 (normal), 低库存 (low), 超上限 (above max), 无库存 (no stock)

5. Created CSS styling at `src/pages/inventory/StockList.css`:
   - Warning styles for low stock quantities
   - Locked quantity highlighting
   - Dark mode support
   - Responsive layout adjustments

### Files created/modified
- `frontend/src/pages/inventory/StockList.tsx` (rewritten)
- `frontend/src/pages/inventory/StockList.css` (new)
- `frontend/src/api/inventory/inventory.ts` (auto-generated)
- `frontend/src/api/models/*.ts` (auto-generated inventory models)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings from other files)
- `npm run build` passes

### API Endpoints Used
| Method | Endpoint | Purpose |
|--------|----------|---------|
| GET | /inventory/items | List inventory items with filtering |
| GET | /partner/warehouses | Get warehouses for filter dropdown |
| GET | /catalog/products | Get products for name display |

### Page Features Summary
| Feature | Status |
|---------|--------|
| Inventory list display | ✅ |
| Warehouse filter | ✅ |
| Stock status filter | ✅ |
| Search functionality | ✅ |
| Available quantity display | ✅ |
| Locked quantity display | ✅ |
| Low stock warning indicator | ✅ |
| Pagination | ✅ |
| Sorting | ✅ |
| Row actions (view/transactions/adjust) | ✅ |

### Notes for next developer
- **P2-FE-002** (库存明细页面): Next priority - implement batch and transaction detail pages
- **P2-FE-003** (库存调整页面): Can implement using `postInventoryStockAdjust` API
- Warehouse and product names are cached in Maps for display - consider using React Query for caching
- The stock detail and transaction routes (`/inventory/stock/:id/*`) need corresponding page components
- The adjust stock route (`/inventory/adjust`) needs corresponding page component
- Consider adding real-time refresh or polling for stock changes in production

---

## 2026-01-24 - P2-FE-002: Inventory Detail Page Complete

### Completed
- **P2-FE-002**: 库存明细页面 (批次/流水)

### What was done
1. Implemented Stock Detail page at `src/pages/inventory/StockDetail.tsx`:
   - Display inventory item basic information (warehouse, product, update time)
   - Display quantity information (available, locked, total) with visual indicators
   - Display cost information (unit cost, total value)
   - Display threshold settings (minimum, maximum quantity)
   - Status tag showing current stock status (normal, low stock, above max, no stock)
   - Transaction history table with pagination and sorting
   - Navigation actions (back, refresh, adjust stock)

2. Implemented Stock Transactions page at `src/pages/inventory/StockTransactions.tsx`:
   - Dedicated page for viewing transaction history
   - Transaction type filter (INBOUND, OUTBOUND, LOCK, UNLOCK, ADJUSTMENT)
   - Date range filter for time-based filtering
   - Sortable columns (transaction date, signed quantity)
   - Display transaction details: date, type, quantity change, balance before/after, cost, source type/ID, reference, reason
   - Summary header showing current inventory status

3. Created CSS files for both pages following design system tokens:
   - `StockDetail.css` - Styles for detail page with quantity grid, responsive layout
   - `StockTransactions.css` - Styles for transactions page with quantity color indicators

4. Updated router configuration:
   - Added lazy-loaded StockDetailPage and StockTransactionsPage
   - Added routes: `/inventory/stock/:id` and `/inventory/stock/:id/transactions`

5. Fixed StockList page icon import (IconWarning → IconAlertTriangle)

### Files created/modified
- `frontend/src/pages/inventory/StockDetail.tsx` (new)
- `frontend/src/pages/inventory/StockDetail.css` (new)
- `frontend/src/pages/inventory/StockTransactions.tsx` (new)
- `frontend/src/pages/inventory/StockTransactions.css` (new)
- `frontend/src/pages/inventory/StockList.tsx` (fixed icon import)
- `frontend/src/router/routes.tsx` (added inventory detail routes)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings)
- `npm run build` passes

### Page Features Summary

**Stock Detail Page:**
| Feature | Status |
|---------|--------|
| Basic info display (warehouse, product) | ✅ |
| Quantity display (available, locked, total) | ✅ |
| Low stock warning indicator | ✅ |
| Cost information display | ✅ |
| Threshold settings display | ✅ |
| Status tag | ✅ |
| Transaction history (embedded) | ✅ |
| Navigation actions | ✅ |

**Stock Transactions Page:**
| Feature | Status |
|---------|--------|
| Transaction listing | ✅ |
| Transaction type filter | ✅ |
| Date range filter | ✅ |
| Sortable columns | ✅ |
| Pagination | ✅ |
| Balance before/after display | ✅ |
| Source type/ID display | ✅ |
| Item info summary | ✅ |

### API Endpoints Used
| Method | Endpoint | Purpose |
|--------|----------|---------|
| GET | /inventory/items/:id | Get inventory item details |
| GET | /inventory/items/:id/transactions | List transactions for item |
| GET | /partner/warehouses | Get warehouse names |
| GET | /catalog/products | Get product names |

### Notes for next developer
- **P2-FE-003** (库存调整页面): Next high priority - implement stock adjustment form
- **P1-INT-001/002** (前后端联调): Integration testing can now proceed with inventory module
- Transaction type labels and source type labels are localized to Chinese
- Both pages follow responsive design with mobile breakpoints
- Dark mode is supported via CSS variables
- The adjust stock navigation requires implementing `/inventory/adjust` page


---

## 2026-01-24 - P2-FE-003: Stock Adjustment Page Complete

### Completed
- **P2-FE-003**: 库存调整页面

### What was done
1. Implemented Stock Adjustment page at `src/pages/inventory/StockAdjust.tsx`:
   - Warehouse and product selection with search support
   - Pre-fill warehouse and product from URL query parameters
   - Display current stock information (total, available, locked quantities)
   - Show cost information (unit cost, total value)
   - Locked stock warning indicator

2. Implemented adjustment form features:
   - Actual quantity input with validation (non-negative)
   - Adjustment reason selection with predefined options:
     - 盘点调整 (Stock take)
     - 破损报废 (Damaged)
     - 丢失 (Lost)
     - 数据校正 (Data correction)
     - 期初录入 (Initial entry)
     - 其他 (Other)
   - Optional notes/remarks field

3. Implemented adjustment preview:
   - Current quantity → Adjusted quantity visual comparison
   - Calculated difference (变动数量)
   - Color-coded indicator (green for gain/盘盈, red for loss/盘亏)

4. Created CSS styling at `src/pages/inventory/StockAdjust.css`:
   - Responsive layout with mobile breakpoints
   - Preview section with clear visual hierarchy
   - Dark mode support via CSS variables

5. Updated router configuration:
   - Added lazy-loaded StockAdjustPage
   - Added route: `/inventory/adjust`
   - Supports query params: `?warehouse_id=...&product_id=...`

### Files created/modified
- `frontend/src/pages/inventory/StockAdjust.tsx` (new)
- `frontend/src/pages/inventory/StockAdjust.css` (new)
- `frontend/src/router/routes.tsx` (added adjust route)
- `.claude/ralph/plans/prd.json` (marked P2-FE-003 as complete)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings)
- `npm run build` passes

### Page Features Summary
| Feature | Status |
|---------|--------|
| Warehouse selection with search | ✅ |
| Product selection with search | ✅ |
| URL parameter pre-fill | ✅ |
| Current stock display | ✅ |
| Locked stock warning | ✅ |
| Actual quantity input | ✅ |
| Reason selection dropdown | ✅ |
| Notes field | ✅ |
| Adjustment preview | ✅ |
| Gain/loss indicator | ✅ |
| Form validation | ✅ |
| API integration | ✅ |

### API Endpoints Used
| Method | Endpoint | Purpose |
|--------|----------|---------|
| GET | /partner/warehouses | Get warehouses for dropdown |
| GET | /catalog/products | Get products for dropdown |
| GET | /inventory/items/lookup | Get current stock by warehouse+product |
| POST | /inventory/stock/adjust | Submit stock adjustment |

### Navigation Flow
1. From StockList page → Click row action "调整" → Opens StockAdjust with pre-filled warehouse/product
2. From StockDetail page → Click "库存调整" button → Opens StockAdjust with pre-filled warehouse/product
3. Direct navigation to `/inventory/adjust` → Manual selection of warehouse/product

### Notes for next developer
- **P2-INT-001** (库存模块前后端联调): Can now test the complete inventory adjustment flow
- **P2-BE-011/012** (盘点功能): Stock taking backend features are next if planning inventory count workflows
- **P2-QA-003** (库存锁定并发测试): Consider testing concurrent adjustments
- The adjustment form handles the case where no inventory record exists (creates new)
- Backend API (`/inventory/stock/adjust`) fails if there are active locks on the inventory item
- Form uses Zod validation integrated with react-hook-form
- All form components follow the project's design system tokens

---

## P3-BE-001 + P3-BE-002: SalesOrder Aggregate Root & SalesOrderItem Entity

**Date**: 2026-01-24
**Status**: ✅ COMPLETE

### Summary
Implemented the SalesOrder aggregate root and SalesOrderItem entity for the Trade module. This includes a complete state machine for order lifecycle management, domain events for cross-context communication, and comprehensive unit tests.

### Implementation Details

#### 1. OrderStatus State Machine
```
DRAFT → CONFIRMED → SHIPPED → COMPLETED
  ↓         ↓
CANCELLED  CANCELLED
```

- **DRAFT**: Initial state, items can be added/modified/removed, discount can be applied
- **CONFIRMED**: Order is confirmed, requires at least one item and positive payable amount
- **SHIPPED**: Order has been shipped, requires warehouse to be set
- **COMPLETED**: Terminal state, order delivered/received
- **CANCELLED**: Terminal state, requires cancel reason

#### 2. SalesOrder Aggregate Root
- Tenant-scoped using `TenantAggregateRoot`
- Order number with uniqueness constraint per tenant
- Customer information (ID, name)
- Optional warehouse assignment (required before shipping)
- Amount calculations: TotalAmount, DiscountAmount, PayableAmount
- Status tracking with timestamps (ConfirmedAt, ShippedAt, CompletedAt, CancelledAt)
- Version field for optimistic locking

#### 3. SalesOrderItem Entity
- Product information (ID, name, code, unit)
- Quantity and UnitPrice with automatic Amount calculation
- Duplicate product prevention (same product cannot be added twice)
- Quantity and price update methods with automatic recalculation

#### 4. Domain Events
| Event | Triggered When | Contains |
|-------|----------------|----------|
| SalesOrderCreatedEvent | Order created | Order details |
| SalesOrderConfirmedEvent | Order confirmed | Full order with items |
| SalesOrderShippedEvent | Order shipped | Order + warehouse info |
| SalesOrderCompletedEvent | Order completed | Order details |
| SalesOrderCancelledEvent | Order cancelled | Order + WasConfirmed flag |

The `WasConfirmed` flag in cancelled event helps downstream services (like inventory) know if stock locks need to be released.

### Files Created
| File | Description |
|------|-------------|
| `backend/internal/domain/trade/sales_order.go` | SalesOrder aggregate root, SalesOrderItem entity, OrderStatus enum |
| `backend/internal/domain/trade/sales_order_events.go` | Domain events for order lifecycle |
| `backend/internal/domain/trade/sales_order_test.go` | Comprehensive unit tests |

### Test Coverage
- 49+ test cases covering:
  - OrderStatus validation and transitions
  - SalesOrder creation and validation
  - Item CRUD operations
  - Discount application
  - Warehouse assignment
  - State transitions (Confirm, Ship, Complete, Cancel)
  - Domain event generation
  - Edge cases and error conditions

### Build Status
- All tests pass: `go test ./internal/domain/trade/...`
- No linting issues

### Key Design Decisions
1. **Immutable Order Number**: Cannot be changed after creation
2. **Single Product Per Item**: Same product cannot be added twice; use UpdateItemQuantity instead
3. **Discount Validation**: Cannot exceed total amount
4. **Warehouse Required for Shipping**: Enforced at domain level
5. **Cancel Reason Required**: Must provide reason when cancelling

### Next Steps
- **P3-BE-003**: Multi-unit quantity conversion (if needed)
- **P3-BE-004**: Pricing strategies (standard/tiered)
- **P3-BE-005**: SalesOrder Application Service
- **P3-BE-006**: Event handling for inventory lock integration
- **P3-BE-007**: SalesOrder HTTP API


---

## 2026-01-24 - P3-BE-005: SalesOrder Application Service Complete

### Completed
- **P3-BE-005**: SalesOrder Application Service

### What was done
1. Created SalesOrderRepository interface in `internal/domain/trade/repository.go`:
   - Standard CRUD methods (FindByID, FindByIDForTenant, Save, SaveWithLock, Delete)
   - Query methods (FindByOrderNumber, FindAllForTenant, FindByCustomer, FindByStatus, FindByWarehouse)
   - Count methods (CountForTenant, CountByStatus, CountByCustomer)
   - Utility methods (ExistsByOrderNumber, GenerateOrderNumber)

2. Created DTOs in `internal/application/trade/dto.go`:
   - Request DTOs: CreateSalesOrderRequest, UpdateSalesOrderRequest, AddOrderItemRequest, UpdateOrderItemRequest
   - Status change DTOs: ConfirmOrderRequest, ShipOrderRequest, CancelOrderRequest
   - Response DTOs: SalesOrderResponse, SalesOrderListItemResponse, SalesOrderItemResponse
   - Filter DTO: SalesOrderListFilter with support for customer, warehouse, status, date range, amount range
   - Summary DTO: OrderStatusSummary for dashboard statistics
   - Converter functions: ToSalesOrderResponse, ToSalesOrderListItemResponse, ToSalesOrderItemResponse

3. Created SalesOrderService in `internal/application/trade/sales_order_service.go`:
   - **Create**: Creates new sales order with items, optional discount, and warehouse
   - **GetByID/GetByOrderNumber**: Retrieves order details
   - **List**: List orders with filtering (customer, warehouse, status, date range, amount range) and pagination
   - **ListByCustomer/ListByStatus**: Convenience methods for common filters
   - **Update**: Updates draft order (warehouse, discount, remark)
   - **AddItem/UpdateItem/RemoveItem**: Item CRUD operations (draft orders only)
   - **Confirm**: Confirms order (requires items, positive payable amount)
   - **Ship**: Ships order (requires warehouse, transitions from CONFIRMED)
   - **Complete**: Marks order as completed (transitions from SHIPPED)
   - **Cancel**: Cancels order with reason (from DRAFT or CONFIRMED)
   - **Delete**: Deletes draft orders only
   - **GetStatusSummary**: Returns count by status for dashboard

4. Created comprehensive unit tests in `internal/application/trade/sales_order_service_test.go`:
   - Mock repository implementation for all interface methods
   - 22 test cases covering all service methods
   - Tests for success cases, error cases, and edge cases
   - Tests for state machine transitions

### Files created
| File | Description |
|------|-------------|
| `backend/internal/domain/trade/repository.go` | SalesOrderRepository interface |
| `backend/internal/application/trade/dto.go` | Request/response DTOs and converters |
| `backend/internal/application/trade/sales_order_service.go` | Application service implementation |
| `backend/internal/application/trade/sales_order_service_test.go` | Unit tests (22 tests) |

### Test Results
```
=== RUN   TestSalesOrderService_Create (4 subtests) --- PASS
=== RUN   TestSalesOrderService_GetByID (2 subtests) --- PASS
=== RUN   TestSalesOrderService_List (2 subtests) --- PASS
=== RUN   TestSalesOrderService_AddItem (2 subtests) --- PASS
=== RUN   TestSalesOrderService_Confirm (3 subtests) --- PASS
=== RUN   TestSalesOrderService_Ship (2 subtests) --- PASS
=== RUN   TestSalesOrderService_Complete (1 subtest) --- PASS
=== RUN   TestSalesOrderService_Cancel (3 subtests) --- PASS
=== RUN   TestSalesOrderService_Delete (2 subtests) --- PASS
=== RUN   TestSalesOrderService_GetStatusSummary (1 subtest) --- PASS
PASS
ok      github.com/erp/backend/internal/application/trade    0.010s
```

### Build Status
- `go build ./...` passes successfully
- `go test ./...` passes all tests

### Service Methods Summary
| Method | Description | Allowed Status |
|--------|-------------|----------------|
| Create | Create new order | - |
| GetByID | Get order by ID | Any |
| GetByOrderNumber | Get order by number | Any |
| List | List with filters | Any |
| Update | Update order details | DRAFT |
| AddItem | Add item to order | DRAFT |
| UpdateItem | Update item | DRAFT |
| RemoveItem | Remove item | DRAFT |
| Confirm | Confirm order | DRAFT → CONFIRMED |
| Ship | Ship order | CONFIRMED → SHIPPED |
| Complete | Complete order | SHIPPED → COMPLETED |
| Cancel | Cancel order | DRAFT/CONFIRMED → CANCELLED |
| Delete | Delete order | DRAFT |
| GetStatusSummary | Get count by status | - |

### Domain Events Generated (for P3-BE-006)
The application service relies on domain events generated by the SalesOrder aggregate:
- **SalesOrderCreatedEvent**: When order is created
- **SalesOrderConfirmedEvent**: When order is confirmed (trigger stock lock)
- **SalesOrderShippedEvent**: When order is shipped (trigger stock deduction)
- **SalesOrderCompletedEvent**: When order is completed
- **SalesOrderCancelledEvent**: When order is cancelled (trigger stock unlock if WasConfirmed)

### Notes for next developer
- **P3-BE-006** (SalesOrder Event Handling): Implement event handlers to integrate with inventory
  - Subscribe to SalesOrderConfirmedEvent → Lock stock in inventory
  - Subscribe to SalesOrderShippedEvent → Deduct stock from inventory
  - Subscribe to SalesOrderCancelledEvent → Unlock stock if WasConfirmed=true
- **P3-BE-007** (SalesOrder API): Implement HTTP handlers using this service
- Repository implementation (GORM) is needed before integration testing
- GenerateOrderNumber should follow format like "SO-YYYY-NNNNN" (tenant-unique)
- Consider adding OrderHistory entity to track all status changes with timestamps and user
- For high-concurrency scenarios, consider using Redis for order number generation

---

## P3-BE-007: SalesOrder API Implementation
**Date**: 2026-01-24
**Status**: COMPLETED ✓

### Files Created
1. `backend/internal/interfaces/http/handler/sales_order.go` (743 lines)
   - HTTP handler for SalesOrder with complete swagger annotations
   - 15 endpoints: Create, GetByID, GetByOrderNumber, List, Update, Delete, AddItem, UpdateItem, RemoveItem, Confirm, Ship, Complete, Cancel, GetStatusSummary

2. `backend/internal/infrastructure/persistence/sales_order_repository.go` (420 lines)
   - GORM implementation of trade.SalesOrderRepository interface
   - Implements optimistic locking via SaveWithLock with version checking
   - Order number generation: `SO-YYYY-NNNNN` format

3. `backend/internal/interfaces/http/handler/sales_order_test.go` (616 lines)
   - 14 unit tests with MockSalesOrderRepository
   - Tests: Create, GetByID, List, Confirm, Cancel, Delete, GetStatusSummary, AddItem

### Files Modified
1. `backend/cmd/server/main.go`
   - Added tradeapp import
   - Added salesOrderRepo, salesOrderService, salesOrderHandler initialization
   - Registered 14 sales order routes under `/trade/sales-orders`

### API Endpoints Registered
```
POST   /api/v1/trade/sales-orders                    Create order
GET    /api/v1/trade/sales-orders                    List orders
GET    /api/v1/trade/sales-orders/stats/summary      Get status summary
GET    /api/v1/trade/sales-orders/number/:order_number Get by order number
GET    /api/v1/trade/sales-orders/:id                Get by ID
PUT    /api/v1/trade/sales-orders/:id                Update order
DELETE /api/v1/trade/sales-orders/:id                Delete order
POST   /api/v1/trade/sales-orders/:id/items          Add item
PUT    /api/v1/trade/sales-orders/:id/items/:item_id Update item
DELETE /api/v1/trade/sales-orders/:id/items/:item_id Remove item
POST   /api/v1/trade/sales-orders/:id/confirm        Confirm order
POST   /api/v1/trade/sales-orders/:id/ship           Ship order
POST   /api/v1/trade/sales-orders/:id/complete       Complete order
POST   /api/v1/trade/sales-orders/:id/cancel         Cancel order
```

### Test Results
```
=== RUN   TestSalesOrderHandler_Create (3 subtests) --- PASS
=== RUN   TestSalesOrderHandler_GetByID (3 subtests) --- PASS
=== RUN   TestSalesOrderHandler_List (1 subtest) --- PASS
=== RUN   TestSalesOrderHandler_Confirm (2 subtests) --- PASS
=== RUN   TestSalesOrderHandler_Cancel (2 subtests) --- PASS
=== RUN   TestSalesOrderHandler_Delete (2 subtests) --- PASS
=== RUN   TestSalesOrderHandler_GetStatusSummary (1 subtest) --- PASS
=== RUN   TestSalesOrderHandler_AddItem (1 subtest) --- PASS
PASS
ok      github.com/erp/backend/internal/interfaces/http/handler  0.018s
```

### Build Status
- `go build ./...` passes successfully
- All 14 handler tests pass

### Key Implementation Details
1. **Request/Response DTOs**: Defined CreateSalesOrderRequest, UpdateSalesOrderRequest, AddOrderItemRequest, UpdateOrderItemRequest, CancelOrderRequest with validation tags
2. **Response Conversion**: SalesOrderResponse and SalesOrderItemResponse convert uuid.UUID to string and decimal.Decimal to float64 for JSON
3. **Tenant ID Extraction**: X-Tenant-ID header required for all operations
4. **Optimistic Locking**: SaveWithLock uses version checking to prevent concurrent modification issues
5. **Order Number Generation**: Format `SO-YYYY-NNNNN` with atomic counter per tenant

### Notes for Next Developer
- **P3-BE-006** (SalesOrder Event Handling) still needs implementation for inventory integration
- Run `swag init -g cmd/server/main.go -o docs --outputTypes yaml,json` to regenerate OpenAPI spec
- Run `npm run api:generate` in frontend to regenerate TypeScript SDK

---

## 2026-01-24 - P3-FE-001: Sales Order List Page Complete

### Completed
- **P3-FE-001**: 销售订单列表页面

### What was done
1. Created comprehensive Sales Order list page at `frontend/src/pages/trade/SalesOrders.tsx`:
   - Full data table with pagination and sorting
   - Order listing showing: order number, customer, item count, amounts, status, timestamps
   - Status-based row actions (confirm, ship, complete, cancel, delete)
   - Navigation to order detail and edit pages (routes pending implementation)

2. Implemented filtering capabilities:
   - Search by order number
   - Filter by order status (draft, confirmed, shipped, completed, cancelled)
   - Filter by customer (dropdown with all customers)
   - Filter by date range (start date to end date)

3. Implemented order status actions:
   - **Confirm** - For draft orders, triggers stock lock (with confirmation dialog)
   - **Ship** - For confirmed orders, triggers stock deduction (with confirmation dialog)
   - **Complete** - For shipped orders
   - **Cancel** - For draft/confirmed orders (with confirmation dialog)
   - **Delete** - For draft orders only (with confirmation dialog)

4. Created CSS styles at `frontend/src/pages/trade/SalesOrders.css`:
   - Follows design system tokens
   - Responsive design for mobile
   - Status tag styling
   - Order number and amount emphasis

5. Regenerated OpenAPI spec and TypeScript SDK:
   - Backend: `make docs` - regenerated OpenAPI spec
   - Frontend: `npm run api:generate` - regenerated TypeScript SDK
   - All Sales Order API endpoints now available with full type safety

### Files created/modified
- `frontend/src/pages/trade/SalesOrders.tsx` (rewritten)
- `frontend/src/pages/trade/SalesOrders.css` (new)
- `backend/docs/swagger.yaml` (regenerated)
- `backend/docs/swagger.json` (regenerated)
- `frontend/src/api/sales-orders/sales-orders.ts` (auto-generated)
- `frontend/src/api/models/*.ts` (auto-generated)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings)
- `npm run build` passes

### Features Implemented
| Feature | Status |
|---------|--------|
| Order listing with pagination | ✓ |
| Sorting by columns | ✓ |
| Search by order number | ✓ |
| Status filtering | ✓ |
| Customer filtering | ✓ |
| Date range filtering | ✓ |
| Confirm order action | ✓ |
| Ship order action | ✓ |
| Complete order action | ✓ |
| Cancel order action | ✓ |
| Delete order action | ✓ |
| View order (navigation) | ✓ |
| Edit order (navigation) | ✓ |

### API Endpoints Used
- `GET /trade/sales-orders` - List orders with filtering
- `POST /trade/sales-orders/{id}/confirm` - Confirm order
- `POST /trade/sales-orders/{id}/ship` - Ship order
- `POST /trade/sales-orders/{id}/complete` - Complete order
- `POST /trade/sales-orders/{id}/cancel` - Cancel order
- `DELETE /trade/sales-orders/{id}` - Delete order
- `GET /partner/customers` - Load customer list for filter

### Notes for next developer
- **P3-FE-002** (Sales Order Creation Page): Create new sales order form with customer selection, product addition, and amount calculation
- **P3-FE-003** (Sales Order Detail Page): Show full order details with items and status history
- **P3-FE-004** (Sales Order Shipping): Already integrated in list page; may need warehouse selection modal
- Routes for `/trade/sales-orders/:id` (detail) and `/trade/sales-orders/:id/edit` (edit) need to be implemented
- Customer filter loads all customers (up to 100); consider search-on-type for large customer bases
- Date range filter uses ISO 8601 format for API compatibility
- Status actions are context-sensitive based on current order status

---

## 2026-01-24 - P3-FE-002: Sales Order Creation Page Complete

### Completed
- **P3-FE-002**: 销售开单页面 (Sales Order Creation/Edit Form)

### What was done
1. Created `SalesOrderForm` component (`frontend/src/features/trade/SalesOrderForm.tsx`)
   - Customer selection with search (remote filtering)
   - Warehouse selection (optional)
   - Dynamic order items table with add/remove rows
   - Product selection with search for each row
   - Real-time amount calculation (unit_price × quantity)
   - Subtotal, discount (percentage), and payable amount calculation
   - Remark field for order notes
   - Zod v4 schema validation (uses `issues` not `errors`)
   - Submit/Cancel actions with loading state

2. Created page wrappers:
   - `SalesOrderNew.tsx` - New order creation page
   - `SalesOrderEdit.tsx` - Edit existing draft order page
   - CSS file `SalesOrderForm.css` with design system tokens

3. Updated routes (`router/routes.tsx`):
   - Added lazy load imports for SalesOrderNew and SalesOrderEdit
   - Added routes: `/trade/sales/new` and `/trade/sales/:id/edit`

4. Fixed `SalesOrders.tsx` list page:
   - Updated navigation paths from `/trade/sales-orders/` to `/trade/sales/`
   - Changed DateRangePicker to use `DatePicker type="dateRange"` (Semi Design API)

### Files created
- `frontend/src/features/trade/SalesOrderForm.tsx` (main form component)
- `frontend/src/features/trade/SalesOrderForm.css` (styles)
- `frontend/src/pages/trade/SalesOrderNew.tsx` (new order page)
- `frontend/src/pages/trade/SalesOrderEdit.tsx` (edit order page)

### Files modified
- `frontend/src/features/trade/index.ts` - Added export
- `frontend/src/router/routes.tsx` - Added routes for new/edit pages
- `frontend/src/pages/trade/SalesOrders.tsx` - Fixed navigation paths and DatePicker

### Technical decisions
1. **Discount calculation**: API returns `discount_amount` not `discount`. Computed percentage from `discount_amount / (total_amount + discount_amount) * 100`
2. **Zod v4**: Uses `result.error.issues` instead of `result.error.errors`
3. **Edit restrictions**: Customer cannot be changed on edit (API limitation); only warehouse, discount, and remark can be updated
4. **Semi Design DatePicker**: Use `type="dateRange"` prop instead of destructured `DateRangePicker` to avoid TypeScript errors

### Feature details

| Feature | Status |
|---------|--------|
| Customer selection with search | ✓ |
| Warehouse selection | ✓ |
| Product selection per row | ✓ |
| Dynamic rows (add/remove) | ✓ |
| Unit price auto-fill from product | ✓ |
| Quantity input with validation | ✓ |
| Amount calculation (price × qty) | ✓ |
| Subtotal calculation | ✓ |
| Discount percentage input | ✓ |
| Payable amount calculation | ✓ |
| Order remark field | ✓ |
| Form validation (Zod) | ✓ |
| Create new order | ✓ |
| Edit draft order | ✓ |
| Navigate from list page | ✓ |

### API Endpoints Used
- `POST /trade/sales-orders` - Create new order
- `GET /trade/sales-orders/{id}` - Get order details (for edit)
- `PUT /trade/sales-orders/{id}` - Update order
- `GET /partner/customers` - Load customer list
- `GET /partner/warehouses` - Load warehouse list
- `GET /catalog/products` - Load product list

### Notes for next developer
- **P3-FE-003** (Sales Order Detail Page): Need to implement `/trade/sales/:id` view page
- Edit mode only available for `draft` status orders
- Products table auto-adds empty row when last row has product selected
- Customer field disabled in edit mode (API doesn't support customer change)
- Consider adding product barcode scanning support
- Consider adding quick product select from recent orders

---

## 2026-01-24 - P3-FE-003: Sales Order Detail Page Complete

### Completed
- **P3-FE-003**: 销售订单详情页面 (Sales Order Detail Page)

### What was done
1. Created `SalesOrderDetail.tsx` page component (`frontend/src/pages/trade/SalesOrderDetail.tsx`):
   - Complete order information display via Descriptions component
   - Order line items table with all fields (product code, name, unit, quantity, price, amount, remark)
   - Amount summary section (subtotal, discount, payable amount)
   - Status timeline showing order creation, confirmation, shipping, completion, or cancellation
   - Status action buttons (Confirm, Ship, Complete, Cancel) based on current order status
   - Edit button for draft orders
   - Back to list navigation

2. Created `SalesOrderDetail.css` with design system tokens:
   - Uses CSS variables from design tokens
   - Responsive design for mobile
   - Styled amount summary section
   - Timeline styling

3. Updated `router/routes.tsx`:
   - Added lazy load import for SalesOrderDetailPage
   - Added route: `/trade/sales/:id` for order detail view

### Files created
- `frontend/src/pages/trade/SalesOrderDetail.tsx` (main detail page component)
- `frontend/src/pages/trade/SalesOrderDetail.css` (styles)

### Files modified
- `frontend/src/router/routes.tsx` - Added detail page route

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings)
- `npm run build` passes

### Features Implemented
| Feature | Status |
|---------|--------|
| Order basic info display | ✓ |
| Order number, customer, status | ✓ |
| Item count, total quantity | ✓ |
| Created/updated timestamps | ✓ |
| Order remark | ✓ |
| Order items table | ✓ |
| Product code, name, unit | ✓ |
| Quantity, unit price, amount | ✓ |
| Item remarks | ✓ |
| Amount summary | ✓ |
| Subtotal, discount, payable | ✓ |
| Status timeline | ✓ |
| Created → Confirmed → Shipped → Completed | ✓ |
| Cancelled status with reason | ✓ |
| Action buttons | ✓ |
| Edit (draft only) | ✓ |
| Confirm order | ✓ |
| Ship order | ✓ |
| Complete order | ✓ |
| Cancel order | ✓ |
| Navigation back to list | ✓ |

### API Endpoints Used
- `GET /trade/sales-orders/{id}` - Get order details
- `POST /trade/sales-orders/{id}/confirm` - Confirm order
- `POST /trade/sales-orders/{id}/ship` - Ship order
- `POST /trade/sales-orders/{id}/complete` - Complete order
- `POST /trade/sales-orders/{id}/cancel` - Cancel order

### Notes for next developer
- **P3-FE-004** (Sales Order Shipping): Ship action already integrated in detail page; may need warehouse selection modal for multi-warehouse scenarios
- The timeline displays timestamps for each status change (created_at, confirmed_at, shipped_at, completed_at, cancelled_at)
- Action buttons are context-sensitive based on current order status
- Edit button navigates to `/trade/sales/:id/edit` for draft orders only
- Amount summary calculates discount percentage from discount_amount and total_amount

---

## 2026-01-24 - P3-FE-004: Sales Order Shipping Operation Complete

### Completed
- **P3-FE-004**: 销售订单发货操作 (Sales Order Shipping Operation)

### What was done
1. Created `ShipOrderModal` component (`frontend/src/pages/trade/components/ShipOrderModal.tsx`):
   - Modal dialog for shipping order confirmation
   - Displays order summary (order number, customer, item count, quantity, payable amount)
   - Warehouse selection dropdown with active warehouses only
   - Auto-selects order's warehouse, or default warehouse, or first available warehouse
   - Loading state for warehouse list fetch
   - Warning message about inventory deduction
   - Confirm/Cancel actions with loading state

2. Created `ShipOrderModal.css` with design system tokens:
   - Uses CSS variables from design tokens
   - Responsive design for mobile
   - Section styling with background colors
   - Loading and empty state styling

3. Updated `SalesOrderDetail.tsx`:
   - Replaced simple Modal.confirm with ShipOrderModal
   - Added state for modal visibility
   - Integrated handleShipConfirm callback for modal

4. Updated `SalesOrders.tsx` (list page):
   - Replaced simple Modal.confirm with ShipOrderModal
   - Added state for modal visibility and selected order
   - Integrated handleShipConfirm callback for modal

### Files created
- `frontend/src/pages/trade/components/ShipOrderModal.tsx`
- `frontend/src/pages/trade/components/ShipOrderModal.css`
- `frontend/src/pages/trade/components/index.ts`

### Files modified
- `frontend/src/pages/trade/SalesOrderDetail.tsx` (integrated ShipOrderModal)
- `frontend/src/pages/trade/SalesOrders.tsx` (integrated ShipOrderModal)

### Build Status
- `npm run type-check` passes
- `npm run lint` passes (only pre-existing warnings)
- `npm run build` passes

### Features Implemented
| Feature | Status |
|---------|--------|
| Shipping confirmation modal | ✓ |
| Order summary display | ✓ |
| Warehouse selection dropdown | ✓ |
| Active warehouses only | ✓ |
| Auto-select warehouse (order > default > first) | ✓ |
| Loading state for warehouse fetch | ✓ |
| Empty state for no warehouses | ✓ |
| Warning message | ✓ |
| Integration in detail page | ✓ |
| Integration in list page | ✓ |
| Update order status after ship | ✓ |

### API Endpoints Used
- `GET /partner/warehouses` - Fetch active warehouses for selection
- `POST /trade/sales-orders/{id}/ship` - Ship the order with selected warehouse_id

### Notes for next developer
- **P3-BE-010** (PurchaseOrder backend) is the next high-priority backend task
- **P3-FE-010** (Purchase Order List) is the next high-priority frontend task
- ShipOrderModal can be reused for other shipping scenarios
- The modal automatically fetches warehouses when opened
- Default warehouse selection priority: order's warehouse > default warehouse > first active warehouse
- The ship API accepts an optional `warehouse_id` parameter

---

## P3-BE-010: PurchaseOrder 聚合根实现 (COMPLETED)

**Date**: 2026-01-24

### Summary
Implemented the PurchaseOrder aggregate root with complete lifecycle management including order creation, confirmation, partial/full receiving, and cancellation. The implementation follows DDD patterns consistent with the existing SalesOrder aggregate.

### Files Created
- `backend/internal/domain/trade/purchase_order.go` - Main aggregate root implementation
- `backend/internal/domain/trade/purchase_order_events.go` - Domain events for purchase orders
- `backend/internal/domain/trade/purchase_order_test.go` - Comprehensive unit tests

### Files Modified
- `backend/internal/domain/trade/repository.go` - Added PurchaseOrderRepository interface

### Key Features Implemented

#### PurchaseOrder Aggregate Root
| Feature | Status |
|---------|--------|
| PurchaseOrderStatus enum | ✓ |
| State machine (DRAFT → CONFIRMED → PARTIAL_RECEIVED → COMPLETED) | ✓ |
| Optimistic locking (Version field) | ✓ |
| Multi-tenant support (TenantID) | ✓ |
| Order items management | ✓ |
| Total/payable amount calculation | ✓ |
| Discount and tax handling | ✓ |
| Receiving operation with batch tracking | ✓ |
| Partial receiving support | ✓ |
| Cancellation with reason | ✓ |
| Warehouse assignment | ✓ |

#### Domain Events
| Event | Description |
|-------|-------------|
| PurchaseOrderCreatedEvent | Raised when order is created |
| PurchaseOrderConfirmedEvent | Raised when order is confirmed |
| PurchaseOrderReceivedEvent | Raised when goods are received (partial or full) |
| PurchaseOrderCompletedEvent | Raised when order is fully received |
| PurchaseOrderCancelledEvent | Raised when order is cancelled |

#### PurchaseOrderRepository Interface
| Method | Description |
|--------|-------------|
| FindByID, FindByIDForTenant | Find order by ID |
| FindByOrderNumber | Find by order number |
| FindAllForTenant | List orders with filters |
| FindBySupplier | Find orders by supplier |
| FindByStatus | Find orders by status |
| FindByWarehouse | Find orders by warehouse |
| FindPendingReceipt | Find orders pending receipt |
| Save, SaveWithLock | Persist order |
| Delete, DeleteForTenant | Delete order |
| CountForTenant, CountByStatus, etc. | Counting methods |
| ExistsByOrderNumber | Check order number uniqueness |
| GenerateOrderNumber | Generate unique order number |

#### Key Domain Logic
- **State Transitions**: Validated transitions between states (DRAFT → CONFIRMED → PARTIAL_RECEIVED → COMPLETED)
- **Receiving Logic**: Tracks received quantities per item with batch numbers and expiry dates
- **Progress Tracking**: CalculateReceivedPercentage() for tracking fulfillment progress
- **Cancellation Rules**: Cannot cancel after goods received (PARTIAL_RECEIVED or COMPLETED)
- **Amount Calculation**: Automatic recalculation with discount/tax support

### Test Coverage
- 60+ test cases covering all aggregate functionality
- Tests for status transitions, item management, receiving, cancellation, events
- Edge case tests for validation and boundary conditions

### Build Status
- `go build ./...` passes
- `go test ./internal/domain/trade/...` passes (all tests green)

### Notes for Next Developer
- **P3-BE-011** (采购收货逻辑) depends on this implementation - the Receive() method provides the foundation
- **P3-BE-012** (PurchaseOrder Application Service) is the next logical task
- The ReceivedItemInfo struct includes batch_number and expiry_date for inventory integration
- Domain events can be used to trigger inventory updates when implementing P3-BE-011

---

## 2026-01-24 - P3-BE-012: PurchaseOrder Application Service Complete

### Completed
- **P3-BE-012**: PurchaseOrder Application Service

### What was done
1. Created Purchase Order DTOs in `internal/application/trade/dto.go`:
   - `CreatePurchaseOrderRequest` / `CreatePurchaseOrderItemInput` - Order creation
   - `UpdatePurchaseOrderRequest` / `UpdatePurchaseOrderItemRequest` - Order updates
   - `AddPurchaseOrderItemRequest` - Adding items to order
   - `ConfirmPurchaseOrderRequest` - Confirm order with optional warehouse
   - `ReceiveItemInput` / `ReceivePurchaseOrderRequest` - Receive goods
   - `CancelPurchaseOrderRequest` - Cancel with reason
   - `PurchaseOrderListFilter` - List filtering with pagination
   - `PurchaseOrderResponse` / `PurchaseOrderListItemResponse` - API responses
   - `PurchaseOrderItemResponse` - Item response with remaining quantity
   - `ReceivedItemResponse` / `ReceiveResultResponse` - Receive operation results
   - `PurchaseOrderStatusSummary` - Status counts including pending receipt
   - Converter functions: `ToPurchaseOrderResponse`, `ToPurchaseOrderListItemResponse`, etc.

2. Created PurchaseOrderService in `internal/application/trade/purchase_order_service.go`:
   - `NewPurchaseOrderService(repo)` - Constructor
   - `Create(ctx, tenantID, req)` - Create new purchase order with items
   - `GetByID(ctx, tenantID, orderID)` - Get order by ID
   - `GetByOrderNumber(ctx, tenantID, orderNumber)` - Get order by number
   - `List(ctx, tenantID, filter)` - List orders with filtering/pagination
   - `ListBySupplier(ctx, tenantID, supplierID, filter)` - Filter by supplier
   - `ListByStatus(ctx, tenantID, status, filter)` - Filter by status
   - `ListPendingReceipt(ctx, tenantID, filter)` - Orders waiting for receipt
   - `Update(ctx, tenantID, orderID, req)` - Update draft order
   - `AddItem(ctx, tenantID, orderID, req)` - Add item to draft order
   - `UpdateItem(ctx, tenantID, orderID, itemID, req)` - Update item in draft order
   - `RemoveItem(ctx, tenantID, orderID, itemID)` - Remove item from draft order
   - `Confirm(ctx, tenantID, orderID, req)` - Confirm order
   - `Receive(ctx, tenantID, orderID, req)` - Receive goods with batch/expiry tracking
   - `Cancel(ctx, tenantID, orderID, req)` - Cancel order with reason
   - `Delete(ctx, tenantID, orderID)` - Delete draft order
   - `GetStatusSummary(ctx, tenantID)` - Get order counts by status
   - `GetReceivableItems(ctx, tenantID, orderID)` - Get items that can receive more goods

3. Created comprehensive unit tests in `internal/application/trade/purchase_order_service_test.go`:
   - MockPurchaseOrderRepository with all interface methods
   - Test helpers for creating test orders
   - 28+ test cases covering all service methods
   - Tests for success paths, validation, and error handling
   - Tests for partial receiving, cost override, expiry dates

### Files created
- `backend/internal/application/trade/purchase_order_service.go`
- `backend/internal/application/trade/purchase_order_service_test.go`

### Files modified
- `backend/internal/application/trade/dto.go` (added Purchase Order DTOs)

### Build Status
- `go build ./...` passes
- `go test ./...` passes (all 28 new tests pass)

### Key Features Implemented
| Feature | Status |
|---------|--------|
| Create purchase order | ✓ |
| CRUD operations | ✓ |
| Order confirmation | ✓ |
| Partial receiving | ✓ |
| Full receiving | ✓ |
| Batch number tracking | ✓ |
| Expiry date tracking | ✓ |
| Cost override on receive | ✓ |
| Order cancellation | ✓ |
| Status summary | ✓ |
| Pending receipt filter | ✓ |
| Receive progress tracking | ✓ |
| Optimistic locking | ✓ |

### API Endpoints to be implemented (P3-BE-013)
| Method | Path | Description |
|--------|------|-------------|
| POST | /trade/purchase-orders | Create purchase order |
| GET | /trade/purchase-orders | List purchase orders |
| GET | /trade/purchase-orders/:id | Get purchase order |
| PUT | /trade/purchase-orders/:id | Update purchase order |
| DELETE | /trade/purchase-orders/:id | Delete purchase order |
| POST | /trade/purchase-orders/:id/confirm | Confirm order |
| POST | /trade/purchase-orders/:id/receive | Receive goods |
| POST | /trade/purchase-orders/:id/cancel | Cancel order |
| GET | /trade/purchase-orders/:id/receivable-items | Get receivable items |
| GET | /trade/purchase-orders/status-summary | Get status counts |
| GET | /trade/purchase-orders/pending-receipt | List pending receipt orders |

### Notes for next developer
- **P3-BE-013** (PurchaseOrder API) is the next task - add HTTP handlers using this service
- **P3-BE-011** (采购收货逻辑) - The Receive() method is ready, but inventory integration via domain events is pending
- The service follows the same patterns as SalesOrderService for consistency
- ReceiveResultResponse includes all received item info including batch numbers and expiry dates
- Domain events are raised during Receive() - subscribe to PurchaseOrderReceivedEvent for inventory updates
- PendingReceipt includes both CONFIRMED and PARTIAL_RECEIVED orders
- Use GetReceivableItems() to show remaining quantities for each item before receiving

---

## P3-BE-013: PurchaseOrder API Implementation

**Date:** 2026-01-24
**Status:** ✅ COMPLETED

### Summary
Implemented the full PurchaseOrder HTTP API handler with all CRUD operations, status transitions, item management, and receiving functionality.

### Files Created/Modified

#### Created Files:
1. **`backend/internal/interfaces/http/handler/purchase_order.go`**
   - Full HTTP handler implementation with 15+ endpoints
   - All Swagger annotations for OpenAPI generation
   - Request/Response DTO types with JSON binding validation

#### Modified Files:
1. **`backend/cmd/server/main.go`**
   - Added `purchaseOrderRepo` initialization
   - Added `purchaseOrderService` initialization
   - Added `purchaseOrderHandler` initialization
   - Registered 17 purchase order routes under `/trade/purchase-orders`

### API Endpoints Implemented

| Method | Path | Description |
|--------|------|-------------|
| POST | /trade/purchase-orders | Create purchase order |
| GET | /trade/purchase-orders | List purchase orders |
| GET | /trade/purchase-orders/:id | Get purchase order by ID |
| GET | /trade/purchase-orders/number/:order_number | Get by order number |
| GET | /trade/purchase-orders/stats/summary | Get status summary |
| GET | /trade/purchase-orders/pending-receipt | List pending receipt |
| GET | /trade/purchase-orders/:id/receivable-items | Get receivable items |
| PUT | /trade/purchase-orders/:id | Update purchase order |
| DELETE | /trade/purchase-orders/:id | Delete purchase order |
| POST | /trade/purchase-orders/:id/items | Add item |
| PUT | /trade/purchase-orders/:id/items/:item_id | Update item |
| DELETE | /trade/purchase-orders/:id/items/:item_id | Remove item |
| POST | /trade/purchase-orders/:id/confirm | Confirm order |
| POST | /trade/purchase-orders/:id/receive | Receive goods |
| POST | /trade/purchase-orders/:id/cancel | Cancel order |

### Features Implemented
| Feature | Status |
|---------|--------|
| Create purchase order | ✓ |
| List with pagination | ✓ |
| Filter by status/supplier/warehouse | ✓ |
| Search by order number/supplier name | ✓ |
| Update draft orders | ✓ |
| Add/Update/Remove items | ✓ |
| Confirm order | ✓ |
| Partial receiving with batch info | ✓ |
| Cancel order with reason | ✓ |
| Status summary by count | ✓ |
| Pending receipt listing | ✓ |
| Receivable items query | ✓ |
| OpenAPI/Swagger annotations | ✓ |

### Handler Methods
- `Create` - Create new purchase order with items
- `GetByID` - Get order by UUID
- `GetByOrderNumber` - Get order by order number string
- `List` - List orders with filtering and pagination
- `ListPendingReceipt` - List orders awaiting receipt
- `Update` - Update draft order (warehouse, discount, remark)
- `Delete` - Delete draft order
- `AddItem` - Add item to draft order
- `UpdateItem` - Update item quantity/cost/remark
- `RemoveItem` - Remove item from draft order
- `Confirm` - Confirm order (DRAFT → CONFIRMED)
- `Receive` - Receive goods with batch info
- `Cancel` - Cancel order with reason
- `GetStatusSummary` - Get counts by status
- `GetReceivableItems` - Get items that can still receive goods

### Request/Response DTOs
- `CreatePurchaseOrderRequest` - Order creation with items
- `UpdatePurchaseOrderRequest` - Update warehouse/discount/remark
- `AddPurchaseOrderItemRequest` - Add item details
- `UpdatePurchaseOrderItemRequest` - Update quantity/cost/remark
- `ConfirmPurchaseOrderRequest` - Confirm with optional warehouse
- `ReceivePurchaseOrderRequest` - Receive items with batch info
- `CancelPurchaseOrderRequest` - Cancel with reason
- `PurchaseOrderResponse` - Full order response with items
- `PurchaseOrderListResponse` - Paginated list response
- `PurchaseOrderStatusSummaryResponse` - Status counts
- `ReceiveResultResponse` - Receive operation result

### Tests & Build
- Build: ✅ PASSED
- All tests: ✅ PASSED
- OpenAPI generation: ✅ COMPLETED

### Notes for Next Developer
- **P3-FE-010** (采购订单列表页面) is a good next frontend task
- **P3-FE-011** (采购开单页面) for order creation UI
- **P3-FE-012** (采购收货页面) for receiving UI
- **P3-BE-011** (采购收货逻辑 - inventory integration) still pending
- The handler follows SalesOrderHandler patterns for consistency
- All endpoints use tenant_id from context (currently hardcoded default)
- Decimal amounts use string format in JSON for precision

---

## 2026-01-24 - P3-FE-010: Purchase Order List Page Implementation

**Date:** 2026-01-24
**Status:** ✅ COMPLETED

### Summary
Implemented the Purchase Order List page with full CRUD operations, filtering, pagination, and status-based actions.

### What was done
1. Created `PurchaseOrders.tsx` page component at `frontend/src/pages/trade/`:
   - Purchase order list with DataTable component
   - Search by order number
   - Filter by status (draft, confirmed, partial_received, completed, cancelled)
   - Filter by supplier (loaded from API)
   - Filter by date range
   - Sortable columns (order number, total amount, payable amount, created_at)
   - Receive progress bar for orders in receiving status
   - Row actions: View, Edit, Confirm, Receive, Cancel, Delete (context-aware based on status)

2. Created `PurchaseOrders.css` styling:
   - Following design system tokens (spacing, colors, typography)
   - Responsive design for mobile/tablet/desktop
   - Payable amount highlighting (warning color)
   - Progress bar styling in table cells

3. Regenerated TypeScript SDK from backend OpenAPI spec:
   - `npm run api:generate` to create typed API client
   - Purchase order API methods: list, get, create, update, delete, confirm, receive, cancel
   - Full type definitions for request/response DTOs

4. Updated routes at `frontend/src/router/routes.tsx`:
   - Changed path from `/trade/purchases` to `/trade/purchase` for consistency
   - Added placeholder routes for detail pages (to be implemented in P3-FE-011/012):
     - `/trade/purchase/new`
     - `/trade/purchase/:id`
     - `/trade/purchase/:id/edit`
     - `/trade/purchase/:id/receive`

### Files created
- `frontend/src/pages/trade/PurchaseOrders.tsx` (new - full implementation)
- `frontend/src/pages/trade/PurchaseOrders.css` (new - styling)

### Files modified
- `frontend/src/router/routes.tsx` (updated route paths and added detail routes)
- `frontend/src/api/purchase-orders/purchase-orders.ts` (auto-generated)
- `frontend/src/api/models/` (auto-generated types)
- `.claude/ralph/plans/prd.json` (marked P3-FE-010 as completed)

### Build Status
- `npm run type-check` ✅ PASSED
- `npm run lint` ✅ PASSED (only pre-existing warnings)
- `npm run build` ✅ PASSED
- `npm run test:run` ✅ PASSED (49 tests)

### Features Implemented
| Feature | Status |
|---------|--------|
| Order list with pagination | ✓ |
| Search by order number | ✓ |
| Status filter (all 5 statuses) | ✓ |
| Supplier filter | ✓ |
| Date range filter | ✓ |
| Column sorting | ✓ |
| Receive progress display | ✓ |
| Confirm order action | ✓ |
| Cancel order action | ✓ |
| Delete draft order | ✓ |
| Navigate to receive page | ✓ (route placeholder) |
| Navigate to detail page | ✓ (route placeholder) |
| Navigate to edit page | ✓ (route placeholder) |

### Key Components Used
- `DataTable` - Common table component with pagination and sorting
- `TableToolbar` - Search, filters, and actions bar
- `useTableState` - Hook for managing pagination/sort/filter state
- `Container` - Responsive layout component
- Semi Design: Card, Tag, Select, DatePicker, Modal, Toast, Progress, Spin

### Status Flow Support
- Draft → Confirm → Confirmed
- Confirmed → Receive → Partial Received / Completed
- Draft/Confirmed → Cancel → Cancelled
- Draft → Delete (hard delete)

### Notes for next developer
- **P3-FE-011** (采购开单页面) is the next high priority - create purchase order form
- **P3-FE-012** (采购收货页面) - receiving workflow with batch/expiry tracking
- Detail page routes are placeholders pointing to list page until implemented
- The `receive_progress` field shows percentage of items received (0-1 scale, displayed as 0-100%)
- Supplier filter loads up to 100 suppliers - may need pagination for large datasets
- Status colors match sales order patterns for UI consistency



---

## 2026-01-24 - P3-FE-011: Purchase Order Creation Page Implementation

**Date:** 2026-01-24
**Status:** ✅ COMPLETED

### Summary
Implemented the Purchase Order Creation page (采购开单页面) with full CRUD operations, supplier selection, product item management, discount support, and form validation.

### What was done
1. Created `PurchaseOrderForm.tsx` component at `frontend/src/features/trade/`:
   - Supplier search and selection with remote filtering
   - Warehouse selection for receiving destination
   - Dynamic product item rows with add/remove functionality
   - Real-time amount calculation (unit_cost × quantity)
   - Discount percentage support with automatic total calculation
   - Form validation with Zod schema
   - Support for both create and edit modes
   - Uses `purchase_price` for unit cost when available

2. Created `PurchaseOrderForm.css` styling:
   - Following design system tokens (spacing, colors, typography)
   - Responsive design for mobile/tablet/desktop
   - Consistent styling with SalesOrderForm

3. Created `PurchaseOrderNew.tsx` page at `frontend/src/pages/trade/`:
   - Renders PurchaseOrderForm in create mode
   - Follows same pattern as SalesOrderNew

4. Updated routes at `frontend/src/router/routes.tsx`:
   - Changed purchase/new route to use PurchaseOrderNewPage
   - Added lazy loading for the new page component

5. Updated exports at `frontend/src/features/trade/index.ts`:
   - Added PurchaseOrderForm export

### Files created
- `frontend/src/features/trade/PurchaseOrderForm.tsx` (new - full implementation)
- `frontend/src/features/trade/PurchaseOrderForm.css` (new - styling)
- `frontend/src/pages/trade/PurchaseOrderNew.tsx` (new - page component)

### Files modified
- `frontend/src/features/trade/index.ts` (added PurchaseOrderForm export)
- `frontend/src/router/routes.tsx` (updated purchase routes)
- `.claude/ralph/plans/prd.json` (marked P3-FE-011 as completed)

### Build Status
- `npm run type-check` ✅ PASSED
- `npm run lint` ✅ PASSED (only pre-existing warnings)
- `npm run build` ✅ PASSED

### Features Implemented
| Feature | Status |
|---------|--------|
| Supplier search and selection | ✓ |
| Warehouse selection (optional) | ✓ |
| Product search and selection | ✓ |
| Dynamic item rows (add/remove) | ✓ |
| Unit cost editing | ✓ |
| Quantity editing | ✓ |
| Real-time amount calculation | ✓ |
| Discount percentage support | ✓ |
| Subtotal/discount/total display | ✓ |
| Form validation (Zod) | ✓ |
| Order remark | ✓ |
| Create order API call | ✓ |
| Edit mode support | ✓ |

### Key Differences from SalesOrderForm
- Uses `supplier_id` and `supplier_name` instead of `customer_id` and `customer_name`
- Uses `unit_cost` instead of `unit_price` (purchase cost vs selling price)
- Defaults to `purchase_price` when selecting products
- Warehouse label says "收货仓库" (receiving warehouse) instead of "发货仓库" (shipping warehouse)
- Total label says "应付金额" (payable amount) - same as sales (amount to pay supplier)

### API Integration
- Uses `getPurchaseOrders().postTradePurchaseOrders()` for order creation
- Uses `getPurchaseOrders().putTradePurchaseOrdersId()` for order update
- Uses `getSuppliers().getPartnerSuppliers()` for supplier dropdown
- Uses `getProducts().getCatalogProducts()` for product dropdown
- Uses `getWarehouses().getPartnerWarehouses()` for warehouse dropdown

### Notes for next developer
- **P3-FE-012** (采购收货页面) is the next high priority - receiving workflow with batch/expiry tracking
- Edit mode disables supplier selection (cannot change supplier after creation)
- The `ordered_quantity` field from API maps to `quantity` in the form
- Empty items (without product_id) are filtered out before API submission
- Navigation goes back to `/trade/purchase` after successful submit
- Default warehouse is auto-selected if available


---

## 2026-01-24 - P3-BE-011: Purchase Order Receiving Logic (Inventory Integration) Complete

**Date:** 2026-01-24
**Status:** ✅ COMPLETED

### Summary
Implemented the purchase order receiving logic that integrates the trade context with the inventory context via domain events. When goods are received on a purchase order, the system automatically increases inventory stock with batch tracking, expiry dates, and moving weighted average cost calculation.

### What was done
1. Created `PurchaseOrderReceivedHandler` at `internal/application/trade/purchase_order_received_handler.go`:
   - Subscribes to `PurchaseOrderReceivedEvent` from the trade domain
   - For each received item, calls `InventoryService.IncreaseStock()` to update inventory
   - Passes batch number and expiry date for batch tracking
   - Uses `PURCHASE_ORDER` source type and order ID for audit trail
   - Implements partial failure handling - continues processing remaining items if one fails
   - Comprehensive logging for debugging and monitoring

2. Updated `PurchaseOrderService` at `internal/application/trade/purchase_order_service.go`:
   - Added `eventPublisher` field of type `shared.EventPublisher`
   - Added `SetEventPublisher()` method for dependency injection
   - Modified `Receive()` method to publish domain events after successful save
   - Events are cleared from aggregate after publishing

3. Updated `main.go` to wire up the event system:
   - Creates `InMemoryEventBus` instance
   - Creates and registers `PurchaseOrderReceivedHandler`
   - Injects event publisher into `PurchaseOrderService`
   - Starts event bus on server startup
   - Stops event bus gracefully on shutdown

4. Created comprehensive unit tests at `internal/application/trade/purchase_order_received_handler_test.go`:
   - `TestPurchaseOrderReceivedHandler_EventTypes` - verifies event subscription
   - `TestPurchaseOrderReceivedHandler_Handle_Success` - single item success case
   - `TestPurchaseOrderReceivedHandler_Handle_MissingWarehouse` - error on missing warehouse
   - `TestPurchaseOrderReceivedHandler_Handle_WrongEventType` - error on wrong event type
   - `TestPurchaseOrderReceivedHandler_Handle_MultipleItems` - multiple items processing
   - `TestPurchaseOrderReceivedHandler_Handle_PartialFailure` - partial failure handling
   - `TestNewPurchaseOrderReceivedHandler` - constructor test

### Files created
- `backend/internal/application/trade/purchase_order_received_handler.go` (new)
- `backend/internal/application/trade/purchase_order_received_handler_test.go` (new)

### Files modified
- `backend/internal/application/trade/purchase_order_service.go` (added event publishing)
- `backend/cmd/server/main.go` (added event bus and handler registration)
- `.claude/ralph/plans/prd.json` (marked P3-BE-011 as completed)

### Build Status
- `go build ./...` ✅ PASSED
- `go test ./...` ✅ PASSED (all 7 new handler tests pass)

### Event Flow
```
1. HTTP POST /trade/purchase-orders/{id}/receive
   ↓
2. PurchaseOrderHandler.Receive()
   ↓
3. PurchaseOrderService.Receive()
   ↓
4. PurchaseOrder.Receive() [Domain]
   - Validates order status (CONFIRMED or PARTIAL_RECEIVED)
   - Updates ReceivedQuantity for each item
   - Transitions status to COMPLETED if all received
   - Raises PurchaseOrderReceivedEvent
   ↓
5. PurchaseOrderRepository.SaveWithLock()
   ↓
6. EventBus.Publish(PurchaseOrderReceivedEvent)
   ↓
7. PurchaseOrderReceivedHandler.Handle()
   - For each received item:
     → InventoryService.IncreaseStock()
       - Gets/creates InventoryItem (warehouse+product)
       - Recalculates moving weighted average cost
       - Creates StockBatch if batch number provided
       - Creates InventoryTransaction audit record
```

### Inventory Integration Details
- **Source Type:** `PURCHASE_ORDER`
- **Source ID:** Purchase Order UUID
- **Reference:** `PO:<order_number>` (e.g., `PO:PO-2024-00001`)
- **Reason:** `Purchase order receiving`
- **Batch Tracking:** Passes batch number and expiry date if provided
- **Cost Calculation:** Moving weighted average recalculated on stock increase

### Key Design Decisions
1. **Event-Driven Architecture:** Uses in-memory event bus for synchronous cross-context communication
2. **Partial Failure Tolerance:** Continues processing remaining items if one fails
3. **Error Logging:** Errors are logged but don't rollback the order save (eventual consistency)
4. **Dependency Injection:** Event publisher is injected into service, not constructor dependency
5. **No Rollback:** If inventory update fails, the receive operation is still recorded (can be retried)

### Notes for next developer
- **P3-FE-012** (采购收货页面) is now unblocked - backend supports full receiving workflow
- Event handler is registered on server startup - no database configuration needed
- For production, consider implementing outbox pattern for reliable event delivery
- The `WarehouseID` is required for receiving - validation happens in handler
- Use `LOG_LEVEL=debug` to see detailed inventory increase logs
- If receiving fails for some items, check server logs for specific product failures


---

## 2026-01-24 - P3-FE-012: Purchase Order Receiving Page Implementation

**Date:** 2026-01-24
**Status:** ✅ COMPLETED

### Summary
Implemented the Purchase Order Receiving page (采购收货页面) with full support for partial receiving, batch tracking, expiry date management, and warehouse selection. This completes the purchase order workflow by allowing users to receive goods against confirmed purchase orders.

### What was done
1. Created `PurchaseOrderReceive.tsx` page at `frontend/src/pages/trade/`:
   - Order summary display with key information (order number, supplier, status, amounts)
   - Warehouse selection for receiving destination (defaults to order's warehouse or default warehouse)
   - Receivable items table showing:
     - Product details (code, name, unit)
     - Ordered quantity, received quantity, remaining quantity
     - Unit cost for each item
   - Interactive form fields for each item:
     - Receive quantity input (defaults to remaining, max = remaining)
     - Batch number input (optional)
     - Expiry date picker (optional)
   - Quick actions:
     - "全部收货" (Receive All) - sets all quantities to remaining
     - "清空数量" (Clear All) - resets all quantities to 0
   - Real-time receiving summary (items count, total quantity, total amount)
   - Form validation before submission
   - Support for partial receiving (allows receiving less than ordered)

2. Created `PurchaseOrderReceive.css` styling:
   - Following design system tokens (spacing, colors, typography)
   - Responsive design for mobile/tablet/desktop
   - Dark mode support

3. Updated routes at `frontend/src/router/routes.tsx`:
   - Added lazy-loaded `PurchaseOrderReceivePage` component
   - Updated `/trade/purchase/:id/receive` route to use the new page

### Files created
- `frontend/src/pages/trade/PurchaseOrderReceive.tsx` (new - 470+ lines)
- `frontend/src/pages/trade/PurchaseOrderReceive.css` (new - styling)

### Files modified
- `frontend/src/router/routes.tsx` (added PurchaseOrderReceivePage import and route)
- `.claude/ralph/plans/prd.json` (marked P3-FE-012 as completed)

### Build Status
- `npm run type-check` ✅ PASSED
- `npm run lint` ✅ PASSED (only pre-existing warnings)
- `npm run build` ✅ PASSED

### Features Implemented
| Feature | Status |
|---------|--------|
| Order summary display | ✓ |
| Warehouse selection | ✓ |
| Receivable items table | ✓ |
| Receive quantity input | ✓ |
| Batch number tracking | ✓ |
| Expiry date input | ✓ |
| Receive all / Clear all actions | ✓ |
| Receiving summary stats | ✓ |
| Partial receiving support | ✓ |
| Form validation | ✓ |
| Status-based access control | ✓ |
| Responsive design | ✓ |

### API Integration
- Uses `getTradePurchaseOrdersId()` for fetching order details
- Uses `getTradePurchaseOrdersIdReceivableItems()` for fetching items with remaining quantities
- Uses `postTradePurchaseOrdersIdReceive()` for submitting receive operation
- Uses `getPartnerWarehouses()` for warehouse dropdown

### Key Design Decisions
1. **Default to receive all**: When loading, all items default to receiving their full remaining quantity
2. **Batch tracking optional**: Batch number and expiry date are optional fields for flexibility
3. **Status validation**: Page only accessible for orders in CONFIRMED or PARTIAL_RECEIVED status
4. **Warehouse required**: Receiving requires warehouse selection for inventory placement
5. **Client-side validation**: Validates quantities don't exceed remaining before API call

### User Flow
1. Navigate from Purchase Orders list → Click "收货" action on a confirmed order
2. Review order summary information
3. Select receiving warehouse (defaults to order's warehouse or default warehouse)
4. Enter receiving quantities (default = remaining), optionally add batch/expiry info
5. Click "确认收货" to submit
6. Backend processes receiving → Updates inventory → Redirects to list

### Notes for next developer
- **P3-INT-002** (采购订单前后端联调) can now be tested - full workflow is complete
- The receive page validates order status on load - returns helpful error for invalid states
- Batch number format is free-form text (no validation)
- Expiry date uses ISO 8601 format for API submission
- Navigation returns to `/trade/purchase` after successful receive
- Backend event (P3-BE-011) handles inventory integration automatically

---

## 2026-01-24 - P4-BE-001: AccountReceivable Aggregate Implementation Complete

### Completed
- **P4-BE-001**: AccountReceivable 聚合实现

### What was done
1. Created AccountReceivable aggregate root at `internal/domain/finance/account_receivable.go`:
   - `ReceivableStatus` enum with state machine (PENDING → PARTIAL → PAID / REVERSED / CANCELLED)
   - `SourceType` enum (SALES_ORDER, MANUAL, ADJUSTMENT)
   - `PaymentRecord` entity for tracking individual payments
   - `AccountReceivable` aggregate with full domain logic

2. Key domain methods implemented:
   - `NewAccountReceivable()` factory with validation (min amount, required fields)
   - `ApplyPayment()` with partial payment support and automatic status transitions
   - `Reverse()` for reversing receivables with reason and refund to customer balance
   - `Cancel()` for cancelling pending receivables with validation
   - `SetDueDate()` with validation (must be future date)
   - `IsOverdue()`, `DaysOverdue()`, `PaidPercentage()` helper methods

3. Created domain events at `internal/domain/finance/account_receivable_events.go`:
   - `AccountReceivableCreatedEvent` - raised on creation
   - `AccountReceivablePaidEvent` - raised when fully paid
   - `AccountReceivablePartiallyPaidEvent` - raised on partial payment
   - `AccountReceivableReversedEvent` - raised on reversal
   - `AccountReceivableCancelledEvent` - raised on cancellation

4. Defined repository interface at `internal/domain/finance/repository.go`:
   - `AccountReceivableFilter` with comprehensive filter options (customer, status, source, dates, amounts, overdue)
   - `AccountReceivableRepository` interface with:
     - CRUD operations (FindByID, Save, Delete)
     - Query methods (FindByCustomer, FindByStatus, FindBySource, FindOutstanding, FindOverdue)
     - Count methods (CountForTenant, CountByStatus, CountByCustomer, CountOverdue)
     - Sum calculations (SumOutstandingByCustomer, SumOutstandingForTenant, SumOverdueForTenant)
     - Utility methods (ExistsByReceivableNumber, ExistsBySource, GenerateReceivableNumber)

5. Created database migration at `migrations/000010_create_account_receivables.up.sql`:
   - `account_receivables` table with proper constraints and indexes
   - `receivable_payment_records` child table for payment tracking
   - Indexes for common query patterns (customer, status, due_date, source)
   - Foreign key to customers table
   - Trigger for updated_at timestamp

6. Created down migration at `migrations/000010_create_account_receivables.down.sql`:
   - Proper rollback order (child table first, then triggers, then main table)

7. Comprehensive unit tests at `internal/domain/finance/account_receivable_test.go`:
   - 59 test cases covering all functionality
   - Status enum tests (String, IsValid, IsTerminal, state transitions)
   - Creation validation tests (valid data, validation errors)
   - ApplyPayment tests (full, partial, overpayment prevention)
   - Reverse tests (validation, status transitions, event generation)
   - Cancel tests (validation, status checks)
   - Helper method tests (IsOverdue, DaysOverdue, PaidPercentage)

### Files created/modified
- `backend/internal/domain/finance/account_receivable.go` (NEW)
- `backend/internal/domain/finance/account_receivable_events.go` (NEW)
- `backend/internal/domain/finance/repository.go` (NEW)
- `backend/migrations/000010_create_account_receivables.up.sql` (NEW)
- `backend/migrations/000010_create_account_receivables.down.sql` (NEW)
- `backend/internal/domain/finance/account_receivable_test.go` (NEW)

### Build Status
- `go build ./...` ✅ PASSED
- `go test ./internal/domain/finance/...` ✅ PASSED (59 tests)

### Design Decisions
1. **State machine pattern**: ReceivableStatus uses strict state transitions validated by CanTransitionTo()
2. **Domain events**: All significant state changes emit events for integration with other bounded contexts
3. **Multi-tenant**: Inherits from TenantAggregateRoot for tenant isolation
4. **Optimistic locking**: Uses version field for concurrent update protection
5. **Decimal precision**: Uses shopspring/decimal for monetary amounts
6. **Payment tracking**: Each payment is recorded as PaymentRecord with reference and notes

### Notes for next developer
- **P4-BE-002** (AccountPayable 聚合实现) follows similar pattern - can reuse structure
- **P4-BE-003** (应收应付自动生成) will subscribe to SalesOrder events to create receivables
- Repository implementation (GORM) needed next
- Application service will coordinate with Customer balance for balance payments
- Finance API (P4-BE-010) will expose these domain operations


---

## 2026-01-24 - P4-BE-002: AccountPayable Aggregate Implementation Complete

### Completed
- **P4-BE-002**: AccountPayable 聚合实现

### What was done
1. Created AccountPayable aggregate root at `internal/domain/finance/account_payable.go`:
   - `PayableStatus` enum with state machine (PENDING → PARTIAL → PAID / REVERSED / CANCELLED)
   - `PayableSourceType` enum (PURCHASE_ORDER, PURCHASE_RETURN, MANUAL)
   - `PayablePaymentRecord` entity for tracking individual payments
   - `AccountPayable` aggregate with full domain logic

2. Key domain methods implemented:
   - `NewAccountPayable()` factory with validation (min amount, required fields)
   - `ApplyPayment()` with partial payment support and automatic status transitions
   - `Reverse()` for reversing payables with reason tracking
   - `Cancel()` for cancelling pending payables with validation
   - `SetDueDate()` with validation (rejects terminal state updates)
   - `IsOverdue()`, `DaysOverdue()`, `PaidPercentage()` helper methods

3. Created domain events at `internal/domain/finance/account_payable_events.go`:
   - `AccountPayableCreatedEvent` - raised on creation
   - `AccountPayablePaidEvent` - raised when fully paid
   - `AccountPayablePartiallyPaidEvent` - raised on partial payment
   - `AccountPayableReversedEvent` - raised on reversal
   - `AccountPayableCancelledEvent` - raised on cancellation

4. Extended repository interface at `internal/domain/finance/repository.go`:
   - `AccountPayableFilter` with comprehensive filter options (supplier, status, source, dates, amounts, overdue)
   - `AccountPayableRepository` interface with:
     - CRUD operations (FindByID, Save, Delete)
     - Query methods (FindBySupplier, FindByStatus, FindBySource, FindOutstanding, FindOverdue)
     - Count methods (CountForTenant, CountByStatus, CountBySupplier, CountOverdue)
     - Sum calculations (SumOutstandingBySupplier, SumOutstandingForTenant, SumOverdueForTenant)
     - Utility methods (ExistsByPayableNumber, ExistsBySource, GeneratePayableNumber)

5. Created database migration at `migrations/000011_create_account_payables.up.sql`:
   - `account_payables` table with proper constraints and indexes
   - `payable_payment_records` child table for payment tracking
   - Indexes for common query patterns (supplier, status, due_date, source)
   - Foreign key to suppliers table
   - Trigger for updated_at timestamp

6. Created down migration at `migrations/000011_create_account_payables.down.sql`:
   - Proper rollback order (child table first, then triggers, then main table)

7. Comprehensive unit tests at `internal/domain/finance/account_payable_test.go`:
   - 59 test cases covering all functionality
   - Status enum tests (String, IsValid, IsTerminal, state transitions)
   - Creation validation tests (valid data, validation errors)
   - ApplyPayment tests (full, partial, overpayment prevention)
   - Reverse tests (validation, status transitions, event generation)
   - Cancel tests (validation, status checks)
   - Helper method tests (IsOverdue, DaysOverdue, PaidPercentage)

### Files created/modified
- `backend/internal/domain/finance/account_payable.go` (NEW)
- `backend/internal/domain/finance/account_payable_events.go` (NEW)
- `backend/internal/domain/finance/repository.go` (UPDATED - added AccountPayableRepository)
- `backend/migrations/000011_create_account_payables.up.sql` (NEW)
- `backend/migrations/000011_create_account_payables.down.sql` (NEW)
- `backend/internal/domain/finance/account_payable_test.go` (NEW)

### Build Status
- `go build ./...` ✅ PASSED
- `go test ./internal/domain/finance/...` ✅ PASSED (59 tests for AccountPayable + existing tests)

### Design Decisions
1. **State machine pattern**: PayableStatus uses strict state transitions validated by CanApplyPayment()
2. **Domain events**: All significant state changes emit events for integration with other bounded contexts
3. **Multi-tenant**: Inherits from TenantAggregateRoot for tenant isolation
4. **Optimistic locking**: Uses version field for concurrent update protection
5. **Decimal precision**: Uses shopspring/decimal for monetary amounts
6. **Payment tracking**: Each payment is recorded as PayablePaymentRecord with reference and notes
7. **Symmetric with AccountReceivable**: Same patterns/structure for consistency

### Notes for next developer
- **P4-BE-003** (应收应付自动生成) will subscribe to PurchaseOrder events to create payables
- Repository implementation (GORM) needed next
- Application service will coordinate with payment vouchers for actual payments
- Finance API (P4-BE-010) will expose these domain operations
- The AccountPayable aggregate mirrors AccountReceivable for consistency


---

## 2026-01-24 - P4-BE-003: Auto-Generate Receivables/Payables (Event Processing) Complete

### Completed
- **P4-BE-003**: 应收应付自动生成 (事件处理)

### What was done
1. Created finance application layer at `internal/application/finance/`:
   - `sales_order_shipped_handler.go` - Handles SalesOrderShippedEvent to create AccountReceivable
   - `purchase_order_received_handler.go` - Handles PurchaseOrderReceivedEvent to create AccountPayable

2. SalesOrderShippedHandler implementation:
   - Subscribes to `SalesOrderShipped` events
   - Creates AccountReceivable when sales orders are shipped
   - **Idempotency check**: Uses ExistsBySource() to prevent duplicate receivables
   - Skips zero-amount orders (fully prepaid)
   - Auto-generates receivable number
   - Sets 30-day default due date
   - Comprehensive logging for debugging

3. PurchaseOrderReceivedHandler implementation:
   - Subscribes to `PurchaseOrderReceived` events
   - Creates AccountPayable when purchase orders are fully received
   - **Idempotency check**: Uses FindBySource() to prevent duplicate payables
   - Only creates payable when `IsFullyReceived = true` (prevents multiple payables for partial receives)
   - Skips zero-amount receives
   - Auto-generates payable number
   - Sets 30-day default due date
   - Comprehensive logging for debugging

4. Comprehensive unit tests (20 tests, all passing):
   - `sales_order_shipped_handler_test.go`: 10 tests
     - EventTypes() returns correct event type
     - Success case with correct receivable creation
     - Wrong event type handling
     - Idempotency when receivable exists
     - Skip zero amount (prepaid) orders
     - Error handling for exists check, number generation, and save operations
     - Validation of created receivable fields
   - `purchase_order_received_handler_test.go`: 10 tests
     - EventTypes() returns correct event type
     - Success case with correct payable creation
     - Wrong event type handling
     - Skip partial receives (only create on full receive)
     - Idempotency when payable exists
     - Skip zero amount receives
     - Error handling for source check, number generation, and save operations
     - Validation of created payable fields
     - isNotFoundError helper function tests

### Files created/modified
- `backend/internal/application/finance/sales_order_shipped_handler.go` (NEW)
- `backend/internal/application/finance/sales_order_shipped_handler_test.go` (NEW)
- `backend/internal/application/finance/purchase_order_received_handler.go` (NEW)
- `backend/internal/application/finance/purchase_order_received_handler_test.go` (NEW)

### Build Status
- `go build ./...` ✅ PASSED
- `go test ./internal/application/finance/...` ✅ PASSED (20 tests)

### Design Decisions
1. **Idempotency**: Both handlers check for existing receivables/payables before creation to ensure safe event re-processing
2. **Event-driven**: Handlers follow existing patterns from trade module (SalesOrderShippedHandler, PurchaseOrderReceivedHandler in trade)
3. **Full receive only for payables**: AccountPayable only created when PO is fully received, preventing multiple payables for partial shipments
4. **30-day due date**: Default payment terms of 30 days (configurable in future)
5. **Skip prepaid orders**: No receivable created for fully prepaid sales orders (PayableAmount = 0)
6. **Logging**: Comprehensive INFO/WARN/ERROR logging for troubleshooting event processing

### Event Flow
```
SalesOrder Shipped Event → SalesOrderShippedHandler (finance) → AccountReceivable
PurchaseOrder Received Event (fully received) → PurchaseOrderReceivedHandler (finance) → AccountPayable
```

### Integration Notes
- Handlers require `AccountReceivableRepository` and `AccountPayableRepository` implementations
- Register handlers with EventBus in main.go (pending repository implementation)
- Handlers follow same pattern as existing trade event handlers

### Notes for next developer
- **P4-BE-005** (ReceiptVoucher 收款单实现) is next high-priority task for finance module
- GORM repository implementations needed before handlers can be registered in main.go
- Finance API (P4-BE-010) will expose receivables/payables for frontend
- Red-ink/reversal logic (P4-BE-004) will subscribe to return events
- The handlers are ready but need repository implementations to be wired into the application



---

## 2026-01-24 - P4-BE-005: ReceiptVoucher (收款单) Implementation Complete

### Completed
- **P4-BE-005**: ReceiptVoucher 收款单实现

### What was done
1. Created ReceiptVoucher aggregate root at `internal/domain/finance/receipt_voucher.go`:
   - `VoucherStatus` enum with state machine (DRAFT → CONFIRMED → ALLOCATED / CANCELLED)
   - `PaymentMethod` enum (CASH, BANK_TRANSFER, WECHAT, ALIPAY, CHECK, BALANCE, OTHER)
   - `ReceivableAllocation` entity for tracking payment allocations to receivables
   - `ReceiptVoucher` aggregate with full domain logic

2. Key domain methods implemented:
   - `NewReceiptVoucher()` factory with validation (positive amount, valid payment method, required fields)
   - `Confirm()` with user tracking - transitions from DRAFT to CONFIRMED
   - `AllocateToReceivable()` with partial allocation support and automatic status transitions
   - `Cancel()` for cancelling vouchers without allocations
   - `SetPaymentReference()`, `SetRemark()` for updating voucher details
   - Helper methods: `IsFullyAllocated()`, `AllocationCount()`, `AllocatedPercentage()`, etc.

3. Created domain events at `internal/domain/finance/receipt_voucher_events.go`:
   - `ReceiptVoucherCreatedEvent` - raised on creation
   - `ReceiptVoucherConfirmedEvent` - raised when confirmed
   - `ReceiptVoucherAllocatedEvent` - raised when allocated to a receivable
   - `ReceiptVoucherCancelledEvent` - raised on cancellation

4. Extended repository interface at `internal/domain/finance/repository.go`:
   - `ReceiptVoucherFilter` with comprehensive filter options (customer, status, payment method, dates, amounts)
   - `ReceiptVoucherRepository` interface with:
     - CRUD operations (FindByID, Save, Delete)
     - Query methods (FindByCustomer, FindByStatus, FindWithUnallocatedAmount)
     - Count methods (CountForTenant, CountByStatus, CountByCustomer)
     - Sum calculations (SumByCustomer, SumForTenant, SumUnallocatedByCustomer)
     - Utility methods (ExistsByVoucherNumber, GenerateVoucherNumber)

5. Created database migration at `migrations/000012_create_receipt_vouchers.up.sql`:
   - `receipt_vouchers` table with proper constraints and indexes
   - `receivable_allocations` child table for allocation tracking
   - Check constraints for amount validation and status values
   - Foreign key to account_receivables table
   - Trigger for updated_at timestamp

6. Created down migration at `migrations/000012_create_receipt_vouchers.down.sql`:
   - Proper rollback order (child table first, then triggers, then main table)

7. Comprehensive unit tests at `internal/domain/finance/receipt_voucher_test.go`:
   - 59+ test cases covering all functionality
   - VoucherStatus enum tests (IsValid, IsTerminal, CanAllocate, CanConfirm, CanCancel)
   - PaymentMethod enum tests (IsValid, String)
   - Creation validation tests (valid data, validation errors)
   - Confirm tests (success, state validation, user validation)
   - AllocateToReceivable tests (full, partial, multiple allocations, validation)
   - Cancel tests (validation, status checks, allocation checks)
   - Helper method tests (amounts, percentages, status checks)

### Files created/modified
- `backend/internal/domain/finance/receipt_voucher.go` (NEW)
- `backend/internal/domain/finance/receipt_voucher_events.go` (NEW)
- `backend/internal/domain/finance/receipt_voucher_test.go` (NEW)
- `backend/internal/domain/finance/repository.go` (UPDATED - added ReceiptVoucherRepository)
- `backend/migrations/000012_create_receipt_vouchers.up.sql` (NEW)
- `backend/migrations/000012_create_receipt_vouchers.down.sql` (NEW)

### Build Status
- `go build ./...` ✅ PASSED
- `go test ./internal/domain/finance/...` ✅ PASSED (59+ tests for ReceiptVoucher)

### Design Decisions
1. **State machine pattern**: VoucherStatus uses strict state transitions validated by CanAllocate(), CanConfirm(), CanCancel()
2. **Domain events**: All significant state changes emit events for integration with other bounded contexts
3. **Multi-tenant**: Inherits from TenantAggregateRoot for tenant isolation
4. **Optimistic locking**: Uses version field for concurrent update protection
5. **Decimal precision**: Uses shopspring/decimal for monetary amounts
6. **Allocation tracking**: Each allocation is recorded as ReceivableAllocation with full details
7. **Confirmation workflow**: Vouchers must be confirmed before allocations can be made
8. **Payment method support**: Seven payment methods including WeChat Pay, Alipay, and customer balance

### Voucher Workflow
```
DRAFT → Confirm() → CONFIRMED → AllocateToReceivable() → ALLOCATED
           |                         |
           v                         |
        Cancel() ←-------------------+
           |
           v
       CANCELLED
```

### Notes for next developer
- **P4-BE-007** (PaymentVoucher 付款单实现) follows similar pattern - can reuse structure
- **P4-BE-008** (核销策略实现 FIFO) will implement automatic allocation strategy
- **P4-BE-009** (ReconciliationService) will coordinate voucher allocation with receivable updates
- GORM repository implementation needed before integration
- Finance API (P4-BE-010) will expose receipt voucher operations
- The ReceiptVoucher must be confirmed before allocations - prevents accidental allocations to draft vouchers
- Allocations automatically update the receivable's paid amount via ApplyPayment() method




---

## 2026-01-24 - P4-BE-007: PaymentVoucher (付款单) Implementation Complete

### Completed
- **P4-BE-007**: PaymentVoucher 付款单实现

### What was done
1. Created PaymentVoucher aggregate root at `internal/domain/finance/payment_voucher.go`:
   - Reuses `VoucherStatus` enum from receipt_voucher.go (DRAFT → CONFIRMED → ALLOCATED / CANCELLED)
   - Reuses `PaymentMethod` enum (CASH, BANK_TRANSFER, WECHAT, ALIPAY, CHECK, BALANCE, OTHER)
   - `PayableAllocation` entity for tracking payment allocations to payables
   - `PaymentVoucher` aggregate with full domain logic - mirrors ReceiptVoucher for consistency

2. Key domain methods implemented:
   - `NewPaymentVoucher()` factory with validation (positive amount, valid payment method, required fields)
   - `Confirm()` with user tracking - transitions from DRAFT to CONFIRMED
   - `AllocateToPayable()` with partial allocation support and automatic status transitions
   - `Cancel()` for cancelling vouchers without allocations
   - `SetPaymentReference()`, `SetRemark()` for updating voucher details
   - Helper methods: `IsFullyAllocated()`, `AllocationCount()`, `AllocatedPercentage()`, etc.

3. Created domain events at `internal/domain/finance/payment_voucher_events.go`:
   - `PaymentVoucherCreatedEvent` - raised on creation
   - `PaymentVoucherConfirmedEvent` - raised when confirmed
   - `PaymentVoucherAllocatedEvent` - raised when allocated to a payable
   - `PaymentVoucherCancelledEvent` - raised on cancellation

4. Extended repository interface at `internal/domain/finance/repository.go`:
   - `PaymentVoucherFilter` with comprehensive filter options (supplier, status, payment method, dates, amounts)
   - `PaymentVoucherRepository` interface with:
     - CRUD operations (FindByID, Save, Delete)
     - Query methods (FindBySupplier, FindByStatus, FindWithUnallocatedAmount)
     - Count methods (CountForTenant, CountByStatus, CountBySupplier)
     - Sum calculations (SumBySupplier, SumForTenant, SumUnallocatedBySupplier)
     - Utility methods (ExistsByVoucherNumber, GenerateVoucherNumber)

5. Created database migration at `migrations/000013_create_payment_vouchers.up.sql`:
   - `payment_vouchers` table with proper constraints and indexes
   - `payable_allocations` child table for allocation tracking
   - Check constraints for amount validation and status values
   - Foreign key to account_payables table
   - Trigger for updated_at timestamp

6. Created down migration at `migrations/000013_create_payment_vouchers.down.sql`:
   - Proper rollback order (child table first, then triggers, then main table)

7. Comprehensive unit tests at `internal/domain/finance/payment_voucher_test.go`:
   - 58+ test cases covering all functionality
   - Creation validation tests (valid data, validation errors)
   - Confirm tests (success, state validation, user validation)
   - AllocateToPayable tests (full, partial, multiple allocations, validation)
   - Cancel tests (validation, status checks, allocation checks)
   - Helper method tests (amounts, percentages, status checks)
   - Domain events tests (created, confirmed, allocated, cancelled)

### Files created/modified
- `backend/internal/domain/finance/payment_voucher.go` (NEW)
- `backend/internal/domain/finance/payment_voucher_events.go` (NEW)
- `backend/internal/domain/finance/payment_voucher_test.go` (NEW)
- `backend/internal/domain/finance/repository.go` (UPDATED - added PaymentVoucherRepository)
- `backend/migrations/000013_create_payment_vouchers.up.sql` (NEW)
- `backend/migrations/000013_create_payment_vouchers.down.sql` (NEW)

### Build Status
- `go build ./...` ✅ PASSED
- `go test ./internal/domain/finance/...` ✅ PASSED (58+ tests for PaymentVoucher)

### Design Decisions
1. **State machine pattern**: Reuses VoucherStatus from ReceiptVoucher for consistency
2. **Domain events**: All significant state changes emit events for integration with other bounded contexts
3. **Multi-tenant**: Inherits from TenantAggregateRoot for tenant isolation
4. **Optimistic locking**: Uses version field for concurrent update protection
5. **Decimal precision**: Uses shopspring/decimal for monetary amounts
6. **Allocation tracking**: Each allocation is recorded as PayableAllocation with full details
7. **Confirmation workflow**: Vouchers must be confirmed before allocations can be made
8. **Symmetric design**: PaymentVoucher mirrors ReceiptVoucher structure for consistency

### Voucher Workflow
```
DRAFT → Confirm() → CONFIRMED → AllocateToPayable() → ALLOCATED
           |                         |
           v                         |
        Cancel() ←-------------------+
           |
           v
       CANCELLED
```

### Notes for next developer
- **P4-BE-008** (核销策略实现 FIFO) is next high-priority task - will implement automatic allocation strategy
- **P4-BE-009** (ReconciliationService) will coordinate voucher allocation with payable updates
- GORM repository implementation needed before integration
- Finance API (P4-BE-010) will expose payment voucher operations
- The PaymentVoucher must be confirmed before allocations - prevents accidental allocations to draft vouchers
- Allocations automatically update the payable's paid amount via ApplyPayment() method
- PaymentVoucher reuses VoucherStatus and PaymentMethod enums from ReceiptVoucher for consistency

---

## 2026-01-24 - P4-BE-008: Reconciliation Strategy (核销策略) Implementation Complete

### Completed
- **P4-BE-008**: 核销策略实现 (FIFO)

### What was done
1. Created `reconciliation_strategy.go` with comprehensive reconciliation strategy framework:
   - `ReconciliationStrategyType` enum with FIFO and MANUAL types
   - `AllocationTarget` struct for representing receivables/payables
   - `AllocationResult` and `ReconciliationResult` structs for allocation outcomes
   - `ReconciliationStrategy` interface extending base strategy pattern

2. Implemented FIFO Reconciliation Strategy (`FIFOReconciliationStrategy`):
   - Sorts outstanding receivables/payables by due date first, then creation date
   - Items with due dates are prioritized over items without
   - Allocates payment amounts to oldest items first
   - Tracks fully paid vs partially paid targets
   - Implements `ReceivableReconciliationStrategy` and `PayableReconciliationStrategy` interfaces
   - Methods: `Allocate()`, `AllocateReceipt()`, `AllocatePayment()`

3. Implemented Manual Reconciliation Strategy (`ManualReconciliationStrategy`):
   - Allows user-specified allocation order via `ManualAllocationRequest`
   - Supports specific amounts or full outstanding allocation (Amount=0)
   - Validates and caps amounts at available/outstanding limits
   - Skips invalid or unavailable targets gracefully

4. Created `ReconciliationStrategyFactory`:
   - `CreateFIFOStrategy()` - creates FIFO strategy
   - `CreateManualStrategy(allocations)` - creates manual strategy
   - `GetStrategy(type, allocations)` - factory method with validation

5. Comprehensive unit tests at `reconciliation_strategy_test.go`:
   - 35+ test cases covering all functionality
   - ReconciliationStrategyType validation tests
   - FIFO strategy tests (sorting, allocation, edge cases)
   - Manual strategy tests (ordering, amounts, validation)
   - Factory tests (creation, validation)
   - Result struct tests

### Files created/modified
- `backend/internal/domain/finance/reconciliation_strategy.go` (NEW)
- `backend/internal/domain/finance/reconciliation_strategy_test.go` (NEW)

### Build Status
- `go build ./...` ✅ PASSED
- `go test ./internal/domain/finance/...` ✅ PASSED (35+ tests for reconciliation strategies)

### Design Decisions
1. **Strategy pattern**: Leverages existing `strategy.BaseStrategy` for consistent pattern
2. **FIFO ordering**: Prioritizes by due date, falls back to creation date, handles nil due dates
3. **Generic allocation**: `Allocate()` method works with abstract `AllocationTarget` for reusability
4. **Specialized methods**: `AllocateReceipt()` and `AllocatePayment()` filter valid targets automatically
5. **Comprehensive results**: `ReconciliationResult` tracks allocations, totals, and affected targets
6. **Factory with validation**: Prevents invalid strategy creation (e.g., manual without allocations)

### FIFO Algorithm
```
1. Sort targets by:
   - Due date ascending (items with due date before items without)
   - Creation date ascending (fallback when due dates equal or missing)
2. For each target in sorted order:
   - If remaining amount > 0 and target.outstanding > 0:
     - Allocate min(remaining, outstanding)
     - Track if fully/partially paid
3. Return allocations, totals, and remaining amount
```

### Notes for next developer
- **P4-BE-009** (ReconciliationService) is next - will use these strategies
- ReconciliationService should coordinate voucher allocation with receivable/payable updates
- Consider adding more strategies (e.g., LIFO, Priority-based) if needed
- The FIFO strategy filters out non-payable items automatically (terminal states, zero outstanding)
- Manual strategy allows fine-grained control over allocation order and amounts

---

## 2026-01-24 - P4-BE-009: ReconciliationService 核销服务 Implementation Complete

### Completed
- **P4-BE-009**: ReconciliationService 核销服务

### What was done
1. Created `reconciliation_service.go` with comprehensive ReconciliationService domain service:
   - `ReconciliationService` struct that coordinates voucher allocation to receivables/payables
   - Uses strategies from P4-BE-008 (FIFO and Manual)
   - Ensures vouchers are confirmed before allocation
   - Filters receivables/payables by customer/supplier respectively

2. Receipt Voucher Reconciliation:
   - `ReconcileReceiptRequest` and `ReconcileReceiptResult` structs
   - `ReconcileReceipt()` - main method for receipt reconciliation
   - `AutoReconcileReceipt()` - convenience method using FIFO strategy
   - `ManualReconcileReceipt()` - convenience method using manual allocations
   - `PreviewReconcileReceipt()` - preview allocations without applying them

3. Payment Voucher Reconciliation:
   - `ReconcilePaymentRequest` and `ReconcilePaymentResult` structs
   - `ReconcilePayment()` - main method for payment reconciliation
   - `AutoReconcilePayment()` - convenience method using FIFO strategy
   - `ManualReconcilePayment()` - convenience method using manual allocations
   - `PreviewReconcilePayment()` - preview allocations without applying them

4. Comprehensive unit tests at `reconciliation_service_test.go`:
   - 30+ test cases covering all functionality
   - Tests for nil voucher handling
   - Tests for unconfirmed voucher rejection
   - Tests for FIFO ordering with multiple receivables/payables
   - Tests for partial allocation scenarios
   - Tests for excess voucher amounts
   - Tests for customer/supplier filtering
   - Tests for manual allocation order
   - Tests for preview functionality (non-mutating)
   - Tests for cancelled/paid receivables/payables filtering
   - Tests for domain event generation

### Files created/modified
- `backend/internal/domain/finance/reconciliation_service.go` (NEW)
- `backend/internal/domain/finance/reconciliation_service_test.go` (NEW)

### Build Status
- `go build ./...` ✅ PASSED
- `go test ./internal/domain/finance/...` ✅ PASSED (All tests pass including 30+ new tests)

### Design Decisions
1. **Domain service pattern**: ReconciliationService coordinates across aggregates (Voucher + Receivable/Payable)
2. **Strategy delegation**: Uses ReconciliationStrategyFactory from P4-BE-008
3. **Customer/Supplier filtering**: Service ensures vouchers only reconcile with matching customer/supplier receivables/payables
4. **Preview capability**: PreviewReconcileXxx methods allow UI to show what would happen before committing
5. **Result structs**: Return comprehensive results including updated entities, allocations made, and reconciliation status
6. **Bidirectional updates**: Service updates both the voucher (AllocateToReceivable/Payable) and the receivable/payable (ApplyPayment)

### Reconciliation Flow
```
1. Validate voucher (not nil, confirmed, has unallocated amount)
2. Validate strategy type
3. Filter receivables/payables by customer/supplier
4. Get strategy and calculate allocations
5. For each allocation:
   a. Allocate on voucher (creates ReceivableAllocation/PayableAllocation)
   b. Apply payment to receivable/payable (creates PaymentRecord)
   c. Update voucher and receivable/payable status
6. Return result with all updated entities
```

### Service Methods Summary
| Method | Description |
|--------|-------------|
| `ReconcileReceipt` | Main reconciliation with full control over strategy |
| `AutoReconcileReceipt` | FIFO reconciliation (oldest receivables first) |
| `ManualReconcileReceipt` | User-specified allocation order and amounts |
| `PreviewReconcileReceipt` | Calculate allocations without applying |
| `ReconcilePayment` | Main payment reconciliation with full control |
| `AutoReconcilePayment` | FIFO payment reconciliation |
| `ManualReconcilePayment` | User-specified payment allocation |
| `PreviewReconcilePayment` | Calculate payment allocations without applying |

### Notes for next developer
- **P4-BE-010** (Finance API) is next - will expose reconciliation service operations via REST endpoints
- Application service layer will need to coordinate:
  1. Load voucher and receivables/payables from repositories
  2. Call ReconciliationService methods
  3. Save all updated entities with optimistic locking
- Consider adding transaction support in application layer for atomicity
- Preview methods are useful for UI to show allocation preview before confirmation
- Events are generated automatically by aggregate methods - application layer should publish them
- The service operates on value copies - application layer is responsible for persistence

---

## P4-BE-010: Finance API (应收/应付/收款/付款) ✅

**Date**: 2026-01-24
**Status**: COMPLETED

### Requirements
- ✅ 实现应收应付查询 API (Account Receivable/Payable Query API)
- ✅ 实现收款付款 API (Receipt/Payment Voucher API)
- ✅ 实现核销 API (Reconciliation API)

### Files Created
- `backend/internal/application/finance/finance_service.go` (NEW)
- `backend/internal/interfaces/http/handler/finance.go` (NEW)

### Build Status
- `go build ./...` ✅ PASSED
- `go test ./internal/application/finance/...` ✅ PASSED

### Implementation Summary

#### 1. Finance Application Service (`finance_service.go`)
Provides comprehensive business logic for all finance operations:

**DTOs and Responses**:
- `AccountReceivableResponse` - Receivable with payment records
- `AccountPayableResponse` - Payable with payment records
- `ReceiptVoucherResponse` - Receipt voucher with allocations
- `PaymentVoucherResponse` - Payment voucher with allocations
- `ReceivableSummaryResponse` - Aggregated receivable stats per customer
- `PayableSummaryResponse` - Aggregated payable stats per supplier

**List Filters**:
- `ReceivableListFilters` - Filter by customer, status, date range, overdue
- `PayableListFilters` - Filter by supplier, status, date range, overdue
- `ReceiptVoucherListFilters` - Filter by customer, status, date range
- `PaymentVoucherListFilters` - Filter by supplier, status, date range

**Service Methods**:
| Category | Methods |
|----------|---------|
| Receivables | `ListReceivables`, `GetReceivableByID`, `GetReceivableSummary` |
| Payables | `ListPayables`, `GetPayableByID`, `GetPayableSummary` |
| Receipt Vouchers | `CreateReceiptVoucher`, `ListReceiptVouchers`, `GetReceiptVoucherByID`, `ConfirmReceiptVoucher`, `CancelReceiptVoucher`, `ReconcileReceiptVoucher` |
| Payment Vouchers | `CreatePaymentVoucher`, `ListPaymentVouchers`, `GetPaymentVoucherByID`, `ConfirmPaymentVoucher`, `CancelPaymentVoucher`, `ReconcilePaymentVoucher` |

#### 2. Finance HTTP Handler (`finance.go`)
REST API endpoints with full Swagger/OpenAPI documentation:

**Account Receivable Endpoints**:
- `GET /api/v1/finance/receivables` - List receivables with filters
- `GET /api/v1/finance/receivables/:id` - Get receivable by ID
- `GET /api/v1/finance/receivables/summary` - Get summary by customer

**Account Payable Endpoints**:
- `GET /api/v1/finance/payables` - List payables with filters
- `GET /api/v1/finance/payables/:id` - Get payable by ID
- `GET /api/v1/finance/payables/summary` - Get summary by supplier

**Receipt Voucher Endpoints**:
- `POST /api/v1/finance/receipt-vouchers` - Create receipt voucher
- `GET /api/v1/finance/receipt-vouchers` - List receipt vouchers
- `GET /api/v1/finance/receipt-vouchers/:id` - Get receipt voucher by ID
- `POST /api/v1/finance/receipt-vouchers/:id/confirm` - Confirm voucher
- `POST /api/v1/finance/receipt-vouchers/:id/cancel` - Cancel voucher
- `POST /api/v1/finance/receipt-vouchers/:id/reconcile` - Reconcile voucher

**Payment Voucher Endpoints**:
- `POST /api/v1/finance/payment-vouchers` - Create payment voucher
- `GET /api/v1/finance/payment-vouchers` - List payment vouchers
- `GET /api/v1/finance/payment-vouchers/:id` - Get payment voucher by ID
- `POST /api/v1/finance/payment-vouchers/:id/confirm` - Confirm voucher
- `POST /api/v1/finance/payment-vouchers/:id/cancel` - Cancel voucher
- `POST /api/v1/finance/payment-vouchers/:id/reconcile` - Reconcile voucher

### API Design Patterns
1. **Consistent Response Format**: Uses `dto.Response{data=...}` pattern
2. **Pagination**: Standard `page`, `page_size`, `sort_by`, `sort_order` parameters
3. **Filtering**: Query params for customer/supplier, status, date ranges
4. **Tenant Support**: X-Tenant-ID header for multi-tenancy
5. **Error Handling**: Proper HTTP status codes and error messages

### Reconciliation Request DTOs
```go
type ReconcileReceiptRequest struct {
    StrategyType string                    // "FIFO" or "MANUAL"
    Allocations  []ManualReceivableAllocation  // For manual reconciliation
}

type ReconcilePaymentRequest struct {
    StrategyType string                   // "FIFO" or "MANUAL"
    Allocations  []ManualPayableAllocation    // For manual reconciliation
}
```

### Notes for Next Developer
- **Routes not wired in main.go**: Finance repositories don't exist yet in infrastructure/persistence
- **Handler is API definition**: Can be used for OpenAPI/Swagger generation
- **Wire up when ready**: Once `FinanceRepositoryImpl` is created, add to main.go:
  ```go
  financeService := financeapp.NewFinanceService(
      receivableRepo, payableRepo, receiptRepo, paymentRepo,
      customerRepo, supplierRepo, reconciliationSvc, sequenceGenerator,
  )
  financeHandler := handler.NewFinanceHandler(financeService)
  financeHandler.RegisterRoutes(api)
  ```
- **Domain layer complete**: All aggregates, events, repositories interfaces, and reconciliation service are implemented
- **Next features**: P4-FE-001 (应收账款列表页面) or P4-BE-015 (ExpenseRecord)

---

## P4-FE-001: 应收账款列表页面 (Account Receivable List Page)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Account Receivable (AR) list page for the Finance module frontend. This page allows users to view, filter, and manage account receivables with summary metrics.

### Features Implemented
1. **Summary Dashboard**
   - Total outstanding amount display
   - Total overdue amount display
   - Pending receivables count
   - Partial payment count
   - Overdue receivables count

2. **Data Table**
   - Receivable number with overdue indicator icon
   - Customer name
   - Source document (order number and type)
   - Total amount, Paid amount, Outstanding amount
   - Due date with overdue highlighting
   - Status tags (PENDING/PARTIAL/PAID/REVERSED/CANCELLED)
   - Created date
   - Row actions: View, Collect (create receipt)

3. **Filtering & Search**
   - Search by receivable number, customer name
   - Status filter dropdown
   - Source type filter (Sales Order, Sales Return, Manual)
   - Overdue filter toggle
   - Date range picker

4. **Navigation**
   - View action navigates to receivable detail page
   - Collect action navigates to receipt voucher creation with pre-filled customer

### Files Created/Modified
- `frontend/src/api/finance/types.ts` (NEW) - Finance API TypeScript types
- `frontend/src/api/finance/finance.ts` (NEW) - Finance API service functions
- `frontend/src/api/finance/index.ts` (NEW) - Finance API exports
- `frontend/src/pages/finance/Receivables.tsx` (MODIFIED) - Complete implementation
- `frontend/src/pages/finance/Receivables.css` (NEW) - Styles for receivables page

### Technical Notes
- **API Client**: Created manual API service since OpenAPI/orval generation isn't set up for finance endpoints yet. When the backend routes are wired up and swagger is regenerated, replace with auto-generated client.
- **Design System**: Used CSS variables for spacing, colors, typography per frontend/README.md guidelines
- **Responsive**: Mobile-first design with breakpoints at 768px and 1024px
- **Components**: Reused existing DataTable, TableToolbar, Container components

### Build Status
- `npm run build` ✅ PASSED

### Notes for Next Developer
- **Backend not wired**: Finance API routes exist in main.go but handlers aren't connected to actual service layer (repositories not implemented)
- **Next Frontend Tasks**: P4-FE-002 (应付账款列表页面), P4-FE-003 (收款单创建页面)
- **API generation**: Once backend implements persistence layer and regenerates swagger, run `npm run api:generate` to auto-generate TypeScript client, then replace manual API service
- **Similar pattern**: The Payables page (P4-FE-002) can follow the same structure - just swap customer for supplier and receivables for payables

---

## P4-FE-002: 应付账款列表页面 (Account Payable List Page)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Account Payable (AP) list page for the Finance module frontend. This page allows users to view, filter, and manage account payables with summary metrics.

### Features Implemented
1. **Summary Dashboard**
   - Total outstanding amount display
   - Total overdue amount display
   - Pending payables count
   - Partial payment count
   - Overdue payables count

2. **Data Table**
   - Payable number with overdue indicator icon
   - Supplier name
   - Source document (order number and type: Purchase Order, Purchase Return, Manual)
   - Total amount, Paid amount, Outstanding amount
   - Due date with overdue highlighting
   - Status tags (PENDING/PARTIAL/PAID/REVERSED/CANCELLED)
   - Created date
   - Row actions: View, Pay (create payment voucher)

3. **Filtering & Search**
   - Search by payable number, supplier name
   - Status filter dropdown
   - Source type filter (Purchase Order, Purchase Return, Manual)
   - Overdue filter toggle
   - Date range picker

4. **Navigation**
   - View action navigates to payable detail page
   - Pay action navigates to payment voucher creation with pre-filled supplier

### Files Created/Modified
- `frontend/src/pages/finance/Payables.tsx` (MODIFIED) - Complete implementation replacing placeholder
- `frontend/src/pages/finance/Payables.css` (NEW) - Styles for payables page

### Technical Notes
- **Pattern follows P4-FE-001**: Mirrors the Receivables page structure with AP-specific changes (supplier instead of customer, payment instead of receipt)
- **API already available**: Finance API service (`getFinancePayables`, `getFinancePayablesSummary`) already implemented in P4-FE-001
- **Types already defined**: `AccountPayable`, `PayableSummary`, `GetPayablesParams` already in types.ts
- **Design System**: Used CSS variables for spacing, colors, typography per frontend/README.md guidelines
- **Responsive**: Mobile-first design with breakpoints at 768px and 1024px

### Build Status
- `npm run build` ✅ PASSED

### Notes for Next Developer
- **Backend not wired**: Finance API routes exist but repositories not implemented yet
- **Next Frontend Tasks**: 
  - P4-FE-003 (收款单创建页面) - Receipt voucher creation
  - P4-FE-005 (付款单创建页面) - Payment voucher creation
- **Consistent patterns**: Receipt/Payment pages can follow similar structure to the list pages
- **API generation**: Once backend implements persistence layer and regenerates swagger, run `npm run api:generate` to auto-generate TypeScript client

---

## P4-FE-003: 收款单创建页面 (Receipt Voucher Creation Page)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Receipt Voucher Creation page for the Finance module frontend. This page allows users to create receipt vouchers to record customer payments with customer selection, payment method, and amount validation.

### Features Implemented
1. **Customer Selection**
   - Searchable dropdown with remote search
   - Shows customer name and code
   - Pre-fills if navigated from receivables page with customer_id param

2. **Customer Receivables Summary**
   - Shows banner with customer's outstanding receivables count and total amount
   - Lists pending receivables as tags (up to 5 with "+N more" indicator)
   - Helps user understand how much is due before creating receipt

3. **Receipt Information Form**
   - Amount input with currency prefix (¥) and 2 decimal precision
   - Payment method selection (Cash, Bank Transfer, WeChat, Alipay, Check, Balance, Other)
   - Receipt date picker (defaults to today)
   - Optional payment reference field (for transaction IDs, check numbers, etc.)
   - Optional remarks field

4. **Form Validation**
   - Required fields: customer, amount, payment method, receipt date
   - Amount must be positive and max 999,999,999.99
   - Payment reference max 100 characters
   - Remarks max 500 characters

5. **Navigation**
   - Cancel returns to receivables list
   - Successful creation shows toast and navigates to receivables list
   - Can be accessed directly at /finance/receipts/new
   - Can be pre-filled via /finance/receipts/new?customer_id=xxx

### Files Created/Modified
- `frontend/src/pages/finance/ReceiptVoucherNew.tsx` (NEW) - Receipt voucher creation page component
- `frontend/src/pages/finance/ReceiptVoucherNew.css` (NEW) - Styles for receipt voucher page
- `frontend/src/router/routes.tsx` (MODIFIED) - Added route for /finance/receipts/new

### Technical Notes
- **Zod Validation**: Uses zod schema with proper type inference for form validation
- **React Hook Form**: Integrated via useFormWithValidation custom hook
- **Customer Search**: Uses remote search with debounce to query customer API
- **Design System**: Uses CSS variables for spacing, colors, typography per frontend/README.md
- **Responsive**: Mobile-first design with breakpoints at 768px
- **API Ready**: Uses existing finance API service (postFinanceReceipts)

### Build Status
- `npm run build` ✅ PASSED

### Notes for Next Developer
- **Backend not wired**: Finance API routes exist but persistence layer isn't fully connected
- **Next Frontend Tasks**:
  - P4-FE-004 (收款核销页面) - Receipt reconciliation page
  - P4-FE-005 (付款单创建页面) - Payment voucher creation (similar structure)
- **Future enhancement**: Could pre-select specific receivable from URL param (receivable_id)
- **Pattern available**: PaymentVoucherNew can follow same structure, swapping customer for supplier

---

## P4-FE-005: 付款单创建页面 (Payment Voucher Creation Page)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Payment Voucher Creation page for the Finance module frontend. This page allows users to create payment vouchers to record supplier payments with supplier selection, payment method, and amount validation.

### Features Implemented
1. **Supplier Selection**
   - Searchable dropdown with remote search
   - Shows supplier name and code
   - Pre-fills if navigated from payables page with supplier_id param

2. **Supplier Payables Summary**
   - Shows banner with supplier's outstanding payables count and total amount
   - Lists pending payables as tags (up to 5 with "+N more" indicator)
   - Helps user understand how much is owed before creating payment

3. **Payment Information Form**
   - Amount input with currency prefix (¥) and 2 decimal precision
   - Payment method selection (Cash, Bank Transfer, WeChat, Alipay, Check, Balance, Other)
   - Payment date picker (defaults to today)
   - Optional payment reference field (for transaction IDs, check numbers, etc.)
   - Optional remarks field

4. **Form Validation**
   - Required fields: supplier, amount, payment method, payment date
   - Amount must be positive and max 999,999,999.99
   - Payment reference max 100 characters
   - Remarks max 500 characters

5. **Navigation**
   - Cancel returns to payables list
   - Successful creation shows toast and navigates to payables list
   - Can be accessed directly at /finance/payments/new
   - Can be pre-filled via /finance/payments/new?supplier_id=xxx

### Files Created/Modified
- `frontend/src/pages/finance/PaymentVoucherNew.tsx` (NEW) - Payment voucher creation page component
- `frontend/src/pages/finance/PaymentVoucherNew.css` (NEW) - Styles for payment voucher page
- `frontend/src/router/routes.tsx` (MODIFIED) - Added route for /finance/payments/new

### Technical Notes
- **Pattern follows P4-FE-003**: Mirrors the Receipt Voucher page structure with payment-specific changes (supplier instead of customer, payables instead of receivables)
- **Zod Validation**: Uses zod schema with proper type inference for form validation
- **React Hook Form**: Integrated via useFormWithValidation custom hook
- **Supplier Search**: Uses remote search with debounce to query supplier API
- **Design System**: Uses CSS variables for spacing, colors, typography per frontend/README.md
- **Responsive**: Mobile-first design with breakpoints at 768px
- **API Ready**: Uses existing finance API service (postFinancePayments)

### Build Status
- `npm run build` ✅ PASSED

### Notes for Next Developer
- **Backend not wired**: Finance API routes exist but persistence layer isn't fully connected
- **Next Frontend Tasks**:
  - P4-FE-004 (收款核销页面) - Receipt reconciliation page
  - P4-FE-006 (付款核销页面) - Payment reconciliation page (similar structure)
- **Future enhancement**: Could pre-select specific payable from URL param (payable_id)
- **Default payment method**: Set to BANK_TRANSFER (vs CASH for receipts) since supplier payments are typically via bank transfer

---

## P4-FE-004: 收款核销页面 (Receipt Reconciliation Page)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Receipt Reconciliation page for the Finance module frontend. This page allows users to reconcile receipt vouchers against outstanding receivables, supporting both automatic (FIFO) and manual allocation strategies.

### Features Implemented

1. **Receipt Voucher Details Display**
   - Shows voucher number, customer, status, payment method, date
   - Displays amount, allocated amount, and unallocated amount
   - Status banner for vouchers not in CONFIRMED state

2. **Pending Receivables List**
   - Lists all pending/partial receivables for the customer
   - Shows receivable number, source, amounts, due date, status
   - Sortable table with proper formatting

3. **Automatic Reconciliation (FIFO)**
   - Allocates by due date order (First In First Out)
   - Shows preview of allocations before confirming
   - One-click reconciliation

4. **Manual Reconciliation**
   - Checkbox selection for each receivable
   - Custom amount input per receivable
   - Select all / deselect all functionality
   - Amount validation (cannot exceed outstanding)

5. **Reconciliation Summary**
   - Shows available amount to reconcile
   - Shows selected/preview allocation total
   - Shows remaining amount after reconciliation

6. **Reconciliation Result**
   - Success/partial banner after reconciliation
   - Updated voucher details
   - List of reconciled receivables with new status

7. **Existing Allocations History**
   - Shows previously reconciled allocations
   - Displays receivable number, amount, time, remarks

### Files Created/Modified
- `frontend/src/pages/finance/ReceiptReconcile.tsx` (NEW) - Receipt reconciliation page component
- `frontend/src/pages/finance/ReceiptReconcile.css` (NEW) - Styles for reconciliation page
- `frontend/src/router/routes.tsx` (MODIFIED) - Added route for /finance/receipts/:id/reconcile

### Technical Notes
- **Two reconciliation modes**: FIFO (automatic) and MANUAL (user selection)
- **FIFO Strategy**: Sorts receivables by due date then creation date
- **Semi UI Components**: Tag, Table, Checkbox, InputNumber, Descriptions, Banner
- **API Integration**: Uses postFinanceReceiptsIdReconcile for reconciliation
- **Type Safety**: Proper TypeScript types for Tag colors and Checkbox events
- **Design System**: Uses CSS variables per frontend/README.md
- **Responsive**: Mobile-first design with breakpoints at 768px
- **Accessibility**: High contrast mode support, focus states

### Build Status
- `npm run build` ✅ PASSED

### Navigation
- Access via: `/finance/receipts/:id/reconcile`
- Back button returns to `/finance/receivables`

### Notes for Next Developer
- **P4-FE-006**: Payment reconciliation page can follow similar pattern
  - Replace customer with supplier
  - Replace receivables with payables
  - Use postFinancePaymentsIdReconcile API
- **Future enhancement**: Add preview endpoint to show allocations before commit
- **Future enhancement**: Add undo/reverse allocation functionality

---

## P4-FE-006: 付款核销页面 (Payment Reconciliation Page)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Completed the Payment Reconciliation page for the Finance module frontend. This page allows users to reconcile payment vouchers against outstanding payables, supporting both automatic (FIFO) and manual allocation strategies. This mirrors the Receipt Reconciliation page (P4-FE-004) with payment-specific adaptations.

### Features Implemented

1. **Payment Voucher Details Display**
   - Shows voucher number, supplier, status, payment method, date
   - Displays amount, allocated amount, and unallocated amount
   - Status banner for vouchers not in CONFIRMED state

2. **Pending Payables List**
   - Lists all pending/partial payables for the supplier
   - Shows payable number, source, amounts, due date, status
   - Sortable table with proper formatting

3. **Automatic Reconciliation (FIFO)**
   - Allocates by due date order (First In First Out)
   - Shows preview of allocations before confirming
   - One-click reconciliation

4. **Manual Reconciliation**
   - Checkbox selection for each payable
   - Custom amount input per payable
   - Select all / deselect all functionality
   - Amount validation (cannot exceed outstanding)

5. **Reconciliation Summary**
   - Shows available amount to reconcile
   - Shows selected/preview allocation total
   - Shows remaining amount after reconciliation

6. **Reconciliation Result**
   - Success/partial banner after reconciliation
   - Updated voucher details
   - List of reconciled payables with new status

7. **Existing Allocations History**
   - Shows previously reconciled allocations
   - Displays payable number, amount, time, remarks

### Files Created/Modified
- `frontend/src/pages/finance/PaymentReconcile.tsx` (NEW) - Payment reconciliation page component
- `frontend/src/pages/finance/PaymentReconcile.css` (NEW) - Styles for reconciliation page
- `frontend/src/router/routes.tsx` (MODIFIED) - Added route for /finance/payments/:id/reconcile

### Technical Notes
- **Two reconciliation modes**: FIFO (automatic) and MANUAL (user selection)
- **FIFO Strategy**: Sorts payables by due date then creation date
- **Semi UI Components**: Tag, Table, Checkbox, InputNumber, Descriptions, Banner
- **API Integration**: Uses postFinancePaymentsIdReconcile for reconciliation
- **Type Safety**: Proper TypeScript types for Tag colors and Checkbox events
- **Design System**: Uses CSS variables per frontend/README.md
- **Responsive**: Mobile-first design with breakpoints at 768px
- **Accessibility**: High contrast mode support, focus states

### Build Status
- `npm run build` ✅ PASSED

### Navigation
- Access via: `/finance/payments/:id/reconcile`
- Back button returns to `/finance/payables`

### Notes for Next Developer
- **Pattern mirrors P4-FE-004**: Receipt reconciliation page has same structure
- **Backend not wired**: Finance API routes exist but persistence layer isn't fully connected
- **Next Frontend Tasks**:
  - P4-FE-010 (费用录入页面) - Expense entry page
  - P4-FE-011 (其他收入录入页面) - Other income entry page
  - P4-FE-012 (收支流水页面) - Cash flow list page
- **Future enhancement**: Add preview endpoint to show allocations before commit
- **Future enhancement**: Add undo/reverse allocation functionality

---

## P4-BE-015, P4-BE-016, P4-BE-017: 费用/其他收入 Backend Implementation

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the backend infrastructure for tracking non-trade expenses (ExpenseRecord) and non-trade income (OtherIncomeRecord) in the Finance module. This provides the domain model, events, repository interfaces, and application service for managing daily expenses (rent, utilities, salary, etc.) and other income sources (investment returns, subsidies, interest, etc.).

### Features Implemented

#### P4-BE-015: ExpenseRecord Aggregate
1. **ExpenseRecord Domain Model** (`expense_record.go`)
   - ExpenseCategory enum: RENT, UTILITIES, SALARY, OFFICE, TRAVEL, MARKETING, EQUIPMENT, MAINTENANCE, INSURANCE, TAX, OTHER
   - ExpenseStatus enum: DRAFT, PENDING, APPROVED, REJECTED, CANCELLED
   - PaymentStatus enum: UNPAID, PAID
   - Full approval workflow: Draft → Submit → Approve/Reject
   - Payment tracking after approval
   - Support for attachments (URLs stored as JSON)
   - Optimistic locking with version field

2. **ExpenseRecord Events** (`expense_record_events.go`)
   - ExpenseRecordCreatedEvent
   - ExpenseRecordSubmittedEvent
   - ExpenseRecordApprovedEvent
   - ExpenseRecordRejectedEvent
   - ExpenseRecordCancelledEvent
   - ExpenseRecordPaidEvent

#### P4-BE-016: OtherIncomeRecord Aggregate
1. **OtherIncomeRecord Domain Model** (`other_income_record.go`)
   - IncomeCategory enum: INVESTMENT, SUBSIDY, INTEREST, RENTAL, REFUND, COMPENSATION, ASSET_DISPOSAL, OTHER
   - IncomeStatus enum: DRAFT, CONFIRMED, CANCELLED
   - ReceiptStatus enum: PENDING, RECEIVED
   - Confirmation workflow: Draft → Confirm
   - Receipt tracking after confirmation
   - Support for attachments (URLs stored as JSON)
   - Optimistic locking with version field

2. **OtherIncomeRecord Events** (`other_income_record_events.go`)
   - OtherIncomeRecordCreatedEvent
   - OtherIncomeRecordConfirmedEvent
   - OtherIncomeRecordCancelledEvent
   - OtherIncomeRecordReceivedEvent

#### P4-BE-017: Expense/Income API
1. **Repository Interfaces** (added to `repository.go`)
   - ExpenseRecordFilter and ExpenseRecordRepository interface
   - OtherIncomeRecordFilter and OtherIncomeRecordRepository interface
   - Full CRUD operations with tenant isolation
   - Summary and aggregation methods

2. **Application Service** (`expense_income_service.go`)
   - ExpenseIncomeService with full CRUD operations
   - Expense workflow: Create → Update → Submit → Approve/Reject → MarkAsPaid
   - Income workflow: Create → Update → Confirm → MarkAsReceived
   - Summary endpoints: GetExpenseSummary, GetIncomeSummary
   - Cash flow summary combining expenses and income
   - Request/Response DTOs for API integration

3. **Database Migration** (`000014_create_expense_income_records.up.sql`)
   - expense_records table with all fields and constraints
   - other_income_records table with all fields and constraints
   - Proper indexes for query optimization
   - Check constraints for valid categories and statuses
   - Soft delete support with deleted_at column

### Files Created
- `backend/internal/domain/finance/expense_record.go` - ExpenseRecord aggregate
- `backend/internal/domain/finance/expense_record_events.go` - Expense domain events
- `backend/internal/domain/finance/other_income_record.go` - OtherIncomeRecord aggregate
- `backend/internal/domain/finance/other_income_record_events.go` - Income domain events
- `backend/internal/application/finance/expense_income_service.go` - Application service
- `backend/migrations/000014_create_expense_income_records.up.sql` - Migration up
- `backend/migrations/000014_create_expense_income_records.down.sql` - Migration down

### Files Modified
- `backend/internal/domain/finance/repository.go` - Added ExpenseRecordRepository and OtherIncomeRecordRepository interfaces

### Technical Notes
- **DDD Pattern**: ExpenseRecord and OtherIncomeRecord are aggregate roots with proper domain events
- **Multi-tenancy**: All records are tenant-scoped via TenantAggregateRoot
- **Approval Workflow**: Expenses require approval before payment; Income requires confirmation
- **Category Display**: Both Category types have DisplayName() methods returning Chinese names
- **Soft Delete**: Uses GORM soft delete pattern with deleted_at field
- **PaymentMethod Reuse**: Uses existing PaymentMethod enum from finance package

### Build Status
- `go build ./...` ✅ PASSED

### Notes for Next Developer
- **Frontend Tasks Ready**: P4-FE-010, P4-FE-011, P4-FE-012 can now be implemented
  - P4-FE-010: 费用录入页面 (Expense entry page)
  - P4-FE-011: 其他收入录入页面 (Other income entry page)
  - P4-FE-012: 收支流水页面 (Cash flow list page)
- **Repository Implementation Needed**: The GORM repository implementations need to be created in infrastructure layer
- **API Routes Needed**: HTTP handlers need to be created to expose the ExpenseIncomeService endpoints
- **Integration with Cash Flow**: The CashFlowSummary method can be extended to include ReceiptVoucher and PaymentVoucher data

---

## P4-FE-010: 费用录入页面 (Expense Entry Page)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the frontend expense management page for the Finance module. This provides a complete CRUD interface for managing expense records with approval workflow support, filtering, and summary statistics.

### Features Implemented

1. **Expense List Page** (`Expenses.tsx`)
   - Full expense record listing with pagination
   - Search by expense number and description
   - Filter by category, status, payment status, and date range
   - Summary cards showing total approved amount and pending count
   - Table actions for workflow operations:
     - Edit (draft expenses only)
     - Submit for approval (draft expenses)
     - Approve (pending expenses)
     - Reject with reason modal (pending expenses)
     - Cancel with reason modal (draft/pending expenses)
     - Delete (draft expenses only)

2. **Expense Form Page** (`ExpenseForm.tsx`)
   - Category selection (11 expense categories)
   - Amount input with currency formatting
   - Date picker for incurred date
   - Description field (required)
   - Optional remark and attachment URLs
   - Edit mode support for existing records
   - Form validation with zod schema

3. **API Client Integration** (`finance.ts`, `types.ts`)
   - ExpenseRecord types and interfaces
   - OtherIncomeRecord types for future use
   - CashFlowSummary types for future use
   - Full CRUD API methods for expenses
   - Workflow API methods (submit, approve, reject, cancel, pay)
   - Summary API method

4. **Routing and Navigation**
   - Added `/finance/expenses` route to sidebar navigation
   - Added expense create/edit routes
   - IconMinus icon for expenses in sidebar

### Files Created
- `frontend/src/pages/finance/Expenses.tsx` - Expense list page
- `frontend/src/pages/finance/Expenses.css` - Expense list styles
- `frontend/src/pages/finance/ExpenseForm.tsx` - Expense create/edit form
- `frontend/src/pages/finance/ExpenseForm.css` - Form styles

### Files Modified
- `frontend/src/api/finance/finance.ts` - Added expense and income API methods
- `frontend/src/api/finance/types.ts` - Added expense, income, and cash flow types
- `frontend/src/router/routes.tsx` - Added expense routes
- `frontend/src/components/layout/Sidebar.tsx` - Added IconMinus for expenses

### Technical Notes
- **Design Pattern**: Follows existing finance module patterns (Receivables.tsx)
- **State Management**: Local state with React hooks
- **Form Validation**: Zod schema with react-hook-form
- **Responsive Design**: CSS follows design system with responsive breakpoints
- **Workflow Support**: Full approval workflow (Draft → Pending → Approved/Rejected)

### Build Status
- `npm run build` ✅ PASSED

### Notes for Next Developer
- **P4-FE-011 Ready**: Other income entry page can follow similar pattern
- **P4-FE-012 Ready**: Cash flow page can use the CashFlowSummary API
- **Backend Routes Needed**: HTTP handlers need to be created to expose ExpenseIncomeService endpoints
- **API Integration**: Currently using manual API client - will be replaced with orval-generated client when OpenAPI spec is available

---

## P4-FE-011: 其他收入录入页面 (Other Income Entry Page)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the frontend other income management page for the Finance module. This provides a complete CRUD interface for managing other income records with confirmation workflow support, filtering, and summary statistics.

### Features Implemented

1. **Other Income List Page** (`OtherIncomes.tsx`)
   - Full other income record listing with pagination
   - Search by income number and description
   - Filter by category, status, receipt status, and date range
   - Summary cards showing total confirmed amount and pending amount
   - Table actions for workflow operations:
     - Edit (draft incomes only)
     - Confirm (draft incomes)
     - Cancel with reason modal (draft incomes)
     - Delete (draft incomes only)

2. **Other Income Form Page** (`OtherIncomeForm.tsx`)
   - Category selection (8 income categories)
   - Amount input with currency formatting
   - Date picker for income date
   - Description field (required)
   - Optional remark and attachment URLs
   - Edit mode support for existing records
   - Form validation with zod schema

3. **Routing and Navigation**
   - Added `/finance/incomes` route to sidebar navigation
   - Added income create/edit routes
   - IconPlus icon for incomes in sidebar

### Files Created
- `frontend/src/pages/finance/OtherIncomes.tsx` - Other income list page
- `frontend/src/pages/finance/OtherIncomes.css` - Other income list styles
- `frontend/src/pages/finance/OtherIncomeForm.tsx` - Other income create/edit form
- `frontend/src/pages/finance/OtherIncomeForm.css` - Form styles

### Files Modified
- `frontend/src/router/routes.tsx` - Added income routes and lazy-loaded components
- `frontend/src/components/layout/Sidebar.tsx` - Added IconPlus for incomes

### Technical Notes
- **Design Pattern**: Follows existing finance module patterns (Expenses.tsx)
- **State Management**: Local state with React hooks
- **Form Validation**: Zod schema with react-hook-form
- **Responsive Design**: CSS follows design system with responsive breakpoints
- **Workflow Support**: Simple workflow (Draft → Confirmed/Cancelled)
- **Income Categories**: INVESTMENT, SUBSIDY, INTEREST, RENTAL, REFUND, COMPENSATION, ASSET_DISPOSAL, OTHER

### Build Status
- `npm run build` ✅ PASSED

### Notes for Next Developer
- **P4-FE-012 Ready**: Cash flow page can use the CashFlowSummary API
- **Backend Routes Needed**: HTTP handlers need to be created to expose ExpenseIncomeService endpoints
- **API Integration**: Currently using manual API client - will be replaced with orval-generated client when OpenAPI spec is available

---

## P4-FE-012: 收支流水页面 (Cash Flow Page)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the frontend Cash Flow page for the Finance module. This provides a unified view of all financial transactions including expenses, other income, receipts, and payments with comprehensive filtering and summary statistics.

### Features Implemented

1. **Cash Flow Summary Section**
   - Total inflow amount (收入)
   - Total outflow amount (支出)
   - Net cash flow (净现金流) with color coding (green for positive, red for negative)
   - Expense total (费用支出)
   - Income total (其他收入)
   - Responsive summary cards layout

2. **Cash Flow Items List**
   - Display all cash flow items with pagination
   - Client-side filtering by direction, type, and search
   - Columns: Date, Document Number, Type, Category, Description, Direction, Amount
   - Amount display with +/- prefix based on direction
   - Color-coded direction and type tags

3. **Filtering and Search**
   - Direction filter (收入/支出)
   - Type filter (费用支出/其他收入/收款/付款)
   - Date range filter with default to current month
   - Full-text search by document number, description, category
   - Refresh button

4. **Routing and Navigation**
   - Added `/finance/cashflow` route to sidebar navigation
   - Added IconHistory icon for cash flow in sidebar
   - Route order set to 5 (after incomes)

### Files Created
- `frontend/src/pages/finance/CashFlow.tsx` - Cash flow list page
- `frontend/src/pages/finance/CashFlow.css` - Cash flow page styles

### Files Modified
- `frontend/src/router/routes.tsx` - Added cash flow route and lazy-loaded component
- `frontend/src/components/layout/Sidebar.tsx` - Added IconHistory for cash flow

### Technical Notes
- **Design Pattern**: Follows existing finance module patterns (Expenses.tsx, OtherIncomes.tsx)
- **Data Handling**: Uses cash flow API with include_items=true to fetch all items
- **Client-side Filtering**: Filters, search, and pagination handled client-side for better UX
- **Default Date Range**: Defaults to current month for initial view
- **Responsive Design**: CSS follows design system with responsive breakpoints
- **Type Tags**: Different colors for each cash flow type (EXPENSE=red, INCOME=green, RECEIPT=cyan, PAYMENT=orange)

### Build Status
- `npm run build` ✅ PASSED

### Notes for Next Developer
- **Finance Module Complete**: All P4-FE features are now implemented
- **P4-INT-002 Ready**: Daily income/expense integration testing can now be performed
- **Backend API**: Uses `getFinanceCashFlow` API with `include_items: true` parameter
- **API Integration**: Currently using manual API client - will be replaced with orval-generated client when OpenAPI spec is available

---

## P5-FE-006: Dashboard 首页看板

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Dashboard/Home page for the ERP system. This provides a comprehensive business overview with key metrics, order statistics, recent orders, and pending tasks that require attention.

### Features Implemented

1. **Key Metrics Cards**
   - Product count (total and active)
   - Customer count (total and active)
   - Sales order statistics (total and pending shipment)
   - Low stock alerts count
   - Account receivables (outstanding amount and pending count)
   - Account payables (outstanding amount and pending count)
   - Clickable cards navigate to respective module pages

2. **Order Statistics Section**
   - Circular progress chart showing order completion rate
   - Breakdown of orders by status (Draft, Confirmed, Shipped, Completed)
   - Visual color-coded status dots

3. **Recent Orders List**
   - Displays last 5 sales orders
   - Shows order number, customer name, amount, status, and date
   - Clickable rows navigate to order details
   - "View All" link to full orders list

4. **Pending Tasks Section**
   - Draft orders awaiting confirmation
   - Confirmed orders awaiting shipment
   - Low stock alerts
   - Pending receivables
   - Pending payables
   - Priority tags (High/Medium/Low)
   - Clickable tasks navigate to relevant pages

### Files Created
- `frontend/src/pages/Dashboard.tsx` - Main dashboard component (replaced placeholder)
- `frontend/src/pages/Dashboard.css` - Dashboard styles (responsive)

### Technical Notes
- **API Integration**: Uses parallel Promise.allSettled for efficient data fetching
- **Error Handling**: Graceful handling of API failures (shows partial data)
- **Responsive Design**: Mobile-first CSS with breakpoints for all screen sizes
- **Accessibility**: Keyboard navigation support, proper ARIA roles
- **Design System**: Uses project layout components (Container, Row, Stack)
- **State Management**: Local React state with useCallback for memoization

### APIs Used
- `getCatalogProductsStatsCount` - Product statistics
- `getPartnerCustomersStatsCount` - Customer statistics
- `getTradeSalesOrdersStatsSummary` - Order status summary
- `getInventoryItemsAlertsLowStock` - Low stock alerts
- `getFinanceReceivablesSummary` - Receivables summary
- `getFinancePayablesSummary` - Payables summary
- `getTradeSalesOrders` - Recent orders list

### Build Status
- `npm run build` ✅ PASSED
- `npm run format` ✅ PASSED

### Notes for Next Developer
- **Charts Integration**: Dashboard is prepared for chart library (ECharts/VChart) integration when P5-BE report APIs are available
- **Sales Trend**: Currently shows order statistics; full trend charts will be added with P5-FE-001
- **Authentication**: Dashboard will need authentication integration when P6 is complete
- **Real-time Updates**: Consider adding WebSocket or polling for live updates in future


---

## P5-BE-001 to P5-BE-005: Report Module Backend Implementation

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented comprehensive report backend module following CQRS pattern with read models for sales, inventory, and finance reports. This provides the data layer for dashboard and report pages.

### Features Implemented

1. **P5-BE-001: SalesReport Read Model**
   - Sales summary with total orders, revenue, cost, and profit
   - Daily sales trend data
   - Product sales ranking (top N by sales)
   - Customer sales ranking (top N by sales)
   - Multi-dimensional filtering (by product, category, customer, date range)

2. **P5-BE-002: InventoryTurnover Read Model**
   - Inventory summary (totals, low stock, out of stock counts)
   - Inventory turnover calculation per product/warehouse
   - Inventory value by category breakdown
   - Inventory value by warehouse breakdown
   - Slow-moving products identification

3. **P5-BE-003: ProfitLossStatement**
   - P&L statement with revenue, COGS, gross profit, expenses
   - Gross and net margin calculations
   - Monthly profit trend analysis
   - Profit by product analysis
   - Profit by customer analysis

4. **P5-BE-004: CashFlowStatement**
   - Cash flow statement (operating activities)
   - Receipts from customers tracking
   - Payments to suppliers tracking
   - Expense payments and other income
   - Detailed cash flow item listing with running balance

5. **P5-BE-005: Report API Endpoints**
   - `/reports/sales/summary` - Sales summary
   - `/reports/sales/daily-trend` - Daily sales trend
   - `/reports/sales/products/ranking` - Product sales ranking
   - `/reports/sales/customers/ranking` - Customer sales ranking
   - `/reports/inventory/summary` - Inventory summary
   - `/reports/inventory/turnover` - Inventory turnover
   - `/reports/inventory/value-by-category` - Value by category
   - `/reports/inventory/value-by-warehouse` - Value by warehouse
   - `/reports/inventory/slow-moving` - Slow moving products
   - `/reports/finance/profit-loss` - P&L statement
   - `/reports/finance/monthly-trend` - Monthly profit trend
   - `/reports/finance/profit-by-product` - Profit by product
   - `/reports/finance/cash-flow` - Cash flow statement
   - `/reports/finance/cash-flow/items` - Cash flow items

### Files Created

**Domain Layer:**
- `backend/internal/domain/report/sales_report.go` - Sales report read models and repository interface
- `backend/internal/domain/report/inventory_report.go` - Inventory report read models and repository interface
- `backend/internal/domain/report/finance_report.go` - Finance report read models (P&L, Cash Flow) and repository interface

**Application Layer:**
- `backend/internal/application/report/report_service.go` - Report application service with all report operations

**Infrastructure Layer:**
- `backend/internal/infrastructure/persistence/sales_report_repository.go` - GORM sales report repository
- `backend/internal/infrastructure/persistence/inventory_report_repository.go` - GORM inventory report repository
- `backend/internal/infrastructure/persistence/finance_report_repository.go` - GORM finance report repository

**Interface Layer:**
- `backend/internal/interfaces/http/handler/report.go` - Report HTTP handler with all API endpoints

### Technical Notes
- **CQRS Pattern**: Read models separate from write models for optimized queries
- **PostgreSQL Queries**: Complex aggregations using GROUP BY, JOINs, subqueries
- **Date Range Filtering**: All reports support start/end date filtering
- **Tenant Isolation**: All queries filtered by tenant_id
- **Decimal Precision**: Uses shopspring/decimal for financial calculations
- **Turnover Calculation**: Turnover rate = Sold Quantity / Average Stock
- **Profit Margins**: Calculated as percentage of revenue

### API Documentation
All endpoints include Swagger annotations for OpenAPI spec generation.

### Build Status
- `go build ./...` ✅ PASSED

### Notes for Next Developer
- **P5-FE Integration**: Frontend report pages can now be implemented using these APIs
- **Route Registration**: Report handler needs to be registered in the main router
- **Database Tables**: Queries assume existing tables (sales_orders, sales_order_items, inventory_items, products, etc.)
- **P5-BE-006**: Async aggregation (scheduled tasks) is pending if needed for performance optimization
- **Authentication**: Currently uses X-Tenant-ID header; will integrate with P6 auth module


---

## P5-FE-001: Sales Report Page Implementation

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Sales Report Page with interactive charts, KPI metrics cards, and ranking tables. The page provides comprehensive sales analytics with trend visualization and top performer rankings.

### Features Implemented

1. **Sales Metrics Dashboard**
   - Total Sales Amount card with average order value
   - Total Orders card with total quantity sold
   - Gross Profit card with profit margin percentage
   - Sales Cost card with cost ratio

2. **Sales Trend Chart (ECharts)**
   - Line chart showing daily sales amount trend
   - Line chart showing daily profit trend
   - Bar chart showing daily order count
   - Dual Y-axis (amount/order count)
   - Interactive tooltips with formatted values
   - Gradient area fill for visual appeal

3. **Sales Composition Pie Chart**
   - Donut chart showing top 5 products by sales
   - "Others" category for remaining products
   - Interactive legend and hover effects
   - Percentage breakdown tooltips

4. **Product Sales Ranking Table**
   - Top 10 products by sales amount
   - Shows product name, SKU, total amount, quantity, profit
   - Visual rank indicators (gold for top 3)
   - Color-coded profit values

5. **Customer Sales Ranking Table**
   - Top 10 customers by sales amount
   - Shows customer name, total amount, order count, profit
   - Tabbed interface with Product/Customer toggle

6. **Date Range Filter**
   - Preset options: Last 7/30/90 days, This Month, Last Month, This Year
   - Custom date range picker
   - Auto-refresh on date change

### Files Created

**Report API Layer:**
- `frontend/src/api/reports/types.ts` - TypeScript types for report API responses
- `frontend/src/api/reports/reports.ts` - Report API service with axios calls
- `frontend/src/api/reports/index.ts` - API module exports

**Page Components:**
- `frontend/src/pages/report/SalesReport.tsx` - Main sales report page component
- `frontend/src/pages/report/SalesReport.css` - Page-specific styles

**Router Configuration:**
- `frontend/src/router/routes.tsx` - Added /report module with /report/sales route

### Technical Details

**Chart Library**: ECharts (echarts + echarts-for-react)
- Optimized imports using echarts/core for tree-shaking
- Registered only needed components (Line, Pie, Bar charts)
- CanvasRenderer for performance

**UI Components**: Semi Design
- MetricCard custom component for KPI display
- Grid layout for responsive metrics
- Tabs for ranking table switching
- DatePicker with type="dateRange"
- Table with custom column renderers

**State Management**:
- Local state with useState hooks
- Parallel API calls with Promise.allSettled
- Memoized chart options with useMemo
- Callback handlers with useCallback

**Responsive Design**:
- CSS Grid for metric cards (1/2/4 columns)
- Flex wrap for chart containers
- Responsive chart sizing

### Build Status
- `npm run build` ✅ PASSED

### API Endpoints Used
- `GET /reports/sales/summary` - Sales summary metrics
- `GET /reports/sales/daily-trend` - Daily sales trend data
- `GET /reports/sales/products/ranking` - Product sales ranking
- `GET /reports/sales/customers/ranking` - Customer sales ranking

### Dependencies Added
- `echarts` - Core charting library
- `echarts-for-react` - React wrapper for ECharts

### Notes for Next Developer
- **P5-FE-002**: Sales ranking page is similar - can reuse ranking table components
- **Data Loading**: Uses Promise.allSettled for graceful degradation
- **Chart Sizing**: Charts are responsive but may need adjustment for very small screens
- **Caching**: Consider adding React Query for API response caching in future

---

## P5-FE-002: Sales Ranking Page (销售排行榜页面)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Sales Ranking Page with product and customer ranking tables, horizontal bar charts, and dimension switching capability. The page provides detailed sales performance analysis with flexible sorting options.

### Features Implemented

1. **Summary Metrics Dashboard**
   - Total products count participating in rankings
   - Total customers count participating in rankings
   - Top product sales amount (champion)
   - Top customer sales amount (champion)

2. **Dimension Switching (Radio Buttons)**
   - Sort by Sales Amount (销售额)
   - Sort by Sales Quantity (销售数量)
   - Sort by Profit (毛利)
   - Dynamic re-sorting of data when dimension changes

3. **Product Sales Ranking**
   - Horizontal bar chart showing Top 10 products by selected dimension
   - Full ranking table with pagination (10/20/50 per page)
   - Columns: Rank (with medal icons for top 3), Product Name, SKU, Category, Sales Amount, Quantity, Order Count, Profit
   - Client-side sorting capability on numeric columns

4. **Customer Sales Ranking**
   - Horizontal bar chart showing Top 10 customers by selected dimension
   - Full ranking table with pagination (10/20/50 per page)
   - Columns: Rank (with medal icons for top 3), Customer Name, Sales Amount, Quantity, Order Count, Profit
   - Client-side sorting capability on numeric columns

5. **Filters**
   - Preset date ranges: Last 7/30/90 days, This Month, Last Month, This Year
   - Custom date range picker
   - Top N selector: Top 10, 20, 50, 100

### Files Created

- `frontend/src/pages/report/SalesRanking.tsx` - Main sales ranking page component
- `frontend/src/pages/report/SalesRanking.css` - Page-specific styles

### Files Modified

- `frontend/src/router/routes.tsx` - Added /report/ranking route and lazy-loaded component

### Technical Details

**Chart Library**: ECharts (echarts + echarts-for-react)
- Horizontal bar charts with gradient fills
- Responsive sizing
- Truncated labels for long names

**UI Components**: Semi Design
- RadioGroup for dimension switching
- Tabs for Product/Customer toggle
- Table with sorting and pagination
- Tag with medal colors (amber, white, orange) for top 3 ranks
- DatePicker with type="dateRange"

**State Management**:
- Local state with useState hooks
- Parallel API calls with Promise.allSettled
- Memoized chart options with useMemo
- Client-side sorting by dimension

### Build Status
- `npm run build` ✅ PASSED

### API Endpoints Used
- `GET /reports/sales/products/ranking` - Product sales ranking with top_n parameter
- `GET /reports/sales/customers/ranking` - Customer sales ranking with top_n parameter

### Notes for Next Developer
- **P5-FE-003**: Inventory Turnover Report - should follow similar structure
- **P5-FE-004**: Profit/Loss Report - uses different API endpoints
- **Dimension Switching**: The pattern can be reused for other ranking pages
- **ECharts**: Shared between SalesReport and SalesRanking pages (code-split together)

---

## P5-FE-003: Inventory Turnover Report Page (库存周转报表页面)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Inventory Turnover Report Page with metrics cards, distribution charts, warehouse distribution, and detailed product turnover table. The page provides comprehensive inventory turnover analysis with filtering capabilities.

### Features Implemented

1. **Summary Metrics Dashboard**
   - Total products count
   - Total inventory value
   - Average turnover rate (周转次数/期)
   - Slow-moving products count with out-of-stock indicator

2. **Turnover Distribution Pie Chart**
   - Groups products by turnover rate ranges:
     - 滞销 (<2): Red
     - 偏慢 (2-4): Amber
     - 正常 (4-8): Green
     - 良好 (8-12): Blue
     - 优秀 (>12): Purple
   - Interactive donut chart with legend

3. **Category Inventory Value Bar Chart**
   - Top 10 categories by inventory value
   - Horizontal bar chart with gradient fill
   - Value labels on bars

4. **Warehouse Distribution Section**
   - Grid layout showing all warehouses
   - Each warehouse card shows:
     - Warehouse name
     - Product count
     - Total inventory value
     - Percentage progress bar
     - Proportion percentage

5. **Product Turnover Detail Table**
   - Columns: Product Info (Name + SKU), Category, Warehouse, Beginning Stock, Ending Stock, Average Stock, Sold Quantity, Turnover Rate (with status tag), Days of Inventory, Stock Value
   - Sortable columns for numeric fields
   - Pagination (10/20/50/100 per page)
   - Search by product name, SKU, or category

6. **Filters**
   - Category dropdown filter
   - Warehouse dropdown filter
   - Preset date ranges: 近30天, 近90天, 近半年, 近一年
   - Custom date range picker

### Files Created

- `frontend/src/pages/report/InventoryTurnover.tsx` - Main inventory turnover report page component
- `frontend/src/pages/report/InventoryTurnover.css` - Page-specific styles

### Files Modified

- `frontend/src/router/routes.tsx` - Added /report/inventory-turnover route and lazy-loaded component

### Technical Details

**Chart Library**: ECharts (echarts + echarts-for-react)
- Pie chart for turnover distribution
- Horizontal bar chart for category values
- Gradient fills and responsive sizing

**UI Components**: Semi Design
- Grid for responsive metrics layout
- Row with flex wrap for chart layout
- Table with sorting and pagination
- Select for filters
- DatePicker with type="dateRange"
- Tag for turnover status indicators
- Progress for warehouse percentage

**State Management**:
- Local state with useState hooks
- Parallel API calls with Promise.allSettled
- Memoized chart options with useMemo
- Client-side search filtering

**Layout Components**: Custom design system
- Container, Grid, Row from @/components/common/layout
- Responsive grid with mobile/tablet/desktop breakpoints

### Build Status
- `npm run build` ✅ PASSED

### API Endpoints Used
- `GET /reports/inventory/summary` - Inventory summary metrics
- `GET /reports/inventory/turnover` - Product turnover data
- `GET /reports/inventory/value-by-category` - Category-wise inventory value
- `GET /reports/inventory/value-by-warehouse` - Warehouse-wise inventory value

### Notes for Next Developer
- **P5-FE-004**: Profit/Loss Report - uses `/reports/finance/profit-loss` and `/reports/finance/monthly-trend` endpoints
- **P5-FE-005**: Cash Flow Report - uses `/reports/finance/cash-flow` and `/reports/finance/cash-flow/items` endpoints
- **Design Pattern**: Similar structure to SalesReport and SalesRanking pages - can reuse MetricCard component pattern
- **Filter Logic**: Category/warehouse options are populated from API response data


---

## P5-FE-004: 损益报表页面 (Profit/Loss Report Page)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Profit/Loss Report Page with comprehensive P&L statement display, monthly profit trends, and product profit analysis. The page provides clear visibility into business profitability with export support.

### Features Implemented

1. **Summary Metrics Dashboard**
   - Net sales revenue with total income
   - Sales cost with returns amount
   - Gross profit with gross margin percentage
   - Net profit with net margin percentage

2. **P&L Statement Breakdown**
   - Revenue section: Sales revenue, returns, net sales revenue
   - Cost & Gross Profit section: COGS, gross profit, gross margin
   - Other Income/Expenses section: Other income, total income, expenses
   - Net Profit section: Net profit and net margin with color-coded tags

3. **Monthly Profit Trend Chart**
   - Grouped bar chart for sales revenue, gross profit, net profit
   - Line chart overlay for gross margin and net margin percentages
   - Dual Y-axis (amount and percentage)
   - Interactive tooltips with formatted values

4. **Product Profit Analysis Table**
   - Columns: Product (Name + SKU), Category, Sales Revenue, COGS, Gross Profit, Gross Margin (color-coded tag), Profit Contribution
   - Sortable columns for revenue, profit, margin, and contribution
   - Pagination with size options (10/20/50)

5. **Filters & Export**
   - Date range picker for period selection
   - CSV export button with UTF-8 BOM for Excel compatibility
   - Export includes all P&L statement line items

### Files Created

- `frontend/src/pages/report/ProfitLoss.tsx` - Main P&L report page component
- `frontend/src/pages/report/ProfitLoss.css` - Page-specific styles

### Files Modified

- `frontend/src/router/routes.tsx` - Added /report/profit-loss route and lazy-loaded component

### Technical Details

**Chart Library**: ECharts (echarts + echarts-for-react)
- Grouped bar chart for revenue/profit metrics
- Line chart overlay for margin percentages
- Dual Y-axis configuration

**UI Components**: Semi Design
- Grid for responsive metrics layout
- Descriptions for P&L statement breakdown
- Table with column sorting and pagination
- DatePicker with type="dateRange"
- Tag for margin status indicators (green/orange/red)
- Button with IconDownload for export

**State Management**:
- Local state with useState hooks
- Parallel API calls with Promise.allSettled
- Memoized chart options with useMemo
- Export to CSV with Blob API

**Layout Components**: Custom design system
- Container, Grid from @/components/common/layout
- Responsive grid with mobile/tablet/desktop breakpoints

### Build Status
- `npm run build` ✅ PASSED

### API Endpoints Used
- `GET /reports/finance/profit-loss` - P&L statement data
- `GET /reports/finance/monthly-trend` - Monthly profit trend data
- `GET /reports/finance/profit-by-product` - Product profit analysis

### Notes for Next Developer
- **P5-FE-005**: Cash Flow Report - uses `/reports/finance/cash-flow` and `/reports/finance/cash-flow/items` endpoints
- **Design Pattern**: Similar structure to SalesReport and InventoryTurnover pages
- **Export Format**: CSV with UTF-8 BOM for proper Chinese character display in Excel
- **Chart Note**: Uses grouped bar chart pattern from ECharts for multi-series comparison


---

## P5-FE-005: 现金流量报表页面 (Cash Flow Report Page)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Cash Flow Report Page with comprehensive cash flow statement display, waterfall chart visualization, cash flow items detail table, and period comparison functionality.

### Features Implemented

1. **Summary Metrics Dashboard**
   - Ending cash balance with beginning balance comparison
   - Net cash increase/decrease with trend indicator
   - Operating cash flow with period comparison
   - Customer receipts vs supplier payments

2. **Cash Flow Statement Breakdown**
   - Beginning cash balance section
   - Operating activities section with:
     - Receipts from customers (positive)
     - Payments to suppliers (negative)
     - Other income (positive)
     - Expense payments (negative)
     - Net operating cash flow subtotal
   - Ending balance section with net cash flow

3. **Cash Flow Waterfall Chart**
   - Visual waterfall chart showing cash flow progression
   - Green bars for inflows, red bars for outflows
   - Starting and ending balance visualization
   - Stacked bar implementation with invisible helper series
   - Value labels on each bar

4. **Cash Flow Items Detail Table**
   - Columns: Date, Type (with color-coded tags), Reference No, Description, Amount, Running Balance
   - Type filters (Customer Receipts, Supplier Payments, Other Income, Expense)
   - Sortable amount column
   - Pagination with size options (10/20/50)

5. **Period Comparison Feature**
   - Select comparison options: None, Previous Period, Same Period Last Year
   - Comparison values displayed in metric cards
   - Percentage change indicators with trend arrows
   - Comparison period ending balance shown in statement

6. **Filters & Export**
   - Date range picker for period selection
   - Refresh button to reload data
   - CSV export with UTF-8 BOM for Excel compatibility
   - Export includes full cash flow statement breakdown

### Files Created

- `frontend/src/pages/report/CashFlowReport.tsx` - Main cash flow report page component
- `frontend/src/pages/report/CashFlowReport.css` - Page-specific styles

### Files Modified

- `frontend/src/router/routes.tsx` - Added /report/cash-flow route and lazy-loaded component

### Technical Details

**Chart Library**: ECharts (echarts + echarts-for-react)
- Waterfall chart implementation using stacked bars
- Invisible helper series for positioning
- Green/red coloring for inflows/outflows

**UI Components**: Semi Design
- Grid for responsive metrics layout
- Descriptions for cash flow statement breakdown
- Table with column filtering and sorting
- DatePicker with type="dateRange"
- Select for comparison period
- Tag for cash flow type indicators (green/red/cyan/orange)
- Button with IconSync for refresh, IconDownload for export

**State Management**:
- Local state with useState hooks
- Parallel API calls with Promise.allSettled
- Memoized chart options with useMemo
- Comparison period data fetched separately

**Layout Components**: Custom design system
- Container, Grid from @/components/common/layout
- Responsive grid with mobile/tablet/desktop breakpoints

### Build Status
- `npm run build` ✅ PASSED

### API Endpoints Used
- `GET /reports/finance/cash-flow` - Cash flow statement summary
- `GET /reports/finance/cash-flow/items` - Detailed cash flow items

### Notes for Next Developer
- **Report Module Complete**: All P5-FE reports (Sales, Sales Ranking, Inventory Turnover, P&L, Cash Flow) are now implemented
- **Next Focus**: Consider P5-INT-001 (Report Module Integration Testing) or move to P6 (Multi-tenant & Auth)
- **Design Pattern**: Waterfall chart pattern can be reused for other financial visualizations
- **Comparison Feature**: The period comparison logic is reusable for other reports

---

## P6-BE-001: Tenant 聚合实现 (Tenant Aggregate Implementation)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Tenant aggregate root in the identity domain. This is foundational infrastructure for the multi-tenant system, supporting tenant management with status, plans, configuration, and expiration handling.

### Features Implemented

1. **Tenant Aggregate Root**
   - Status management: Active, Inactive, Suspended, Trial
   - Subscription plans: Free, Basic, Pro, Enterprise
   - Contact information (name, phone, email)
   - Address and logo URL
   - Custom domain/subdomain support
   - Trial and subscription expiration dates

2. **TenantConfig Embedded Configuration**
   - MaxUsers, MaxWarehouses, MaxProducts limits
   - Cost strategy (FIFO, Weighted Average)
   - Currency, Timezone, Locale settings
   - Features and Settings JSON objects
   - Auto-updates based on plan tier

3. **Status Transitions**
   - Activate() - Activate a tenant
   - Deactivate() - Deactivate a tenant
   - Suspend() - Suspend a tenant (e.g., payment issues)
   - ConvertFromTrial() - Convert trial to paid plan

4. **Domain Events**
   - TenantCreatedEvent
   - TenantUpdatedEvent
   - TenantStatusChangedEvent
   - TenantPlanChangedEvent
   - TenantDeletedEvent

5. **Business Logic**
   - Trial expiration checks
   - Subscription expiration checks
   - Resource limit checks (CanAddUser, CanAddWarehouse, CanAddProduct)
   - Auto config updates when plan changes

### Files Created

- `backend/internal/domain/identity/doc.go` - Package documentation
- `backend/internal/domain/identity/tenant.go` - Tenant aggregate root
- `backend/internal/domain/identity/tenant_events.go` - Domain events
- `backend/internal/domain/identity/tenant_repository.go` - Repository interface
- `backend/internal/domain/identity/tenant_test.go` - Comprehensive unit tests

### Technical Details

**Plan Resource Limits**:
| Plan | MaxUsers | MaxWarehouses | MaxProducts |
|------|----------|---------------|-------------|
| Free | 5 | 3 | 1,000 |
| Basic | 10 | 5 | 5,000 |
| Pro | 50 | 20 | 50,000 |
| Enterprise | 9,999 | 9,999 | 999,999 |

**Test Coverage**: 50+ test cases covering:
- Tenant creation (normal and trial)
- Status transitions
- Plan changes and config updates
- Expiration checks
- Resource limit validation
- Input validation

### Build & Test Status
- `go build ./...` ✅ PASSED
- `go test ./internal/domain/identity/...` ✅ PASSED (all 50+ tests)

### Notes for Next Developer
- **Next Steps**: P6-BE-002 (Tenant Middleware) to implement tenant_id extraction from JWT
- **Pattern**: Uses BaseAggregateRoot from shared package (not TenantAggregateRoot since Tenant itself is the tenant)
- **Events**: Tenant events use tenant ID as both aggregate_id and tenant_id in BaseDomainEvent
- **Repository**: Interface defined but GORM implementation needed in infrastructure layer

---

## P6-BE-002: 租户中间件 (Tenant Middleware - tenant_id injection)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the tenant identification middleware that extracts tenant_id from multiple sources (JWT claims, HTTP header, subdomain) and injects it into the request context. This is foundational infrastructure for the multi-tenant system.

### Features Implemented

1. **Multi-source Tenant Extraction**
   - Priority 1: JWT claims (`jwt_tenant_id`) - for use after JWT middleware runs
   - Priority 2: X-Tenant-ID header - for direct API calls
   - Priority 3: Subdomain extraction - e.g., `acme.erp.com` → `acme`

2. **Configuration Options**
   - `HeaderEnabled` - Enable/disable X-Tenant-ID header extraction
   - `JWTEnabled` - Enable/disable JWT claim extraction
   - `SubdomainEnabled` - Enable/disable subdomain extraction
   - `BaseDomain` - Base domain for subdomain extraction
   - `SkipPaths` - Paths that don't require tenant context (health checks, etc.)
   - `Required` - Whether tenant context is mandatory
   - `Validator` - Optional validator interface to check tenant status

3. **Context Integration**
   - Stores tenant_id in both gin.Context and request.Context
   - Integrates with logger package for structured logging
   - Provides helper functions: `GetTenantID`, `GetTenantUUID`, `GetTenantCode`
   - Must-get variants: `MustGetTenantID`, `MustGetTenantUUID` (panic if not found)

4. **Security Features**
   - UUID format validation for tenant IDs
   - Optional tenant validation via `TenantValidator` interface
   - Unauthorized response for invalid/missing tenant when required
   - Path skipping for public endpoints

5. **Middleware Variants**
   - `TenantMiddleware()` - Default configuration, tenant required
   - `TenantMiddlewareWithConfig(cfg)` - Custom configuration
   - `OptionalTenantMiddleware()` - Tenant not required

### Files Created

- `backend/internal/interfaces/http/middleware/tenant.go` - Tenant middleware implementation
- `backend/internal/interfaces/http/middleware/tenant_test.go` - Comprehensive unit tests

### Technical Details

**Extraction Priority Order**:
1. JWT claims (if JWT middleware has run and set `jwt_tenant_id`)
2. X-Tenant-ID header
3. Subdomain (if configured with base domain)

**Default Skip Paths**:
- `/health`
- `/healthz`
- `/ready`
- `/metrics`
- `/api/v1/health`

### API for Handlers

```go
// Get tenant ID from gin context
tenantID := middleware.GetTenantID(c)

// Get tenant ID as UUID
tenantUUID, err := middleware.GetTenantUUID(c)

// Get tenant code (if validator provides it)
tenantCode := middleware.GetTenantCode(c)

// Must-get variants (panic if not found)
tenantID := middleware.MustGetTenantID(c)
tenantUUID := middleware.MustGetTenantUUID(c)
```

### Build & Test Status
- `go build ./...` ✅ PASSED
- `go test ./internal/interfaces/http/middleware/...` ✅ PASSED (16 tenant-related tests)

### Notes for Next Developer
- **Next Steps**: P6-BE-003 (Repository layer tenant_id filtering) or P6-BE-014 (JWT middleware) 
- **JWT Integration**: When JWT middleware (P6-BE-014) is implemented, it should set `jwt_tenant_id` in gin.Context
- **Validator Pattern**: Implement `TenantValidator` interface to check tenant status in database
- **Subdomain**: Enable `SubdomainEnabled` and set `BaseDomain` for subdomain-based tenant identification
- **Context Propagation**: Tenant ID is available in both gin.Context (via GetTenantID) and request.Context (via logger.GetTenantID)


---

## P6-BE-003: Repository 层自动 tenant_id 过滤 (Repository Auto tenant_id Filtering)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented automatic tenant_id filtering at the repository layer using GORM scopes and callbacks. This prevents cross-tenant data access by automatically adding WHERE tenant_id = ? conditions to all database queries.

### Features Implemented

1. **TenantScope Functions**
   - `TenantScope(uuid.UUID)` - GORM scope for UUID tenant IDs
   - `TenantScopeString(string)` - GORM scope for string tenant IDs

2. **TenantDB Wrapper**
   - `NewTenantDB(db)` - Creates tenant-aware DB wrapper (required=true by default)
   - `NewTenantDBWithConfig(db, cfg)` - With custom configuration
   - `WithContext(ctx)` - Extracts tenant_id from context, applies scope
   - `WithTenant(uuid)` - Scopes to specific tenant UUID
   - `WithTenantString(string)` - Scopes to specific tenant string
   - `ForTenant(ctx, uuid)` - Creates scoped DB with both context and tenant
   - `Transaction(ctx, fn)` - Transaction with tenant scope
   - `Unscoped()` - Returns raw DB (bypasses tenant filter - use with caution!)
   - `SetRequired(bool)` - Changes required flag

3. **GORM Callbacks (Optional Auto-filter)**
   - `EnableAutoTenantFilter(db, required)` - Enables automatic filtering via callbacks
   - `DisableAutoTenantFilter(db)` - Removes callbacks
   - Callbacks intercept: Query, Update, Delete, Row operations
   - Automatically adds tenant_id filter from context

4. **Error Handling**
   - `ErrTenantIDRequired` - When tenant required but not in context
   - `ErrInvalidTenantID` - When tenant ID is not valid UUID format

5. **Configuration**
   - `Config.TenantColumn` - Column name (default: "tenant_id")
   - `Config.Required` - Whether tenant is mandatory (default: true)

### Files Created

- `backend/internal/infrastructure/persistence/tenant/scope.go` - TenantDB wrapper and scopes
- `backend/internal/infrastructure/persistence/tenant/callback.go` - GORM callback implementation
- `backend/internal/infrastructure/persistence/tenant/scope_test.go` - Comprehensive tests
- `backend/internal/infrastructure/persistence/tenant/callback_test.go` - Callback tests

### Usage Examples

**Basic Usage with Context (Recommended)**:
```go
import "github.com/erp/backend/internal/infrastructure/persistence/tenant"

// Create tenant-aware DB wrapper
tenantDB := tenant.NewTenantDB(db)

// In handler: extract tenant from context and query
func (h *Handler) List(c *gin.Context) {
    ctx := c.Request.Context() // Contains tenant_id from middleware
    var products []Product
    if err := tenantDB.WithContext(ctx).Find(&products).Error; err != nil {
        // Handle error
    }
}
```

**Direct Tenant Scoping**:
```go
// When you have tenant ID directly
products, err := tenantDB.WithTenant(tenantUUID).Find(&products)

// With string tenant ID
products, err := tenantDB.WithTenantString("tenant-uuid-string").Find(&products)
```

**Using GORM Scopes Directly**:
```go
// Apply to any GORM query
db.Scopes(tenant.TenantScope(tenantID)).Find(&products)
```

**Auto-Filter with Callbacks**:
```go
// Enable once at startup - all queries will auto-filter by tenant
tenant.EnableAutoTenantFilter(db, true)

// Then use normal GORM operations - tenant filter is automatic
db.WithContext(ctx).Find(&products) // WHERE tenant_id = 'xxx' auto-added
```

### Build & Test Status
- `go build ./...` ✅ PASSED
- `go test ./internal/infrastructure/persistence/tenant/...` ✅ PASSED (26+ tests)

### Notes for Next Developer
- **Recommended Pattern**: Use `TenantDB.WithContext(ctx)` which extracts tenant from context set by middleware
- **Callback Approach**: Use `EnableAutoTenantFilter` for automatic filtering without code changes (good for legacy code migration)
- **Scope Approach**: Use `TenantScope` functions for explicit, opt-in tenant filtering
- **Security**: The `Unscoped()` method bypasses all tenant filtering - use only for system-level operations
- **Validation**: Both UUID format validation and required tenant checks are enforced
- **Context Integration**: Works with `logger.GetTenantID(ctx)` which is set by tenant middleware


---

## P6-BE-010: User 聚合实现 (User Aggregate Implementation)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the User aggregate root for the Identity Context, following RBAC (Role-Based Access Control) model as specified in the design document. The User aggregate manages user authentication, authorization, and status lifecycle.

### Features Implemented

1. **User Aggregate Root** (`user.go`)
   - `User` struct with TenantAggregateRoot (multi-tenant support)
   - Username validation (3-100 chars, alphanumeric + special chars)
   - Password validation (8-128 chars, must contain letter + number)
   - Password hashing using bcrypt (cost=12)
   - Email and phone validation

2. **User Status Management**
   - `UserStatus` enum: `pending`, `active`, `locked`, `deactivated`
   - Status transitions: `Activate()`, `Deactivate()`, `Lock()`, `Unlock()`
   - Lock with optional duration (auto-expiry support)
   - Failed login attempt tracking with auto-lock

3. **Role Management**
   - `AssignRole(roleID)` - Add role to user
   - `RemoveRole(roleID)` - Remove role from user
   - `SetRoles(roleIDs)` - Replace all roles (with deduplication)
   - `HasRole(roleID)` - Check if user has specific role
   - `UserRole` entity for many-to-many relationship

4. **Password Operations**
   - `VerifyPassword(password)` - Validate password
   - `ChangePassword(old, new)` - Change with old password verification
   - `SetPassword(new)` - Admin password reset
   - `ForcePasswordChange()` - Flag for mandatory password change

5. **Login Tracking**
   - `RecordLoginSuccess(ip)` - Record successful login
   - `RecordLoginFailure(maxAttempts, duration)` - Track failed attempts
   - `CanLogin()` - Check if user can authenticate
   - Last login timestamp and IP tracking

6. **Domain Events** (`user_events.go`)
   - `UserCreatedEvent` - When user is created
   - `UserDeactivatedEvent` - When user is deactivated
   - `UserPasswordChangedEvent` - When password changes
   - `UserRoleAssignedEvent` - When role is assigned
   - `UserRoleRemovedEvent` - When role is removed
   - `UserStatusChangedEvent` - When status changes

7. **UserRepository Interface** (`user_repository.go`)
   - `Create`, `Update`, `Delete`, `FindByID`
   - `FindByUsername`, `FindByEmail`, `FindByPhone`
   - `FindAll` with `UserFilter` (keyword, status, role, pagination)
   - `ExistsByUsername`, `ExistsByEmail`
   - `SaveUserRoles`, `LoadUserRoles`
   - `Count` for tenant user limit checks

### Files Created

- `backend/internal/domain/identity/user.go` - User aggregate root
- `backend/internal/domain/identity/user_events.go` - User domain events
- `backend/internal/domain/identity/user_repository.go` - Repository interface
- `backend/internal/domain/identity/user_test.go` - Comprehensive unit tests

### Build & Test Status
- `go build ./...` ✅ PASSED
- `go test ./internal/domain/identity/...` ✅ PASSED (50+ test cases)

### Notes for Next Developer
- **Repository Implementation**: Next step is to implement GORM-based UserRepository
- **Role Aggregate**: P6-BE-011 implements the Role aggregate that User references
- **JWT Integration**: P6-BE-014 implements JWT authentication using User aggregate
- **Unique Constraints**: Username and email should be unique per tenant (enforced at DB level)
- **Password Security**: bcrypt cost is set to 12, adjust in production if needed
- **Lock Duration**: Default is time-based lock; pass 0 duration for indefinite lock


---

## P6-BE-011: Role 聚合实现 (Role Aggregate Implementation)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the Role aggregate root for the Identity Context, following the RBAC (Role-Based Access Control) model as specified in the design document. The Role aggregate manages roles, permissions (functional), and data scopes (data-level authorization).

### Features Implemented

1. **Permission Value Object** (`role.go`)
   - `Permission` struct with Code, Resource, Action, Description
   - Code format: `resource:action` (e.g., `product:create`)
   - Factory functions: `NewPermission`, `NewPermissionFromCode`, `NewPermissionWithDescription`
   - Validation: Resource/action must start with letter, contain only lowercase letters, numbers, underscores

2. **DataScope Value Object** (`role.go`)
   - `DataScope` struct with Resource, ScopeType, ScopeValues, Description
   - `DataScopeType` enum: `all`, `self`, `department`, `custom`
   - Factory functions: `NewDataScope`, `NewCustomDataScope`
   - Custom scopes support arbitrary scope values for flexible filtering

3. **Role Aggregate Root** (`role.go`)
   - `Role` struct with TenantAggregateRoot (multi-tenant support)
   - Code validation (2-50 chars, alphanumeric + underscore, starts with letter)
   - Name validation (1-100 chars)
   - System role flag (`IsSystemRole` - cannot be deleted)
   - Enable/disable status with domain events

4. **Permission Management**
   - `GrantPermission(perm)` - Add permission with event
   - `GrantPermissionByCode(code)` - Add by code string
   - `RevokePermission(code)` - Remove permission with event
   - `SetPermissions(permissions)` - Replace all (with deduplication)
   - `HasPermission(code)` - Check if role has permission
   - `HasPermissionForResource(resource)` - Check resource-level access
   - `GetPermissionsForResource(resource)` - List all actions for resource

5. **DataScope Management**
   - `SetDataScope(ds)` - Set/update scope for resource (replaces if exists)
   - `RemoveDataScope(resource)` - Remove scope for resource
   - `SetDataScopes(scopes)` - Replace all (deduplicated by resource)
   - `GetDataScope(resource)` - Get scope for resource
   - `HasDataScope(resource)` - Check if scope exists

6. **Domain Events** (`role_events.go`)
   - `RoleCreatedEvent` - When role is created
   - `RoleUpdatedEvent` - When role is updated
   - `RoleDeletedEvent` - When role is deleted
   - `RoleEnabledEvent` - When role is enabled
   - `RoleDisabledEvent` - When role is disabled
   - `RolePermissionGrantedEvent` - When permission granted
   - `RolePermissionRevokedEvent` - When permission revoked
   - `RoleDataScopeChangedEvent` - When data scope changes
   - `RoleUsersChangedEvent` - When users assigned to role change

7. **RoleRepository Interface** (`role_repository.go`)
   - Standard CRUD operations
   - `FindByCode` - Find by tenant + code
   - `FindAll` with `RoleFilter` (keyword, enabled, system role, pagination)
   - `ExistsByCode`, `ExistsByID` - Existence checks
   - `FindByIDs` - Bulk find
   - `FindSystemRoles` - Get all system roles
   - `SavePermissions`, `LoadPermissions` - Permission persistence
   - `SaveDataScopes`, `LoadDataScopes` - DataScope persistence
   - `FindUsersWithRole`, `CountUsersWithRole` - User-role queries
   - `FindRolesWithPermission` - Find roles by permission

8. **Predefined Constants**
   - Role codes: `ADMIN`, `OWNER`, `MANAGER`, `SALES`, `PURCHASER`, `WAREHOUSE`, `CASHIER`, `ACCOUNTANT`
   - Resources: `product`, `category`, `customer`, `supplier`, `warehouse`, `inventory`, `sales_order`, `purchase_order`, etc.
   - Actions: `create`, `read`, `update`, `delete`, `enable`, `disable`, `confirm`, `cancel`, `ship`, `receive`, `approve`, `reject`, `adjust`, `lock`, `unlock`, `reconcile`, `export`, `import`, `assign_role`, `view_all`

9. **Supporting Entities**
   - `RolePermission` - Many-to-many for role-permission storage
   - `RoleDataScope` - Role data scope configuration storage

### Files Created

- `backend/internal/domain/identity/role.go` - Role aggregate, Permission/DataScope value objects
- `backend/internal/domain/identity/role_events.go` - Role domain events
- `backend/internal/domain/identity/role_repository.go` - Repository interface
- `backend/internal/domain/identity/role_test.go` - Comprehensive unit tests (40+ test cases)

### Also Completed
- **P6-BE-012 (Permission权限模型实现)**: Permission value object with resource:action pattern fully implemented
- Note: P6-BE-013 (DataScope数据权限实现) model is complete, but query-level filtering needs repository implementation

### Build & Test Status
- `go build ./...` ✅ PASSED
- `go test ./internal/domain/identity/...` ✅ PASSED (All tests pass)

### Notes for Next Developer
- **Repository Implementation**: Next step is to implement GORM-based RoleRepository
- **Role Inheritance**: The spec mentions "支持角色继承" but current implementation uses flat permission model. Role inheritance could be added by including parent role references
- **DataScope Query Filtering**: The DataScope model is ready but the actual query filtering logic needs to be implemented in repositories (P6-BE-013 requirement "在查询中应用数据权限")
- **Unique Constraints**: Code should be unique per tenant (enforced at DB level)
- **System Roles**: System roles (`IsSystemRole=true`) cannot be deleted - implement seed data for default system roles
- **Permission Seeding**: Consider implementing a permission seeding mechanism for predefined permissions


## P6-BE-014: JWT 认证中间件 (JWT Authentication Middleware)

**Date**: 2026-01-24
**Status**: ✅ COMPLETED

### Summary
Implemented the JWT authentication middleware for the Identity Context, providing secure token-based authentication with access and refresh token support.

### Features Implemented

1. **JWT Service** (`backend/internal/infrastructure/auth/jwt.go`)
   - `JWTService` struct with configurable access and refresh token settings
   - Access token generation with full user claims (tenant, user, roles, permissions)
   - Refresh token generation with minimal claims for security
   - Token validation with proper error handling
   - Token refresh with rotation and count limiting

2. **Token Types**
   - `TokenTypeAccess` - Short-lived access tokens (default 15 minutes)
   - `TokenTypeRefresh` - Long-lived refresh tokens (default 7 days)
   - Separate secrets support for access and refresh tokens

3. **JWT Claims** (`Claims` struct)
   - Standard JWT claims (issuer, subject, audience, expiry, etc.)
   - Custom claims: TenantID, UserID, Username, RoleIDs, Permissions
   - Token type identification
   - Refresh count tracking for token rotation limits

4. **Token Pair Generation**
   - `GenerateTokenPair()` - Creates both access and refresh tokens
   - `TokenPair` struct with token strings and expiration times
   - Bearer token type for OAuth2 compatibility

5. **Token Validation**
   - `ValidateAccessToken()` - Validates access tokens only
   - `ValidateRefreshToken()` - Validates refresh tokens only
   - Token type checking to prevent cross-use
   - Proper error types: ErrInvalidToken, ErrExpiredToken, ErrInvalidTokenType, etc.

6. **Token Refresh**
   - `RefreshTokenPair()` - Generates new token pair from valid refresh token
   - Increments refresh count for rotation tracking
   - Configurable maximum refresh count (default 10)
   - Updated permissions can be passed during refresh

7. **JWT Authentication Middleware** (`backend/internal/interfaces/http/middleware/jwt.go`)
   - `JWTAuthMiddleware()` - Standard authentication middleware
   - `JWTAuthMiddlewareWithConfig()` - Configurable middleware
   - `OptionalJWTAuthMiddleware()` - Non-blocking auth for optional endpoints
   - Bearer token extraction from Authorization header
   - Automatic skip for public endpoints (health, auth/login, auth/refresh, swagger)

8. **Context Helpers**
   - `GetJWTClaims(c)` - Get full claims from context
   - `GetJWTUserID(c)` - Get user ID from context
   - `GetJWTTenantID(c)` - Get tenant ID from context
   - `GetJWTUsername(c)` - Get username from context
   - `GetJWTRoleIDs(c)` - Get role IDs from context
   - `GetJWTPermissions(c)` - Get permissions from context
   - `MustGetJWTClaims(c)` - Panic-on-missing variant

9. **Claims Helpers**
   - `GetTenantUUID()` - Parse tenant ID as UUID
   - `GetUserUUID()` - Parse user ID as UUID
   - `GetRoleUUIDs()` - Parse role IDs as UUIDs
   - `HasPermission(permission)` - Check single permission
   - `HasAnyPermission(permissions...)` - Check any permission
   - `HasAllPermissions(permissions...)` - Check all permissions

10. **Configuration Enhancement** (`backend/internal/infrastructure/config/config.go`)
    - Extended `JWTConfig` struct with:
      - `AccessTokenExpiration` (duration)
      - `RefreshTokenExpiration` (duration)
      - `Issuer` string
      - `RefreshSecret` (optional separate secret)
      - `MaxRefreshCount` (rotation limit)
    - Environment variables: JWT_ACCESS_TOKEN_EXPIRATION, JWT_REFRESH_TOKEN_EXPIRATION, JWT_ISSUER, JWT_REFRESH_SECRET, JWT_MAX_REFRESH_COUNT

11. **Error Handling**
    - Proper HTTP status codes (401 Unauthorized)
    - Specific error codes: UNAUTHORIZED, TOKEN_EXPIRED, INVALID_TOKEN, INVALID_TOKEN_TYPE, TOKEN_NOT_VALID
    - Custom error handler support via `OnError` callback

### Files Created/Modified

- `backend/internal/infrastructure/auth/jwt.go` - JWT service implementation
- `backend/internal/infrastructure/auth/jwt_test.go` - Comprehensive unit tests (23 test cases)
- `backend/internal/interfaces/http/middleware/jwt.go` - JWT authentication middleware
- `backend/internal/interfaces/http/middleware/jwt_test.go` - Middleware tests (27 test cases)
- `backend/internal/infrastructure/config/config.go` - Extended JWTConfig
- `backend/go.mod` - Added github.com/golang-jwt/jwt/v5

### Build & Test Status
- `go build ./...` ✅ PASSED
- `go test ./internal/infrastructure/auth/...` ✅ PASSED (23 tests)
- `go test ./internal/interfaces/http/middleware/...` ✅ PASSED (27 JWT tests + existing tests)

### Integration with Existing Components
- Integrates with existing TenantMiddleware (JWT claims provide tenant_id)
- Uses existing logger infrastructure for context logging
- Compatible with existing response format patterns

### Notes for Next Developer
- **P6-BE-015 (权限校验中间件)**: Permission checking middleware should use the Claims.HasPermission() methods
- **P6-BE-016 (Auth API)**: Auth handlers should use JWTService for token generation and UserRepository for authentication
- **Token Blacklisting**: For logout functionality, consider implementing a Redis-based token blacklist
- **Refresh Token Storage**: For production, consider storing refresh tokens in database for revocation capability
- **Rate Limiting**: Consider rate limiting the refresh endpoint to prevent abuse
- **Password Hash**: User.VerifyPassword() from identity domain already handles bcrypt comparison

---

## P6-BE-015: Permission Validation Middleware (权限校验中间件)

**Date**: 2026-01-24
**Status**: COMPLETED ✅

### Implementation Summary

Implemented comprehensive permission validation middleware that integrates with the existing JWT authentication system to provide role-based access control (RBAC) for API routes.

### Components Implemented

1. **RequirePermission Middleware** (`backend/internal/interfaces/http/middleware/permission.go`)
   - `RequirePermission(permission)` - Requires a single permission
   - `RequireAnyPermission(permissions...)` - Requires any one of the permissions
   - `RequireAllPermissions(permissions...)` - Requires all specified permissions

2. **Resource-Based Permission Middleware**
   - `RequireResource(resource)` - Auto-maps HTTP methods to actions:
     - GET → `resource:read`
     - POST → `resource:create`
     - PUT/PATCH → `resource:update`
     - DELETE → `resource:delete`
   - `RequireResourceAction(resource, action)` - Explicit resource:action check

3. **Route-Based Permission Middleware**
   - `RoutePermissionMiddleware(cfg)` - Centralized route permission configuration
   - Supports exact path matching and prefix matching (with `*`)
   - Supports wildcard method matching (`*`)
   - `RequireAll` option for AND logic (default is OR)
   - `DefaultDeny` option for secure-by-default routes

4. **Custom Permission Middleware**
   - `RequireCustomPermission(checkFunc)` - For complex permission logic
   - Callback receives `*auth.Claims` and `*gin.Context`

5. **Helper Functions**
   - `HasPermission(c, permission)` - Check single permission in handlers
   - `HasAnyPermission(c, permissions...)` - Check any permission
   - `HasAllPermissions(c, permissions...)` - Check all permissions
   - `MustHavePermission(c, permission)` - Abort if no permission

6. **Configuration Options**
   - `PermissionConfig` with Logger and OnDenied callback
   - `RoutePermissionConfig` with Routes, Logger, DefaultDeny, OnDenied

### Error Response Format

Permission denied returns HTTP 403 Forbidden with standardized error:
```json
{
  "success": false,
  "error": {
    "code": "ERR_FORBIDDEN",
    "message": "Access denied: insufficient permissions"
  }
}
```

### Usage Examples

```go
// Single permission
router.GET("/products", RequirePermission("product:read"), handler)

// Any of multiple permissions
router.POST("/orders", RequireAnyPermission("order:create", "admin:all"), handler)

// All permissions required
router.DELETE("/users/:id", RequireAllPermissions("user:delete", "admin:access"), handler)

// Resource-based (auto-maps method to action)
products := router.Group("/products", RequireResource("product"))
products.GET("/", listHandler)      // Requires product:read
products.POST("/", createHandler)   // Requires product:create
products.PUT("/:id", updateHandler) // Requires product:update

// Route-based configuration
cfg := RoutePermissionConfig{
    Routes: []RoutePermission{
        {Method: "GET", Path: "/api/v1/products*", Permissions: []string{"product:read"}},
        {Method: "*", Path: "/api/v1/admin/*", Permissions: []string{"admin:access"}, RequireAll: true},
    },
    DefaultDeny: true,
    Logger: logger,
}
router.Use(RoutePermissionMiddleware(cfg))

// Custom permission logic
router.GET("/custom", RequireCustomPermission(func(claims *auth.Claims, c *gin.Context) bool {
    // Check ownership, time-based access, etc.
    resourceID := c.Param("id")
    return claims.UserID == resourceID || claims.HasPermission("admin:all")
}), handler)
```

### Files Created/Modified

- `backend/internal/interfaces/http/middleware/permission.go` - Main implementation
- `backend/internal/interfaces/http/middleware/permission_test.go` - Comprehensive tests (30 test cases)

### Build & Test Status
- `go build ./...` ✅ PASSED
- `go test ./internal/interfaces/http/middleware/...` ✅ PASSED (30 permission tests + existing tests)

### Integration with Existing Components
- Integrates with JWT middleware (`GetJWTClaims`)
- Uses `auth.Claims.HasPermission()`, `HasAnyPermission()`, `HasAllPermissions()`
- Uses standardized error format from `dto/errors.go`
- Uses `ERR_FORBIDDEN` error code

### Notes for Next Developer
- **P6-BE-016 (Auth API)**: Login handler should use `JWTService.GenerateTokenPair()` with permissions loaded from user's roles
- **Route Registration**: When registering routes with permission requirements, prefer `RequireResource()` for standard CRUD operations
- **Admin Override**: Consider implementing an admin permission (e.g., `admin:all`) that bypasses all permission checks
- **Caching**: For high-traffic applications, consider caching permission checks with Redis
- **Audit Logging**: The `PermissionConfig.OnDenied` callback can be used to log unauthorized access attempts

---

## P6-BE-016: Auth API (登录/登出/刷新)

### Date: 2026-01-24

### Completion Status: ✅ COMPLETED

### Requirements Fulfilled
1. ✅ 实现登录 API - Login endpoint with password verification, account locking, and token generation
2. ✅ 实现登出 API - Logout endpoint that invalidates the current session
3. ✅ 实现 Token 刷新 API - Token refresh endpoint with refresh count tracking

### Implementation Details

#### Application Layer - Auth Service (`backend/internal/application/identity/`)

**auth_service.go** - Core authentication service with:
- `Login()` - Authenticates user with username/password, tracks login attempts, locks account after max failures
- `RefreshToken()` - Validates refresh token and generates new token pair
- `Logout()` - Invalidates current session (can be extended for token blacklisting)
- `GetCurrentUser()` - Returns authenticated user's full profile with permissions
- `ChangePassword()` - Changes user password with old password verification

**dto.go** - Data transfer objects:
- `LoginInput`, `LoginResult` - Login request/response
- `RefreshTokenInput`, `RefreshTokenResult` - Token refresh request/response
- `LogoutInput`, `ChangePasswordInput` - Other operation inputs
- `GetCurrentUserInput`, `CurrentUserResult` - Current user profile
- `UserInfo` - User information with permissions

#### HTTP Layer - Auth Handler (`backend/internal/interfaces/http/handler/`)

**auth.go** - HTTP handlers with Swagger documentation:
- `POST /auth/login` - User login (public)
- `POST /auth/refresh` - Token refresh (public)
- `POST /auth/logout` - User logout (authenticated)
- `GET /auth/me` - Get current user (authenticated)
- `PUT /auth/password` - Change password (authenticated)

**auth_dto.go** - HTTP request/response DTOs:
- `LoginRequest`, `RefreshTokenRequest`, `ChangePasswordRequest`
- `TokenResponse`, `AuthUserResponse`, `LoginResponse`, `RefreshTokenResponse`, etc.

### Security Features

1. **Account Locking**: After configurable max login attempts (default: 5), account is locked for a configurable duration (default: 15 minutes)
2. **Password Verification**: Uses bcrypt for secure password hashing
3. **Token Pair**: Separate access token (short-lived) and refresh token (long-lived)
4. **Refresh Count Tracking**: Tokens include refresh count to limit total refreshes
5. **IP Tracking**: Login records client IP address

### Auth Service Configuration

```go
type AuthServiceConfig struct {
    MaxLoginAttempts     int           // Default: 5
    LockDuration         time.Duration // Default: 15 minutes
    SessionTimeout       time.Duration // Default: 24 hours
    PasswordMinLength    int           // Default: 8
    RequirePasswordReset bool          // Default: false
}
```

### API Endpoints

```
POST /api/v1/auth/login
  Request: { "username": "string", "password": "string" }
  Response: { "token": {...}, "user": {...} }

POST /api/v1/auth/refresh
  Request: { "refresh_token": "string" }
  Response: { "token": {...} }

POST /api/v1/auth/logout (requires JWT)
  Response: { "message": "Logged out successfully" }

GET /api/v1/auth/me (requires JWT)
  Response: { "user": {...}, "permissions": [...] }

PUT /api/v1/auth/password (requires JWT)
  Request: { "old_password": "string", "new_password": "string" }
  Response: { "message": "Password changed successfully" }
```

### Files Created/Modified

- `backend/internal/application/identity/dto.go` - Auth DTOs
- `backend/internal/application/identity/auth_service.go` - Auth service implementation
- `backend/internal/application/identity/auth_service_test.go` - Auth service tests (13 tests)
- `backend/internal/interfaces/http/handler/auth_dto.go` - HTTP DTOs
- `backend/internal/interfaces/http/handler/auth.go` - HTTP handlers
- `backend/internal/interfaces/http/handler/auth_test.go` - Handler tests (7 tests)

### Build & Test Status
- `go build ./...` ✅ PASSED
- `go test ./internal/application/identity/...` ✅ PASSED (13 auth service tests)
- `go test ./internal/interfaces/http/handler/...` ✅ PASSED (7 handler tests)

### Test Coverage

**Auth Service Tests (13 tests)**:
- Login success, invalid credentials, user not found, locked account, deactivated account
- RefreshToken success, invalid token, user not found
- GetCurrentUser success
- ChangePassword success, wrong old password
- Logout success
- Account locks after max attempts

**Handler Tests (7 tests)**:
- Login success, invalid request body
- RefreshToken success
- Logout success, unauthorized
- GetCurrentUser success
- ChangePassword success

### Integration Notes

- Uses existing JWT infrastructure from P6-BE-014
- Uses existing User/Role domain models from P6-BE-010/P6-BE-011
- Integrates with permission middleware from P6-BE-015
- Follows existing handler patterns (BaseHandler, dto.Response)

### Next Steps for Integration
- **Route Registration**: Register auth routes in the main router setup
- **Route Security**: Login and refresh should be public; logout, me, password require JWT
- **OpenAPI Spec**: Run `swag init` to generate updated Swagger docs
- **Frontend**: Generate SDK using `npm run api:generate`

---

## P6-FE-001: 登录页面 (Login Page)

**Date**: 2026-01-24
**Status**: COMPLETED ✅

### Summary
Implemented the login page with real API integration, replacing the mock login implementation.

### Implementation Details

#### Auth API Service (`frontend/src/api/auth/`)

Created a new auth API module with the following files:

**types.ts** - TypeScript interfaces matching backend DTOs:
- `LoginRequest`, `RefreshTokenRequest`, `ChangePasswordRequest`
- `TokenResponse`, `AuthUserResponse`, `LoginResponse`
- `RefreshTokenResponse`, `CurrentUserResponse`, `LogoutResponse`
- `ApiResponse<T>` wrapper interface

**auth.ts** - Auth API service with methods:
- `postAuthLogin(loginRequest)` - User login
- `postAuthRefresh(refreshTokenRequest)` - Token refresh
- `postAuthLogout()` - User logout
- `getAuthMe()` - Get current user info
- `putAuthPassword(changePasswordRequest)` - Change password

**index.ts** - Re-exports for clean imports

#### Login Page Updates (`frontend/src/pages/Login.tsx`)

- Integrated with `authApi.postAuthLogin()` instead of mock data
- Added proper form validation:
  - Username: required, min 3 chars, max 100 chars
  - Password: required, min 8 chars, max 128 chars
- Added error handling with specific error codes:
  - `INVALID_CREDENTIALS` - Invalid username or password
  - `ACCOUNT_LOCKED` - Account is locked
  - `ACCOUNT_DISABLED/DEACTIVATED` - Account is disabled
  - `USER_NOT_FOUND` - User not found
- Added error banner display for login failures
- Disabled form inputs during loading state
- Used design system tokens (--spacing-4, --spacing-6, etc.)

### Requirements Fulfilled

1. ✅ **实现登录表单** - Login form implemented with Semi Design Form component
2. ✅ **实现表单验证** - Form validation for username (3-100 chars) and password (8-128 chars)
3. ✅ **处理登录错误** - Comprehensive error handling with user-friendly messages

### Build & Test Status
- `npm run build` ✅ PASSED
- `npx tsc --noEmit` ✅ PASSED (TypeScript check)

### Files Created/Modified
- `frontend/src/api/auth/types.ts` (NEW)
- `frontend/src/api/auth/auth.ts` (NEW)
- `frontend/src/api/auth/index.ts` (NEW)
- `frontend/src/pages/Login.tsx` (MODIFIED)

### Notes for Next Steps
- **P6-FE-002**: Token storage is already partially implemented in `authStore.ts`. Need to add automatic token refresh logic.
- **P6-FE-003**: Route permission control - implement route guards that check permissions from auth store.
- The auth API module can be regenerated using orval once the backend swagger docs are updated.


---

## P6-FE-002: Token 存储与刷新逻辑 (Token Storage & Refresh Logic)

**Date**: 2026-01-24
**Status**: COMPLETED ✅

### Summary
Implemented comprehensive token storage and automatic refresh logic for JWT authentication.

### Implementation Details

#### Token Refresh Service (`frontend/src/services/token-refresh.ts`)

Created a complete token refresh service with the following features:

**JWT Token Utilities:**
- `getTokenExpiration(token)` - Decode JWT to get expiration timestamp
- `isTokenExpired(token)` - Check if token needs refresh (1 min buffer)
- `isTokenCompletelyExpired(token)` - Check if token is past expiration
- `getTimeUntilExpiry(token)` - Get milliseconds until expiration

**Refresh Logic:**
- `refreshAccessToken()` - Singleton pattern to prevent multiple simultaneous refresh requests
- `performRefresh(refreshToken)` - Makes the actual API call to /auth/refresh
- Queues concurrent requests and serves them with the new token

**Auto-Refresh System:**
- `setupAutoRefresh()` - Sets up a timer to refresh before token expires
- Subscribes to auth store changes to re-schedule on token updates
- Returns cleanup function for proper React lifecycle management

**Redirect Handling:**
- `redirectToLogin(message?)` - Redirects to login with optional message
- Stores redirect path in sessionStorage for post-login navigation

#### Axios Interceptor Updates (`frontend/src/services/axios-instance.ts`)

Enhanced the axios instance with:

**Request Interceptor:**
- Checks token expiration BEFORE making requests
- If token expired, waits for refresh or triggers one
- Skips auth for public URLs (/auth/login, /auth/refresh)

**Response Interceptor:**
- Handles 401 responses with automatic token refresh
- Queues failed requests during refresh, then retries with new token
- Prevents infinite retry loops with `_retry` flag
- Clears auth state and redirects on refresh failure

#### Auth Provider Component (`frontend/src/components/auth/AuthProvider.tsx`)

Created a provider component that:
- Initializes auth state from localStorage on app mount
- Sets up automatic token refresh when user is authenticated
- Displays session expired messages from redirect
- Properly cleans up refresh timers on unmount

**Helper exports:**
- `useAuthRedirectPath()` - Get path user was trying to access before redirect
- `clearAuthRedirectPath()` - Clear stored path after successful navigation

#### Updated Main Entry (`frontend/src/main.tsx`)

Wrapped RouterProvider with AuthProvider:
```tsx
<AuthProvider>
  <RouterProvider router={router} />
</AuthProvider>
```

### Requirements Fulfilled

1. ✅ **实现 Token 存储** - Token storage in localStorage (via existing authStore) + sessionStorage for redirect state
2. ✅ **实现自动刷新** - Automatic refresh before token expiration with 1-minute buffer
3. ✅ **处理 Token 过期** - Graceful handling with redirect to login and message display

### Key Design Decisions

1. **Singleton Refresh Pattern**: Prevents race conditions when multiple API calls fail simultaneously
2. **Proactive Refresh**: Refreshes 1 minute before expiration, not after failure
3. **Request Queuing**: Failed requests are queued during refresh and retried with new token
4. **Clean Logout Flow**: Clears all auth state and redirects with informative message
5. **React Integration**: AuthProvider properly manages timers with useEffect cleanup

### Build & Test Status
- `npm run build` ✅ PASSED
- `npx tsc --noEmit` ✅ PASSED (TypeScript check)

### Files Created/Modified
- `frontend/src/services/token-refresh.ts` (NEW) - Token refresh service
- `frontend/src/services/axios-instance.ts` (MODIFIED) - Enhanced interceptors
- `frontend/src/services/index.ts` (MODIFIED) - Export token utilities
- `frontend/src/components/auth/AuthProvider.tsx` (NEW) - Auth provider component
- `frontend/src/components/auth/index.ts` (NEW) - Component exports
- `frontend/src/main.tsx` (MODIFIED) - Wrapped with AuthProvider

### Notes for Next Steps
- **P6-FE-003**: Route permission control can now use `isAuthenticated` from authStore
- Token refresh is handled transparently - API calls will automatically retry with new tokens
- The AuthProvider ensures auth state is initialized before any protected route renders

---

## P6-FE-003: 路由权限控制 (Route Permission Control)

**Date**: 2026-01-24
**Status**: COMPLETED ✅

### Summary
Implemented comprehensive route permission control system that filters menu items based on user permissions and redirects unauthorized users to a 403 page.

### Implementation Details

#### Permission Configuration (`frontend/src/config/permissions.ts`)

Created a centralized permission configuration file:

**Resource & Action Constants:**
- Defined all resources (product, customer, inventory, etc.)
- Defined all actions (create, read, update, delete, etc.)
- Helper function `createPermission(resource, action)` for generating codes

**Predefined Permission Codes:**
- Complete set of permission codes matching backend definitions
- Format: `resource:action` (e.g., `product:create`, `sales_order:read`)

**Route Permission Mappings:**
- `RoutePermissions` record mapping paths to required permissions
- `hasRouteAccess(userPermissions, routePath)` - Check access by permissions

#### Route Metadata Updates (`frontend/src/router/routes.tsx`)

Added `permissions` array to route metadata:

```typescript
{
  path: '/catalog',
  meta: {
    title: 'Catalog',
    permissions: [Permissions.PRODUCT_READ, Permissions.CATEGORY_READ],
  },
  children: [
    {
      path: '/catalog/products',
      meta: {
        permissions: [Permissions.PRODUCT_READ],
      },
    },
  ],
}
```

Each module and child route now has appropriate permission requirements.

#### Sidebar Menu Filtering (`frontend/src/components/layout/Sidebar.tsx`)

Enhanced menu generation to filter by user permissions:

**New `hasRoutePermission` function:**
- Returns true if no permissions required
- Returns false if user has no permissions but route requires them
- Checks if user has ANY of the required permissions

**Updated `routeToNavItem` function:**
- Now accepts `userPermissions` parameter
- Filters out routes user cannot access
- Hides parent menus if all children are filtered out

**Updated `Sidebar` component:**
- Reads `user?.permissions` from auth store
- Passes permissions to nav item generation
- Menu updates reactively when user permissions change

#### Enhanced Auth Guard (`frontend/src/router/guards.tsx`)

Improved route guard with automatic permission detection:

**New `findRoutePermissions` function:**
- Finds permissions for exact path match
- Falls back to parent route permissions for dynamic routes
- Falls back to module-level permissions

**Updated `AuthGuard` component:**
- Handles auth loading state (prevents flash of login)
- Stores redirect path in sessionStorage
- Automatically determines required permissions from route config
- Redirects to 403 for unauthorized access

**Updated `GuestGuard` component:**
- Handles auth loading state
- Restores redirect path after login

#### Enhanced 403 Page (`frontend/src/pages/Forbidden.tsx`)

Improved forbidden page with:
- Better visual design with Semi UI components
- Shows attempted URL when available
- "Back to Dashboard" and "Go Back" navigation options
- Proper background color using design tokens

### Requirements Fulfilled

1. ✅ **实现路由守卫** - AuthGuard checks authentication and permissions
2. ✅ **根据权限过滤菜单** - Sidebar filters menu items by user permissions
3. ✅ **处理无权限访问** - 403 page with helpful navigation options

### Key Design Decisions

1. **Centralized Permissions**: All permission codes defined in one file for consistency
2. **ANY Permission Logic**: User needs ANY of the listed permissions (not all) for access
3. **Hierarchical Fallback**: Child routes inherit parent permissions if not specified
4. **Reactive Menu**: Menu updates immediately when user permissions change
5. **Graceful Loading**: Guards wait for auth state before redirecting

### Build & Test Status
- `npm run build` ✅ PASSED
- `npx tsc --noEmit` ✅ PASSED (TypeScript check)

### Files Created/Modified
- `frontend/src/config/permissions.ts` (NEW) - Permission configuration
- `frontend/src/config/index.ts` (NEW) - Config exports
- `frontend/src/router/routes.tsx` (MODIFIED) - Added permissions to routes
- `frontend/src/router/guards.tsx` (MODIFIED) - Enhanced permission checking
- `frontend/src/components/layout/Sidebar.tsx` (MODIFIED) - Permission-filtered menu
- `frontend/src/pages/Forbidden.tsx` (MODIFIED) - Improved 403 page

### Notes for Next Steps
- **P6-FE-004/005/006**: User/Role/Permission management pages can use these permission constants
- **P6-INT-002**: Auth flow integration can verify permission filtering works end-to-end
- Backend API should return user permissions in the login response (already done in P6-BE-016)
- For testing, user permissions should include relevant permission codes from the backend

---

## P6-BE-017: User/Role Management API

### Date: 2026-01-24

### Summary
Implemented complete User and Role management API endpoints that enable frontend to manage users, roles, and their assignments.

### Implementation Details

#### 1. Application Services (`internal/application/identity/`)
- **user_service.go**: UserService with CRUD operations:
  - Create, Get, List, Update, Delete users
  - Activate/Deactivate/Lock/Unlock user accounts
  - Reset password functionality
  - Assign roles to users
  - User count statistics
- **role_service.go**: RoleService with CRUD operations:
  - Create, Get, List, Update, Delete roles
  - Enable/Disable roles
  - Set permissions for roles
  - Get system roles and permission codes
  - Role count statistics

#### 2. Repository Implementations (`internal/infrastructure/persistence/`)
- **user_repository.go**: GormUserRepository implementing UserRepository interface:
  - FindByID, FindByUsername, FindByEmail, FindAll
  - Create, Update, Delete
  - SaveUserRoles, LoadUserRoles
  - ExistsByUsername, ExistsByEmail
  - CountUsersWithRole
- **role_repository.go**: GormRoleRepository implementing RoleRepository interface:
  - FindByID, FindByCode, FindAll, FindByIDs
  - Create, Update, Delete
  - SavePermissions, LoadPermissions
  - SaveDataScopes, LoadDataScopes
  - GetAllPermissionCodes, FindRolesWithPermission
  - CountUsersWithRole

#### 3. HTTP Handlers (`internal/interfaces/http/handler/`)
- **user_role_dto.go**: Request/Response DTOs for User and Role APIs
- **user.go**: UserHandler with 12 endpoints
- **role.go**: RoleHandler with 13 endpoints

#### 4. Route Registration (`cmd/server/main.go`)
- Added identity domain repositories and services initialization
- Registered auth routes (public): `/api/v1/auth/login`, `/api/v1/auth/refresh`
- Registered identity routes (protected):
  - Auth: `/api/v1/identity/auth/logout`, `/api/v1/identity/auth/me`, `/api/v1/identity/auth/password`
  - Users: `/api/v1/identity/users/*` (CRUD, activate, deactivate, lock, unlock, reset-password, roles)
  - Roles: `/api/v1/identity/roles/*` (CRUD, enable, disable, permissions)
  - Permissions: `/api/v1/identity/permissions`

### API Endpoints

#### User Management
- `POST /api/v1/identity/users` - Create user
- `GET /api/v1/identity/users` - List users with filtering/pagination
- `GET /api/v1/identity/users/:id` - Get user by ID
- `PUT /api/v1/identity/users/:id` - Update user
- `DELETE /api/v1/identity/users/:id` - Delete user
- `POST /api/v1/identity/users/:id/activate` - Activate user
- `POST /api/v1/identity/users/:id/deactivate` - Deactivate user
- `POST /api/v1/identity/users/:id/lock` - Lock user account
- `POST /api/v1/identity/users/:id/unlock` - Unlock user account
- `POST /api/v1/identity/users/:id/reset-password` - Reset user password
- `PUT /api/v1/identity/users/:id/roles` - Assign roles to user
- `GET /api/v1/identity/users/stats/count` - Get user count

#### Role Management
- `POST /api/v1/identity/roles` - Create role
- `GET /api/v1/identity/roles` - List roles with filtering/pagination
- `GET /api/v1/identity/roles/:id` - Get role by ID
- `GET /api/v1/identity/roles/code/:code` - Get role by code
- `PUT /api/v1/identity/roles/:id` - Update role
- `DELETE /api/v1/identity/roles/:id` - Delete role
- `POST /api/v1/identity/roles/:id/enable` - Enable role
- `POST /api/v1/identity/roles/:id/disable` - Disable role
- `PUT /api/v1/identity/roles/:id/permissions` - Set role permissions
- `GET /api/v1/identity/roles/system` - Get system roles
- `GET /api/v1/identity/roles/stats/count` - Get role count
- `GET /api/v1/identity/permissions` - Get all available permissions

### Build Status
- `go build ./...` ✅ PASSED

### Known Issues
- Swagger/OpenAPI spec generation fails due to pre-existing issue in report.go (reportapp types not resolvable by swag). This is not related to P6-BE-017 changes.

### Files Created/Modified
- `backend/internal/application/identity/user_service.go` (NEW)
- `backend/internal/application/identity/role_service.go` (NEW)
- `backend/internal/infrastructure/persistence/user_repository.go` (NEW)
- `backend/internal/infrastructure/persistence/role_repository.go` (NEW)
- `backend/internal/interfaces/http/handler/user_role_dto.go` (NEW)
- `backend/internal/interfaces/http/handler/user.go` (NEW)
- `backend/internal/interfaces/http/handler/role.go` (NEW)
- `backend/internal/interfaces/http/dto/response.go` (MODIFIED) - Added MessageResponse
- `backend/cmd/server/main.go` (MODIFIED) - Added identity routes

### Notes for Next Steps
- **P6-FE-004**: User management page can now use `/api/v1/identity/users/*` endpoints
- **P6-FE-005**: Role management page can now use `/api/v1/identity/roles/*` endpoints
- **P6-FE-006**: Permission assignment page can use `/api/v1/identity/roles/:id/permissions` and `/api/v1/identity/permissions`
- **Swagger Fix**: The report.go swagger annotations need to be fixed separately (use full paths or local types instead of aliased imports)

---

## 2026-01-24: P6-FE-004 - 用户管理页面

### Summary
Implemented the User Management page frontend that allows administrators to manage system users, including CRUD operations, status management, role assignment, and password reset.

### Implementation Details

#### 1. API Client (`frontend/src/api/identity/`)
- **types.ts**: TypeScript type definitions matching backend DTOs:
  - User types (User, UserStatus, CreateUserRequest, UpdateUserRequest)
  - Role types (Role, CreateRoleRequest, UpdateRoleRequest)
  - Query and response types with pagination support
  
- **identity.ts**: API service factory with methods for:
  - User CRUD: createUser, getUser, listUsers, updateUser, deleteUser
  - User status: activateUser, deactivateUser, lockUser, unlockUser
  - Password management: resetPassword
  - Role assignment: assignRoles
  - Role CRUD: createRole, getRole, listRoles, updateRole, deleteRole
  - Role status: enableRole, disableRole
  - Permission management: setRolePermissions, getAllPermissions

#### 2. User Management Page (`frontend/src/pages/system/Users.tsx`)
Features implemented:
- User list with pagination and filtering (search, status, role)
- Create user modal with form validation
- Edit user modal for updating user details
- Status management actions (activate/deactivate/lock/unlock)
- Password reset with random password generation
- Role assignment modal with checkbox selection
- Bulk actions (bulk activate, bulk deactivate)
- Table sorting and row selection

#### 3. Route Configuration Updates
- Added `/system` module to `appRoutes` in `routes.tsx`
- Added `/system/users` route with USER_READ permission
- Updated `permissions.ts` with system module route permissions
- Added lazy-loaded `UsersPage` component

### API Endpoints Used
- `GET /identity/users` - List users with filtering
- `POST /identity/users` - Create user
- `GET /identity/users/:id` - Get user by ID
- `PUT /identity/users/:id` - Update user
- `DELETE /identity/users/:id` - Delete user
- `POST /identity/users/:id/activate` - Activate user
- `POST /identity/users/:id/deactivate` - Deactivate user
- `POST /identity/users/:id/lock` - Lock user
- `POST /identity/users/:id/unlock` - Unlock user
- `POST /identity/users/:id/reset-password` - Reset password
- `PUT /identity/users/:id/roles` - Assign roles
- `GET /identity/roles` - List roles (for filter and assignment)

### Build Status
- TypeScript check: ✅ PASSED
- Vite build: ✅ PASSED

### Files Created
- `frontend/src/api/identity/types.ts`
- `frontend/src/api/identity/identity.ts`
- `frontend/src/api/identity/index.ts`
- `frontend/src/pages/system/Users.tsx`
- `frontend/src/pages/system/Users.css`

### Files Modified
- `frontend/src/router/routes.tsx` - Added system module routes
- `frontend/src/config/permissions.ts` - Added system route permissions

### Notes for Next Steps
- **P6-FE-005**: Role management page can reuse the identity API client
- **P6-FE-006**: Permission configuration page will use setRolePermissions and getAllPermissions APIs
- The Users page includes role assignment which partially addresses user-role management

---

## 2026-01-24: P6-FE-005 - 角色管理页面

### Summary
Implemented the Role Management page frontend that allows administrators to manage system roles, including CRUD operations, status management, and permission configuration.

### Implementation Details

#### 1. Role Management Page (`frontend/src/pages/system/Roles.tsx`)
Features implemented:
- Role list with pagination and filtering (search, status, type)
- Create role modal with form validation
- Edit role modal for updating role details (name, description, sort order)
- Status management actions (enable/disable)
- Permission configuration modal with tree-based permission selection
- Role detail view modal showing all role information and permissions
- Protection for system roles (cannot edit/disable/delete)
- Readable permission labels in Chinese (e.g., "查看商品" instead of "product:read")

#### 2. Permission Configuration Features
- Tree-based permission selection grouped by resource
- Select all / clear all buttons
- Resource and action labels translated to Chinese
- Warning banner for system role permission modifications
- Real-time count of selected permissions

#### 3. Route Configuration Updates
- Added `/system/roles` route to `routes.tsx`
- Added `RolesPage` lazy-loaded component
- Added route element mapping for `/system/roles`
- Updated `permissions.ts` with `/system/roles` route permission (ROLE_READ)

### API Endpoints Used
- `GET /identity/roles` - List roles with filtering
- `POST /identity/roles` - Create role
- `GET /identity/roles/:id` - Get role by ID
- `PUT /identity/roles/:id` - Update role
- `DELETE /identity/roles/:id` - Delete role
- `POST /identity/roles/:id/enable` - Enable role
- `POST /identity/roles/:id/disable` - Disable role
- `PUT /identity/roles/:id/permissions` - Set role permissions
- `GET /identity/permissions` - Get all available permissions

### Build Status
- TypeScript check: ✅ PASSED
- Vite build: ✅ PASSED

### Files Created
- `frontend/src/pages/system/Roles.tsx`
- `frontend/src/pages/system/Roles.css`

### Files Modified
- `frontend/src/router/routes.tsx` - Added roles route and component
- `frontend/src/config/permissions.ts` - Added /system/roles route permission

### Notes for Next Steps
- **P6-FE-006**: Permission configuration page is largely covered by the permission modal in Roles.tsx. May only need a dedicated page if more advanced permission tree viewing is required.
- The Roles page provides full permission management through the "配置权限" action.
- System roles are protected from modification but their permissions can still be viewed.

---

## 2026-01-24: P6-FE-006 - 权限配置页面

### Summary
Implemented the Permission Configuration page frontend that provides a read-only view of all system permissions, showing permission tree structure and which roles have which permissions.

### Implementation Details

#### 1. Permission Configuration Page (`frontend/src/pages/system/Permissions.tsx`)
Features implemented:
- Display all system permissions in a hierarchical tree view grouped by resource
- Show statistics: total resources, total permissions, and enabled roles
- Search/filter permissions by keyword (matches permission code, resource name, or action name)
- Expand/collapse all functionality for the permission tree
- Display which roles have each permission (with overflow handling for many roles)
- Role-Permission summary collapse panel showing all roles and their permission counts
- Info banner explaining this is a read-only view and directing users to Roles page for modifications

#### 2. Permission Tree Display
- Resources displayed as parent nodes with permission counts and role counts
- Action permissions displayed as child nodes with:
  - Chinese action labels
  - Permission code in monospace font
  - Tooltip with action description
  - Tags showing which roles have this permission

#### 3. Route Configuration Updates
- Added `/system/permissions` route to `routes.tsx`
- Added `PermissionsPage` lazy-loaded component
- Updated `permissions.ts` with `/system/permissions` route permission (ROLE_READ)

### API Endpoints Used
- `GET /identity/permissions` - Get all available permissions
- `GET /identity/roles` - List roles with their permissions

### Build Status
- TypeScript check: ✅ PASSED
- Vite build: ✅ PASSED

### Files Created
- `frontend/src/pages/system/Permissions.tsx`
- `frontend/src/pages/system/Permissions.css`

### Files Modified
- `frontend/src/router/routes.tsx` - Added permissions route and component
- `frontend/src/config/permissions.ts` - Added /system/permissions route permission

### Notes for Next Steps
- **P6-FE-007**: Tenant switching component (low priority)
- The System module now has complete User, Role, and Permission management pages
- The permission configuration page is read-only; actual permission modifications are done through the Role Management page's "配置权限" action

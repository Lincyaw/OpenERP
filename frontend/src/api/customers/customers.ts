/**
 * // This file is auto-generated by orval
 * // Do not edit manually
 *
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  ActivateCustomerBody,
  AddCustomerBalanceBody,
  CreateCustomerBody,
  DeactivateCustomerBody,
  DeductCustomerBalanceBody,
  DtoErrorResponse,
  HandlerAPIResponseArrayHandlerCustomerListResponse,
  HandlerAPIResponseHandlerCustomerCountByStatusResponse,
  HandlerAPIResponseHandlerCustomerResponse,
  ListCustomersParams,
  SetCustomerLevelBody,
  SuspendCustomerBody,
  UpdateCustomerBody,
  UpdateCustomerCodeBody,
} from '.././models'

import { customInstance } from '../../services/axios-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Retrieve a paginated list of customers with optional filtering
 * @summary List customers
 */
export type listCustomersResponse200 = {
  data: HandlerAPIResponseArrayHandlerCustomerListResponse
  status: 200
}

export type listCustomersResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listCustomersResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listCustomersResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listCustomersResponseSuccess = listCustomersResponse200 & {
  headers: Headers
}
export type listCustomersResponseError = (
  | listCustomersResponse400
  | listCustomersResponse401
  | listCustomersResponse500
) & {
  headers: Headers
}

export type listCustomersResponse = listCustomersResponseSuccess | listCustomersResponseError

export const getListCustomersUrl = (params?: ListCustomersParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/partner/customers?${stringifiedParams}`
    : `/partner/customers`
}

export const listCustomers = async (
  params?: ListCustomersParams,
  options?: RequestInit
): Promise<listCustomersResponse> => {
  return customInstance<listCustomersResponse>(getListCustomersUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getListCustomersQueryKey = (params?: ListCustomersParams) => {
  return [`/partner/customers`, ...(params ? [params] : [])] as const
}

export const getListCustomersQueryOptions = <
  TData = Awaited<ReturnType<typeof listCustomers>>,
  TError = DtoErrorResponse,
>(
  params?: ListCustomersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomers>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListCustomersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listCustomers>>> = ({ signal }) =>
    listCustomers(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listCustomers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListCustomersQueryResult = NonNullable<Awaited<ReturnType<typeof listCustomers>>>
export type ListCustomersQueryError = DtoErrorResponse

export function useListCustomers<
  TData = Awaited<ReturnType<typeof listCustomers>>,
  TError = DtoErrorResponse,
>(
  params: undefined | ListCustomersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomers>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCustomers>>,
          TError,
          Awaited<ReturnType<typeof listCustomers>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListCustomers<
  TData = Awaited<ReturnType<typeof listCustomers>>,
  TError = DtoErrorResponse,
>(
  params?: ListCustomersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomers>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCustomers>>,
          TError,
          Awaited<ReturnType<typeof listCustomers>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListCustomers<
  TData = Awaited<ReturnType<typeof listCustomers>>,
  TError = DtoErrorResponse,
>(
  params?: ListCustomersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomers>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List customers
 */

export function useListCustomers<
  TData = Awaited<ReturnType<typeof listCustomers>>,
  TError = DtoErrorResponse,
>(
  params?: ListCustomersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomers>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListCustomersQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Create a new customer in the partner module
 * @summary Create a new customer
 */
export type createCustomerResponse201 = {
  data: HandlerAPIResponseHandlerCustomerResponse
  status: 201
}

export type createCustomerResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type createCustomerResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type createCustomerResponse409 = {
  data: DtoErrorResponse
  status: 409
}

export type createCustomerResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type createCustomerResponseSuccess = createCustomerResponse201 & {
  headers: Headers
}
export type createCustomerResponseError = (
  | createCustomerResponse400
  | createCustomerResponse401
  | createCustomerResponse409
  | createCustomerResponse500
) & {
  headers: Headers
}

export type createCustomerResponse = createCustomerResponseSuccess | createCustomerResponseError

export const getCreateCustomerUrl = () => {
  return `/partner/customers`
}

export const createCustomer = async (
  createCustomerBody: CreateCustomerBody,
  options?: RequestInit
): Promise<createCustomerResponse> => {
  return customInstance<createCustomerResponse>(getCreateCustomerUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createCustomerBody),
  })
}

export const getCreateCustomerMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCustomer>>,
    TError,
    { data: CreateCustomerBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCustomer>>,
  TError,
  { data: CreateCustomerBody },
  TContext
> => {
  const mutationKey = ['createCustomer']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCustomer>>,
    { data: CreateCustomerBody }
  > = (props) => {
    const { data } = props ?? {}

    return createCustomer(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateCustomerMutationResult = NonNullable<Awaited<ReturnType<typeof createCustomer>>>
export type CreateCustomerMutationBody = CreateCustomerBody
export type CreateCustomerMutationError = DtoErrorResponse

/**
 * @summary Create a new customer
 */
export const useCreateCustomer = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCustomer>>,
      TError,
      { data: CreateCustomerBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createCustomer>>,
  TError,
  { data: CreateCustomerBody },
  TContext
> => {
  return useMutation(getCreateCustomerMutationOptions(options), queryClient)
}
/**
 * Delete a customer by ID
 * @summary Delete a customer
 */
export type deleteCustomerResponse204 = {
  data: void
  status: 204
}

export type deleteCustomerResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type deleteCustomerResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type deleteCustomerResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type deleteCustomerResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type deleteCustomerResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type deleteCustomerResponseSuccess = deleteCustomerResponse204 & {
  headers: Headers
}
export type deleteCustomerResponseError = (
  | deleteCustomerResponse400
  | deleteCustomerResponse401
  | deleteCustomerResponse404
  | deleteCustomerResponse422
  | deleteCustomerResponse500
) & {
  headers: Headers
}

export type deleteCustomerResponse = deleteCustomerResponseSuccess | deleteCustomerResponseError

export const getDeleteCustomerUrl = (id: string) => {
  return `/partner/customers/${id}`
}

export const deleteCustomer = async (
  id: string,
  options?: RequestInit
): Promise<deleteCustomerResponse> => {
  return customInstance<deleteCustomerResponse>(getDeleteCustomerUrl(id), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteCustomerMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCustomer>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteCustomer>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteCustomer']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCustomer>>, { id: string }> = (
    props
  ) => {
    const { id } = props ?? {}

    return deleteCustomer(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteCustomerMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCustomer>>>

export type DeleteCustomerMutationError = DtoErrorResponse

/**
 * @summary Delete a customer
 */
export const useDeleteCustomer = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteCustomer>>,
      TError,
      { id: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteCustomer>>,
  TError,
  { id: string },
  TContext
> => {
  return useMutation(getDeleteCustomerMutationOptions(options), queryClient)
}
/**
 * Retrieve a customer by its ID
 * @summary Get customer by ID
 */
export type getCustomerByIdResponse200 = {
  data: HandlerAPIResponseHandlerCustomerResponse
  status: 200
}

export type getCustomerByIdResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getCustomerByIdResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getCustomerByIdResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getCustomerByIdResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getCustomerByIdResponseSuccess = getCustomerByIdResponse200 & {
  headers: Headers
}
export type getCustomerByIdResponseError = (
  | getCustomerByIdResponse400
  | getCustomerByIdResponse401
  | getCustomerByIdResponse404
  | getCustomerByIdResponse500
) & {
  headers: Headers
}

export type getCustomerByIdResponse = getCustomerByIdResponseSuccess | getCustomerByIdResponseError

export const getGetCustomerByIdUrl = (id: string) => {
  return `/partner/customers/${id}`
}

export const getCustomerById = async (
  id: string,
  options?: RequestInit
): Promise<getCustomerByIdResponse> => {
  return customInstance<getCustomerByIdResponse>(getGetCustomerByIdUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetCustomerByIdQueryKey = (id: string) => {
  return [`/partner/customers/${id}`] as const
}

export const getGetCustomerByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getCustomerById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCustomerByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerById>>> = ({ signal }) =>
    getCustomerById(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCustomerById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerById>>>
export type GetCustomerByIdQueryError = DtoErrorResponse

export function useGetCustomerById<
  TData = Awaited<ReturnType<typeof getCustomerById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerById>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerById>>,
          TError,
          Awaited<ReturnType<typeof getCustomerById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerById<
  TData = Awaited<ReturnType<typeof getCustomerById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerById>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerById>>,
          TError,
          Awaited<ReturnType<typeof getCustomerById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerById<
  TData = Awaited<ReturnType<typeof getCustomerById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get customer by ID
 */

export function useGetCustomerById<
  TData = Awaited<ReturnType<typeof getCustomerById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCustomerByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Update an existing customer's details
 * @summary Update a customer
 */
export type updateCustomerResponse200 = {
  data: HandlerAPIResponseHandlerCustomerResponse
  status: 200
}

export type updateCustomerResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type updateCustomerResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type updateCustomerResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type updateCustomerResponse409 = {
  data: DtoErrorResponse
  status: 409
}

export type updateCustomerResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type updateCustomerResponseSuccess = updateCustomerResponse200 & {
  headers: Headers
}
export type updateCustomerResponseError = (
  | updateCustomerResponse400
  | updateCustomerResponse401
  | updateCustomerResponse404
  | updateCustomerResponse409
  | updateCustomerResponse500
) & {
  headers: Headers
}

export type updateCustomerResponse = updateCustomerResponseSuccess | updateCustomerResponseError

export const getUpdateCustomerUrl = (id: string) => {
  return `/partner/customers/${id}`
}

export const updateCustomer = async (
  id: string,
  updateCustomerBody: UpdateCustomerBody,
  options?: RequestInit
): Promise<updateCustomerResponse> => {
  return customInstance<updateCustomerResponse>(getUpdateCustomerUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateCustomerBody),
  })
}

export const getUpdateCustomerMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCustomer>>,
    TError,
    { id: string; data: UpdateCustomerBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCustomer>>,
  TError,
  { id: string; data: UpdateCustomerBody },
  TContext
> => {
  const mutationKey = ['updateCustomer']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCustomer>>,
    { id: string; data: UpdateCustomerBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateCustomer(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateCustomerMutationResult = NonNullable<Awaited<ReturnType<typeof updateCustomer>>>
export type UpdateCustomerMutationBody = UpdateCustomerBody
export type UpdateCustomerMutationError = DtoErrorResponse

/**
 * @summary Update a customer
 */
export const useUpdateCustomer = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCustomer>>,
      TError,
      { id: string; data: UpdateCustomerBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateCustomer>>,
  TError,
  { id: string; data: UpdateCustomerBody },
  TContext
> => {
  return useMutation(getUpdateCustomerMutationOptions(options), queryClient)
}
/**
 * Activate an inactive or suspended customer
 * @summary Activate a customer
 */
export type activateCustomerResponse200 = {
  data: HandlerAPIResponseHandlerCustomerResponse
  status: 200
}

export type activateCustomerResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type activateCustomerResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type activateCustomerResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type activateCustomerResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type activateCustomerResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type activateCustomerResponseSuccess = activateCustomerResponse200 & {
  headers: Headers
}
export type activateCustomerResponseError = (
  | activateCustomerResponse400
  | activateCustomerResponse401
  | activateCustomerResponse404
  | activateCustomerResponse422
  | activateCustomerResponse500
) & {
  headers: Headers
}

export type activateCustomerResponse =
  | activateCustomerResponseSuccess
  | activateCustomerResponseError

export const getActivateCustomerUrl = (id: string) => {
  return `/partner/customers/${id}/activate`
}

export const activateCustomer = async (
  id: string,
  activateCustomerBody: ActivateCustomerBody,
  options?: RequestInit
): Promise<activateCustomerResponse> => {
  return customInstance<activateCustomerResponse>(getActivateCustomerUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(activateCustomerBody),
  })
}

export const getActivateCustomerMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof activateCustomer>>,
    TError,
    { id: string; data: ActivateCustomerBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof activateCustomer>>,
  TError,
  { id: string; data: ActivateCustomerBody },
  TContext
> => {
  const mutationKey = ['activateCustomer']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof activateCustomer>>,
    { id: string; data: ActivateCustomerBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return activateCustomer(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ActivateCustomerMutationResult = NonNullable<
  Awaited<ReturnType<typeof activateCustomer>>
>
export type ActivateCustomerMutationBody = ActivateCustomerBody
export type ActivateCustomerMutationError = DtoErrorResponse

/**
 * @summary Activate a customer
 */
export const useActivateCustomer = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof activateCustomer>>,
      TError,
      { id: string; data: ActivateCustomerBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof activateCustomer>>,
  TError,
  { id: string; data: ActivateCustomerBody },
  TContext
> => {
  return useMutation(getActivateCustomerMutationOptions(options), queryClient)
}
/**
 * Add to a customer's prepaid balance
 * @summary Add balance to customer
 */
export type addCustomerBalanceResponse200 = {
  data: HandlerAPIResponseHandlerCustomerResponse
  status: 200
}

export type addCustomerBalanceResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type addCustomerBalanceResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type addCustomerBalanceResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type addCustomerBalanceResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type addCustomerBalanceResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type addCustomerBalanceResponseSuccess = addCustomerBalanceResponse200 & {
  headers: Headers
}
export type addCustomerBalanceResponseError = (
  | addCustomerBalanceResponse400
  | addCustomerBalanceResponse401
  | addCustomerBalanceResponse404
  | addCustomerBalanceResponse422
  | addCustomerBalanceResponse500
) & {
  headers: Headers
}

export type addCustomerBalanceResponse =
  | addCustomerBalanceResponseSuccess
  | addCustomerBalanceResponseError

export const getAddCustomerBalanceUrl = (id: string) => {
  return `/partner/customers/${id}/balance/add`
}

export const addCustomerBalance = async (
  id: string,
  addCustomerBalanceBody: AddCustomerBalanceBody,
  options?: RequestInit
): Promise<addCustomerBalanceResponse> => {
  return customInstance<addCustomerBalanceResponse>(getAddCustomerBalanceUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(addCustomerBalanceBody),
  })
}

export const getAddCustomerBalanceMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addCustomerBalance>>,
    TError,
    { id: string; data: AddCustomerBalanceBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof addCustomerBalance>>,
  TError,
  { id: string; data: AddCustomerBalanceBody },
  TContext
> => {
  const mutationKey = ['addCustomerBalance']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addCustomerBalance>>,
    { id: string; data: AddCustomerBalanceBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return addCustomerBalance(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AddCustomerBalanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof addCustomerBalance>>
>
export type AddCustomerBalanceMutationBody = AddCustomerBalanceBody
export type AddCustomerBalanceMutationError = DtoErrorResponse

/**
 * @summary Add balance to customer
 */
export const useAddCustomerBalance = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addCustomerBalance>>,
      TError,
      { id: string; data: AddCustomerBalanceBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof addCustomerBalance>>,
  TError,
  { id: string; data: AddCustomerBalanceBody },
  TContext
> => {
  return useMutation(getAddCustomerBalanceMutationOptions(options), queryClient)
}
/**
 * Deduct from a customer's prepaid balance
 * @summary Deduct balance from customer
 */
export type deductCustomerBalanceResponse200 = {
  data: HandlerAPIResponseHandlerCustomerResponse
  status: 200
}

export type deductCustomerBalanceResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type deductCustomerBalanceResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type deductCustomerBalanceResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type deductCustomerBalanceResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type deductCustomerBalanceResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type deductCustomerBalanceResponseSuccess = deductCustomerBalanceResponse200 & {
  headers: Headers
}
export type deductCustomerBalanceResponseError = (
  | deductCustomerBalanceResponse400
  | deductCustomerBalanceResponse401
  | deductCustomerBalanceResponse404
  | deductCustomerBalanceResponse422
  | deductCustomerBalanceResponse500
) & {
  headers: Headers
}

export type deductCustomerBalanceResponse =
  | deductCustomerBalanceResponseSuccess
  | deductCustomerBalanceResponseError

export const getDeductCustomerBalanceUrl = (id: string) => {
  return `/partner/customers/${id}/balance/deduct`
}

export const deductCustomerBalance = async (
  id: string,
  deductCustomerBalanceBody: DeductCustomerBalanceBody,
  options?: RequestInit
): Promise<deductCustomerBalanceResponse> => {
  return customInstance<deductCustomerBalanceResponse>(getDeductCustomerBalanceUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(deductCustomerBalanceBody),
  })
}

export const getDeductCustomerBalanceMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deductCustomerBalance>>,
    TError,
    { id: string; data: DeductCustomerBalanceBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deductCustomerBalance>>,
  TError,
  { id: string; data: DeductCustomerBalanceBody },
  TContext
> => {
  const mutationKey = ['deductCustomerBalance']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deductCustomerBalance>>,
    { id: string; data: DeductCustomerBalanceBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return deductCustomerBalance(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeductCustomerBalanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof deductCustomerBalance>>
>
export type DeductCustomerBalanceMutationBody = DeductCustomerBalanceBody
export type DeductCustomerBalanceMutationError = DtoErrorResponse

/**
 * @summary Deduct balance from customer
 */
export const useDeductCustomerBalance = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deductCustomerBalance>>,
      TError,
      { id: string; data: DeductCustomerBalanceBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deductCustomerBalance>>,
  TError,
  { id: string; data: DeductCustomerBalanceBody },
  TContext
> => {
  return useMutation(getDeductCustomerBalanceMutationOptions(options), queryClient)
}
/**
 * Update a customer's code
 * @summary Update customer code
 */
export type updateCustomerCodeResponse200 = {
  data: HandlerAPIResponseHandlerCustomerResponse
  status: 200
}

export type updateCustomerCodeResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type updateCustomerCodeResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type updateCustomerCodeResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type updateCustomerCodeResponse409 = {
  data: DtoErrorResponse
  status: 409
}

export type updateCustomerCodeResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type updateCustomerCodeResponseSuccess = updateCustomerCodeResponse200 & {
  headers: Headers
}
export type updateCustomerCodeResponseError = (
  | updateCustomerCodeResponse400
  | updateCustomerCodeResponse401
  | updateCustomerCodeResponse404
  | updateCustomerCodeResponse409
  | updateCustomerCodeResponse500
) & {
  headers: Headers
}

export type updateCustomerCodeResponse =
  | updateCustomerCodeResponseSuccess
  | updateCustomerCodeResponseError

export const getUpdateCustomerCodeUrl = (id: string) => {
  return `/partner/customers/${id}/code`
}

export const updateCustomerCode = async (
  id: string,
  updateCustomerCodeBody: UpdateCustomerCodeBody,
  options?: RequestInit
): Promise<updateCustomerCodeResponse> => {
  return customInstance<updateCustomerCodeResponse>(getUpdateCustomerCodeUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateCustomerCodeBody),
  })
}

export const getUpdateCustomerCodeMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCustomerCode>>,
    TError,
    { id: string; data: UpdateCustomerCodeBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCustomerCode>>,
  TError,
  { id: string; data: UpdateCustomerCodeBody },
  TContext
> => {
  const mutationKey = ['updateCustomerCode']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCustomerCode>>,
    { id: string; data: UpdateCustomerCodeBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateCustomerCode(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateCustomerCodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCustomerCode>>
>
export type UpdateCustomerCodeMutationBody = UpdateCustomerCodeBody
export type UpdateCustomerCodeMutationError = DtoErrorResponse

/**
 * @summary Update customer code
 */
export const useUpdateCustomerCode = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCustomerCode>>,
      TError,
      { id: string; data: UpdateCustomerCodeBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateCustomerCode>>,
  TError,
  { id: string; data: UpdateCustomerCodeBody },
  TContext
> => {
  return useMutation(getUpdateCustomerCodeMutationOptions(options), queryClient)
}
/**
 * Deactivate an active customer
 * @summary Deactivate a customer
 */
export type deactivateCustomerResponse200 = {
  data: HandlerAPIResponseHandlerCustomerResponse
  status: 200
}

export type deactivateCustomerResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type deactivateCustomerResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type deactivateCustomerResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type deactivateCustomerResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type deactivateCustomerResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type deactivateCustomerResponseSuccess = deactivateCustomerResponse200 & {
  headers: Headers
}
export type deactivateCustomerResponseError = (
  | deactivateCustomerResponse400
  | deactivateCustomerResponse401
  | deactivateCustomerResponse404
  | deactivateCustomerResponse422
  | deactivateCustomerResponse500
) & {
  headers: Headers
}

export type deactivateCustomerResponse =
  | deactivateCustomerResponseSuccess
  | deactivateCustomerResponseError

export const getDeactivateCustomerUrl = (id: string) => {
  return `/partner/customers/${id}/deactivate`
}

export const deactivateCustomer = async (
  id: string,
  deactivateCustomerBody: DeactivateCustomerBody,
  options?: RequestInit
): Promise<deactivateCustomerResponse> => {
  return customInstance<deactivateCustomerResponse>(getDeactivateCustomerUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(deactivateCustomerBody),
  })
}

export const getDeactivateCustomerMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deactivateCustomer>>,
    TError,
    { id: string; data: DeactivateCustomerBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deactivateCustomer>>,
  TError,
  { id: string; data: DeactivateCustomerBody },
  TContext
> => {
  const mutationKey = ['deactivateCustomer']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deactivateCustomer>>,
    { id: string; data: DeactivateCustomerBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return deactivateCustomer(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeactivateCustomerMutationResult = NonNullable<
  Awaited<ReturnType<typeof deactivateCustomer>>
>
export type DeactivateCustomerMutationBody = DeactivateCustomerBody
export type DeactivateCustomerMutationError = DtoErrorResponse

/**
 * @summary Deactivate a customer
 */
export const useDeactivateCustomer = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deactivateCustomer>>,
      TError,
      { id: string; data: DeactivateCustomerBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deactivateCustomer>>,
  TError,
  { id: string; data: DeactivateCustomerBody },
  TContext
> => {
  return useMutation(getDeactivateCustomerMutationOptions(options), queryClient)
}
/**
 * Set a customer's tier level
 * @summary Set customer level
 */
export type setCustomerLevelResponse200 = {
  data: HandlerAPIResponseHandlerCustomerResponse
  status: 200
}

export type setCustomerLevelResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type setCustomerLevelResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type setCustomerLevelResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type setCustomerLevelResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type setCustomerLevelResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type setCustomerLevelResponseSuccess = setCustomerLevelResponse200 & {
  headers: Headers
}
export type setCustomerLevelResponseError = (
  | setCustomerLevelResponse400
  | setCustomerLevelResponse401
  | setCustomerLevelResponse404
  | setCustomerLevelResponse422
  | setCustomerLevelResponse500
) & {
  headers: Headers
}

export type setCustomerLevelResponse =
  | setCustomerLevelResponseSuccess
  | setCustomerLevelResponseError

export const getSetCustomerLevelUrl = (id: string) => {
  return `/partner/customers/${id}/level`
}

export const setCustomerLevel = async (
  id: string,
  setCustomerLevelBody: SetCustomerLevelBody,
  options?: RequestInit
): Promise<setCustomerLevelResponse> => {
  return customInstance<setCustomerLevelResponse>(getSetCustomerLevelUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(setCustomerLevelBody),
  })
}

export const getSetCustomerLevelMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setCustomerLevel>>,
    TError,
    { id: string; data: SetCustomerLevelBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof setCustomerLevel>>,
  TError,
  { id: string; data: SetCustomerLevelBody },
  TContext
> => {
  const mutationKey = ['setCustomerLevel']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setCustomerLevel>>,
    { id: string; data: SetCustomerLevelBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return setCustomerLevel(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SetCustomerLevelMutationResult = NonNullable<
  Awaited<ReturnType<typeof setCustomerLevel>>
>
export type SetCustomerLevelMutationBody = SetCustomerLevelBody
export type SetCustomerLevelMutationError = DtoErrorResponse

/**
 * @summary Set customer level
 */
export const useSetCustomerLevel = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof setCustomerLevel>>,
      TError,
      { id: string; data: SetCustomerLevelBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof setCustomerLevel>>,
  TError,
  { id: string; data: SetCustomerLevelBody },
  TContext
> => {
  return useMutation(getSetCustomerLevelMutationOptions(options), queryClient)
}
/**
 * Suspend an active customer
 * @summary Suspend a customer
 */
export type suspendCustomerResponse200 = {
  data: HandlerAPIResponseHandlerCustomerResponse
  status: 200
}

export type suspendCustomerResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type suspendCustomerResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type suspendCustomerResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type suspendCustomerResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type suspendCustomerResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type suspendCustomerResponseSuccess = suspendCustomerResponse200 & {
  headers: Headers
}
export type suspendCustomerResponseError = (
  | suspendCustomerResponse400
  | suspendCustomerResponse401
  | suspendCustomerResponse404
  | suspendCustomerResponse422
  | suspendCustomerResponse500
) & {
  headers: Headers
}

export type suspendCustomerResponse = suspendCustomerResponseSuccess | suspendCustomerResponseError

export const getSuspendCustomerUrl = (id: string) => {
  return `/partner/customers/${id}/suspend`
}

export const suspendCustomer = async (
  id: string,
  suspendCustomerBody: SuspendCustomerBody,
  options?: RequestInit
): Promise<suspendCustomerResponse> => {
  return customInstance<suspendCustomerResponse>(getSuspendCustomerUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(suspendCustomerBody),
  })
}

export const getSuspendCustomerMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suspendCustomer>>,
    TError,
    { id: string; data: SuspendCustomerBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof suspendCustomer>>,
  TError,
  { id: string; data: SuspendCustomerBody },
  TContext
> => {
  const mutationKey = ['suspendCustomer']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof suspendCustomer>>,
    { id: string; data: SuspendCustomerBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return suspendCustomer(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SuspendCustomerMutationResult = NonNullable<Awaited<ReturnType<typeof suspendCustomer>>>
export type SuspendCustomerMutationBody = SuspendCustomerBody
export type SuspendCustomerMutationError = DtoErrorResponse

/**
 * @summary Suspend a customer
 */
export const useSuspendCustomer = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof suspendCustomer>>,
      TError,
      { id: string; data: SuspendCustomerBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof suspendCustomer>>,
  TError,
  { id: string; data: SuspendCustomerBody },
  TContext
> => {
  return useMutation(getSuspendCustomerMutationOptions(options), queryClient)
}
/**
 * Retrieve a customer by its code
 * @summary Get customer by code
 */
export type getCustomerByCodeResponse200 = {
  data: HandlerAPIResponseHandlerCustomerResponse
  status: 200
}

export type getCustomerByCodeResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getCustomerByCodeResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getCustomerByCodeResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getCustomerByCodeResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getCustomerByCodeResponseSuccess = getCustomerByCodeResponse200 & {
  headers: Headers
}
export type getCustomerByCodeResponseError = (
  | getCustomerByCodeResponse400
  | getCustomerByCodeResponse401
  | getCustomerByCodeResponse404
  | getCustomerByCodeResponse500
) & {
  headers: Headers
}

export type getCustomerByCodeResponse =
  | getCustomerByCodeResponseSuccess
  | getCustomerByCodeResponseError

export const getGetCustomerByCodeUrl = (code: string) => {
  return `/partner/customers/code/${code}`
}

export const getCustomerByCode = async (
  code: string,
  options?: RequestInit
): Promise<getCustomerByCodeResponse> => {
  return customInstance<getCustomerByCodeResponse>(getGetCustomerByCodeUrl(code), {
    ...options,
    method: 'GET',
  })
}

export const getGetCustomerByCodeQueryKey = (code: string) => {
  return [`/partner/customers/code/${code}`] as const
}

export const getGetCustomerByCodeQueryOptions = <
  TData = Awaited<ReturnType<typeof getCustomerByCode>>,
  TError = DtoErrorResponse,
>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerByCode>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCustomerByCodeQueryKey(code)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerByCode>>> = ({ signal }) =>
    getCustomerByCode(code, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!code, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCustomerByCode>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerByCodeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCustomerByCode>>
>
export type GetCustomerByCodeQueryError = DtoErrorResponse

export function useGetCustomerByCode<
  TData = Awaited<ReturnType<typeof getCustomerByCode>>,
  TError = DtoErrorResponse,
>(
  code: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerByCode>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerByCode>>,
          TError,
          Awaited<ReturnType<typeof getCustomerByCode>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerByCode<
  TData = Awaited<ReturnType<typeof getCustomerByCode>>,
  TError = DtoErrorResponse,
>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerByCode>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerByCode>>,
          TError,
          Awaited<ReturnType<typeof getCustomerByCode>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerByCode<
  TData = Awaited<ReturnType<typeof getCustomerByCode>>,
  TError = DtoErrorResponse,
>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerByCode>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get customer by code
 */

export function useGetCustomerByCode<
  TData = Awaited<ReturnType<typeof getCustomerByCode>>,
  TError = DtoErrorResponse,
>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerByCode>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCustomerByCodeQueryOptions(code, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Get the count of customers grouped by status
 * @summary Get customer counts by status
 */
export type countCustomerByStatusResponse200 = {
  data: HandlerAPIResponseHandlerCustomerCountByStatusResponse
  status: 200
}

export type countCustomerByStatusResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type countCustomerByStatusResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type countCustomerByStatusResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type countCustomerByStatusResponseSuccess = countCustomerByStatusResponse200 & {
  headers: Headers
}
export type countCustomerByStatusResponseError = (
  | countCustomerByStatusResponse400
  | countCustomerByStatusResponse401
  | countCustomerByStatusResponse500
) & {
  headers: Headers
}

export type countCustomerByStatusResponse =
  | countCustomerByStatusResponseSuccess
  | countCustomerByStatusResponseError

export const getCountCustomerByStatusUrl = () => {
  return `/partner/customers/stats/count`
}

export const countCustomerByStatus = async (
  options?: RequestInit
): Promise<countCustomerByStatusResponse> => {
  return customInstance<countCustomerByStatusResponse>(getCountCustomerByStatusUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getCountCustomerByStatusQueryKey = () => {
  return [`/partner/customers/stats/count`] as const
}

export const getCountCustomerByStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof countCustomerByStatus>>,
  TError = DtoErrorResponse,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof countCustomerByStatus>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getCountCustomerByStatusQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countCustomerByStatus>>> = ({ signal }) =>
    countCustomerByStatus({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof countCustomerByStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CountCustomerByStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof countCustomerByStatus>>
>
export type CountCustomerByStatusQueryError = DtoErrorResponse

export function useCountCustomerByStatus<
  TData = Awaited<ReturnType<typeof countCustomerByStatus>>,
  TError = DtoErrorResponse,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof countCustomerByStatus>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof countCustomerByStatus>>,
          TError,
          Awaited<ReturnType<typeof countCustomerByStatus>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCountCustomerByStatus<
  TData = Awaited<ReturnType<typeof countCustomerByStatus>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof countCustomerByStatus>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof countCustomerByStatus>>,
          TError,
          Awaited<ReturnType<typeof countCustomerByStatus>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCountCustomerByStatus<
  TData = Awaited<ReturnType<typeof countCustomerByStatus>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof countCustomerByStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get customer counts by status
 */

export function useCountCustomerByStatus<
  TData = Awaited<ReturnType<typeof countCustomerByStatus>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof countCustomerByStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCountCustomerByStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

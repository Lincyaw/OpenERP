/**
 * // This file is auto-generated by orval
 * // Do not edit manually
 *
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  DtoErrorResponse,
  HandlerAPIResponseCsvimportImportSession,
  HandlerAPIResponseHandlerCustomerImportResponse,
  HandlerAPIResponseHandlerCustomerValidationResponse,
  HandlerAPIResponseHandlerProductImportResponse,
  HandlerAPIResponseHandlerProductValidationResponse,
  HandlerAPIResponseHandlerValidationResponse,
  ImportCustomersBody,
  ImportProductsBody,
  ValidateCustomerImportBodyTwo,
  ValidateImportBodyTwo,
  ValidateProductImportBodyTwo,
} from '.././models'

import { customInstance } from '../../services/axios-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Imports customers from a previously validated CSV file
 * @summary Import customers from validated CSV
 */
export type importCustomersResponse200 = {
  data: HandlerAPIResponseHandlerCustomerImportResponse
  status: 200
}

export type importCustomersResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type importCustomersResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type importCustomersResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type importCustomersResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type importCustomersResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type importCustomersResponseSuccess = importCustomersResponse200 & {
  headers: Headers
}
export type importCustomersResponseError = (
  | importCustomersResponse400
  | importCustomersResponse401
  | importCustomersResponse404
  | importCustomersResponse422
  | importCustomersResponse500
) & {
  headers: Headers
}

export type importCustomersResponse = importCustomersResponseSuccess | importCustomersResponseError

export const getImportCustomersUrl = () => {
  return `/import/customers`
}

export const importCustomers = async (
  importCustomersBody: ImportCustomersBody,
  options?: RequestInit
): Promise<importCustomersResponse> => {
  return customInstance<importCustomersResponse>(getImportCustomersUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(importCustomersBody),
  })
}

export const getImportCustomersMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof importCustomers>>,
    TError,
    { data: ImportCustomersBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof importCustomers>>,
  TError,
  { data: ImportCustomersBody },
  TContext
> => {
  const mutationKey = ['importCustomers']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importCustomers>>,
    { data: ImportCustomersBody }
  > = (props) => {
    const { data } = props ?? {}

    return importCustomers(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ImportCustomersMutationResult = NonNullable<Awaited<ReturnType<typeof importCustomers>>>
export type ImportCustomersMutationBody = ImportCustomersBody
export type ImportCustomersMutationError = DtoErrorResponse

/**
 * @summary Import customers from validated CSV
 */
export const useImportCustomers = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof importCustomers>>,
      TError,
      { data: ImportCustomersBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof importCustomers>>,
  TError,
  { data: ImportCustomersBody },
  TContext
> => {
  return useMutation(getImportCustomersMutationOptions(options), queryClient)
}
/**
 * Validates a customer CSV file for import without actually importing the data
 * @summary Validate customer CSV file for import
 */
export type validateCustomerImportResponse200 = {
  data: HandlerAPIResponseHandlerCustomerValidationResponse
  status: 200
}

export type validateCustomerImportResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type validateCustomerImportResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type validateCustomerImportResponse413 = {
  data: DtoErrorResponse
  status: 413
}

export type validateCustomerImportResponse415 = {
  data: DtoErrorResponse
  status: 415
}

export type validateCustomerImportResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type validateCustomerImportResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type validateCustomerImportResponseSuccess = validateCustomerImportResponse200 & {
  headers: Headers
}
export type validateCustomerImportResponseError = (
  | validateCustomerImportResponse400
  | validateCustomerImportResponse401
  | validateCustomerImportResponse413
  | validateCustomerImportResponse415
  | validateCustomerImportResponse422
  | validateCustomerImportResponse500
) & {
  headers: Headers
}

export type validateCustomerImportResponse =
  | validateCustomerImportResponseSuccess
  | validateCustomerImportResponseError

export const getValidateCustomerImportUrl = () => {
  return `/import/customers/validate`
}

export const validateCustomerImport = async (
  validateCustomerImportBody: unknown | ValidateCustomerImportBodyTwo,
  options?: RequestInit
): Promise<validateCustomerImportResponse> => {
  return customInstance<validateCustomerImportResponse>(getValidateCustomerImportUrl(), {
    ...options,
    method: 'POST',
    body: JSON.stringify(validateCustomerImportBody),
  })
}

export const getValidateCustomerImportMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof validateCustomerImport>>,
    TError,
    { data: unknown | ValidateCustomerImportBodyTwo },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof validateCustomerImport>>,
  TError,
  { data: unknown | ValidateCustomerImportBodyTwo },
  TContext
> => {
  const mutationKey = ['validateCustomerImport']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof validateCustomerImport>>,
    { data: unknown | ValidateCustomerImportBodyTwo }
  > = (props) => {
    const { data } = props ?? {}

    return validateCustomerImport(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ValidateCustomerImportMutationResult = NonNullable<
  Awaited<ReturnType<typeof validateCustomerImport>>
>
export type ValidateCustomerImportMutationBody = unknown | ValidateCustomerImportBodyTwo
export type ValidateCustomerImportMutationError = DtoErrorResponse

/**
 * @summary Validate customer CSV file for import
 */
export const useValidateCustomerImport = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof validateCustomerImport>>,
      TError,
      { data: unknown | ValidateCustomerImportBodyTwo },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof validateCustomerImport>>,
  TError,
  { data: unknown | ValidateCustomerImportBodyTwo },
  TContext
> => {
  return useMutation(getValidateCustomerImportMutationOptions(options), queryClient)
}
/**
 * Imports products from a previously validated CSV file
 * @summary Import products from validated CSV
 */
export type importProductsResponse200 = {
  data: HandlerAPIResponseHandlerProductImportResponse
  status: 200
}

export type importProductsResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type importProductsResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type importProductsResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type importProductsResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type importProductsResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type importProductsResponseSuccess = importProductsResponse200 & {
  headers: Headers
}
export type importProductsResponseError = (
  | importProductsResponse400
  | importProductsResponse401
  | importProductsResponse404
  | importProductsResponse422
  | importProductsResponse500
) & {
  headers: Headers
}

export type importProductsResponse = importProductsResponseSuccess | importProductsResponseError

export const getImportProductsUrl = () => {
  return `/import/products`
}

export const importProducts = async (
  importProductsBody: ImportProductsBody,
  options?: RequestInit
): Promise<importProductsResponse> => {
  return customInstance<importProductsResponse>(getImportProductsUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(importProductsBody),
  })
}

export const getImportProductsMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof importProducts>>,
    TError,
    { data: ImportProductsBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof importProducts>>,
  TError,
  { data: ImportProductsBody },
  TContext
> => {
  const mutationKey = ['importProducts']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importProducts>>,
    { data: ImportProductsBody }
  > = (props) => {
    const { data } = props ?? {}

    return importProducts(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ImportProductsMutationResult = NonNullable<Awaited<ReturnType<typeof importProducts>>>
export type ImportProductsMutationBody = ImportProductsBody
export type ImportProductsMutationError = DtoErrorResponse

/**
 * @summary Import products from validated CSV
 */
export const useImportProducts = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof importProducts>>,
      TError,
      { data: ImportProductsBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof importProducts>>,
  TError,
  { data: ImportProductsBody },
  TContext
> => {
  return useMutation(getImportProductsMutationOptions(options), queryClient)
}
/**
 * Validates a product CSV file for import without actually importing the data
 * @summary Validate product CSV file for import
 */
export type validateProductImportResponse200 = {
  data: HandlerAPIResponseHandlerProductValidationResponse
  status: 200
}

export type validateProductImportResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type validateProductImportResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type validateProductImportResponse413 = {
  data: DtoErrorResponse
  status: 413
}

export type validateProductImportResponse415 = {
  data: DtoErrorResponse
  status: 415
}

export type validateProductImportResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type validateProductImportResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type validateProductImportResponseSuccess = validateProductImportResponse200 & {
  headers: Headers
}
export type validateProductImportResponseError = (
  | validateProductImportResponse400
  | validateProductImportResponse401
  | validateProductImportResponse413
  | validateProductImportResponse415
  | validateProductImportResponse422
  | validateProductImportResponse500
) & {
  headers: Headers
}

export type validateProductImportResponse =
  | validateProductImportResponseSuccess
  | validateProductImportResponseError

export const getValidateProductImportUrl = () => {
  return `/import/products/validate`
}

export const validateProductImport = async (
  validateProductImportBody: unknown | ValidateProductImportBodyTwo,
  options?: RequestInit
): Promise<validateProductImportResponse> => {
  return customInstance<validateProductImportResponse>(getValidateProductImportUrl(), {
    ...options,
    method: 'POST',
    body: JSON.stringify(validateProductImportBody),
  })
}

export const getValidateProductImportMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof validateProductImport>>,
    TError,
    { data: unknown | ValidateProductImportBodyTwo },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof validateProductImport>>,
  TError,
  { data: unknown | ValidateProductImportBodyTwo },
  TContext
> => {
  const mutationKey = ['validateProductImport']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof validateProductImport>>,
    { data: unknown | ValidateProductImportBodyTwo }
  > = (props) => {
    const { data } = props ?? {}

    return validateProductImport(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ValidateProductImportMutationResult = NonNullable<
  Awaited<ReturnType<typeof validateProductImport>>
>
export type ValidateProductImportMutationBody = unknown | ValidateProductImportBodyTwo
export type ValidateProductImportMutationError = DtoErrorResponse

/**
 * @summary Validate product CSV file for import
 */
export const useValidateProductImport = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof validateProductImport>>,
      TError,
      { data: unknown | ValidateProductImportBodyTwo },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof validateProductImport>>,
  TError,
  { data: unknown | ValidateProductImportBodyTwo },
  TContext
> => {
  return useMutation(getValidateProductImportMutationOptions(options), queryClient)
}
/**
 * Retrieves the status and details of an import session
 * @summary Get import session
 */
export type getImportSessionResponse200 = {
  data: HandlerAPIResponseCsvimportImportSession
  status: 200
}

export type getImportSessionResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getImportSessionResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getImportSessionResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getImportSessionResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getImportSessionResponseSuccess = getImportSessionResponse200 & {
  headers: Headers
}
export type getImportSessionResponseError = (
  | getImportSessionResponse400
  | getImportSessionResponse401
  | getImportSessionResponse404
  | getImportSessionResponse500
) & {
  headers: Headers
}

export type getImportSessionResponse =
  | getImportSessionResponseSuccess
  | getImportSessionResponseError

export const getGetImportSessionUrl = (id: string) => {
  return `/import/sessions/${id}`
}

export const getImportSession = async (
  id: string,
  options?: RequestInit
): Promise<getImportSessionResponse> => {
  return customInstance<getImportSessionResponse>(getGetImportSessionUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetImportSessionQueryKey = (id: string) => {
  return [`/import/sessions/${id}`] as const
}

export const getGetImportSessionQueryOptions = <
  TData = Awaited<ReturnType<typeof getImportSession>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportSession>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetImportSessionQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImportSession>>> = ({ signal }) =>
    getImportSession(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getImportSession>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetImportSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getImportSession>>>
export type GetImportSessionQueryError = DtoErrorResponse

export function useGetImportSession<
  TData = Awaited<ReturnType<typeof getImportSession>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportSession>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getImportSession>>,
          TError,
          Awaited<ReturnType<typeof getImportSession>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetImportSession<
  TData = Awaited<ReturnType<typeof getImportSession>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportSession>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getImportSession>>,
          TError,
          Awaited<ReturnType<typeof getImportSession>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetImportSession<
  TData = Awaited<ReturnType<typeof getImportSession>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportSession>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get import session
 */

export function useGetImportSession<
  TData = Awaited<ReturnType<typeof getImportSession>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportSession>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetImportSessionQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Validates a CSV file for import without actually importing the data
 * @summary Validate CSV file for import
 */
export type validateImportResponse200 = {
  data: HandlerAPIResponseHandlerValidationResponse
  status: 200
}

export type validateImportResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type validateImportResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type validateImportResponse413 = {
  data: DtoErrorResponse
  status: 413
}

export type validateImportResponse415 = {
  data: DtoErrorResponse
  status: 415
}

export type validateImportResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type validateImportResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type validateImportResponseSuccess = validateImportResponse200 & {
  headers: Headers
}
export type validateImportResponseError = (
  | validateImportResponse400
  | validateImportResponse401
  | validateImportResponse413
  | validateImportResponse415
  | validateImportResponse422
  | validateImportResponse500
) & {
  headers: Headers
}

export type validateImportResponse = validateImportResponseSuccess | validateImportResponseError

export const getValidateImportUrl = () => {
  return `/import/validate`
}

export const validateImport = async (
  validateImportBody:
    | unknown
    | 'products'
    | 'customers'
    | 'suppliers'
    | 'inventory'
    | ValidateImportBodyTwo,
  options?: RequestInit
): Promise<validateImportResponse> => {
  return customInstance<validateImportResponse>(getValidateImportUrl(), {
    ...options,
    method: 'POST',
    body: JSON.stringify(validateImportBody),
  })
}

export const getValidateImportMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof validateImport>>,
    TError,
    {
      data: unknown | 'products' | 'customers' | 'suppliers' | 'inventory' | ValidateImportBodyTwo
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof validateImport>>,
  TError,
  { data: unknown | 'products' | 'customers' | 'suppliers' | 'inventory' | ValidateImportBodyTwo },
  TContext
> => {
  const mutationKey = ['validateImport']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof validateImport>>,
    { data: unknown | 'products' | 'customers' | 'suppliers' | 'inventory' | ValidateImportBodyTwo }
  > = (props) => {
    const { data } = props ?? {}

    return validateImport(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ValidateImportMutationResult = NonNullable<Awaited<ReturnType<typeof validateImport>>>
export type ValidateImportMutationBody =
  | unknown
  | 'products'
  | 'customers'
  | 'suppliers'
  | 'inventory'
  | ValidateImportBodyTwo
export type ValidateImportMutationError = DtoErrorResponse

/**
 * @summary Validate CSV file for import
 */
export const useValidateImport = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof validateImport>>,
      TError,
      {
        data: unknown | 'products' | 'customers' | 'suppliers' | 'inventory' | ValidateImportBodyTwo
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof validateImport>>,
  TError,
  { data: unknown | 'products' | 'customers' | 'suppliers' | 'inventory' | ValidateImportBodyTwo },
  TContext
> => {
  return useMutation(getValidateImportMutationOptions(options), queryClient)
}

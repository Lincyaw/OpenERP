/**
 * // This file is auto-generated by orval
 * // Do not edit manually
 *
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  DtoErrorResponse,
  HandlerAPIResponseCsvimportImportSession,
  HandlerAPIResponseDtoImportHistoryListResponse,
  HandlerAPIResponseDtoImportHistoryResponse,
  HandlerAPIResponseHandlerCustomerImportResponse,
  HandlerAPIResponseHandlerCustomerValidationResponse,
  HandlerAPIResponseHandlerInventoryImportResponse,
  HandlerAPIResponseHandlerInventoryValidationResponse,
  HandlerAPIResponseHandlerProductImportResponse,
  HandlerAPIResponseHandlerProductValidationResponse,
  HandlerAPIResponseHandlerSupplierImportResponse,
  HandlerAPIResponseHandlerSupplierValidationResponse,
  HandlerAPIResponseHandlerValidationResponse,
  ImportCustomersBody,
  ImportInventoryBody,
  ImportProductsBody,
  ImportSuppliersBody,
  ListImportHistoryParams,
  ValidateCustomerImportBodyTwo,
  ValidateImportBodyTwo,
  ValidateInventoryImportBodyTwo,
  ValidateProductImportBodyTwo,
  ValidateSupplierImportBodyTwo,
} from '.././models'

import { customInstance } from '../../services/axios-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Imports customers from a previously validated CSV file
 * @summary Import customers from validated CSV
 */
export type importCustomersResponse200 = {
  data: HandlerAPIResponseHandlerCustomerImportResponse
  status: 200
}

export type importCustomersResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type importCustomersResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type importCustomersResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type importCustomersResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type importCustomersResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type importCustomersResponseSuccess = importCustomersResponse200 & {
  headers: Headers
}
export type importCustomersResponseError = (
  | importCustomersResponse400
  | importCustomersResponse401
  | importCustomersResponse404
  | importCustomersResponse422
  | importCustomersResponse500
) & {
  headers: Headers
}

export type importCustomersResponse = importCustomersResponseSuccess | importCustomersResponseError

export const getImportCustomersUrl = () => {
  return `/import/customers`
}

export const importCustomers = async (
  importCustomersBody: ImportCustomersBody,
  options?: RequestInit
): Promise<importCustomersResponse> => {
  return customInstance<importCustomersResponse>(getImportCustomersUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(importCustomersBody),
  })
}

export const getImportCustomersMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof importCustomers>>,
    TError,
    { data: ImportCustomersBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof importCustomers>>,
  TError,
  { data: ImportCustomersBody },
  TContext
> => {
  const mutationKey = ['importCustomers']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importCustomers>>,
    { data: ImportCustomersBody }
  > = (props) => {
    const { data } = props ?? {}

    return importCustomers(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ImportCustomersMutationResult = NonNullable<Awaited<ReturnType<typeof importCustomers>>>
export type ImportCustomersMutationBody = ImportCustomersBody
export type ImportCustomersMutationError = DtoErrorResponse

/**
 * @summary Import customers from validated CSV
 */
export const useImportCustomers = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof importCustomers>>,
      TError,
      { data: ImportCustomersBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof importCustomers>>,
  TError,
  { data: ImportCustomersBody },
  TContext
> => {
  return useMutation(getImportCustomersMutationOptions(options), queryClient)
}
/**
 * Validates a customer CSV file for import without actually importing the data
 * @summary Validate customer CSV file for import
 */
export type validateCustomerImportResponse200 = {
  data: HandlerAPIResponseHandlerCustomerValidationResponse
  status: 200
}

export type validateCustomerImportResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type validateCustomerImportResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type validateCustomerImportResponse413 = {
  data: DtoErrorResponse
  status: 413
}

export type validateCustomerImportResponse415 = {
  data: DtoErrorResponse
  status: 415
}

export type validateCustomerImportResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type validateCustomerImportResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type validateCustomerImportResponseSuccess = validateCustomerImportResponse200 & {
  headers: Headers
}
export type validateCustomerImportResponseError = (
  | validateCustomerImportResponse400
  | validateCustomerImportResponse401
  | validateCustomerImportResponse413
  | validateCustomerImportResponse415
  | validateCustomerImportResponse422
  | validateCustomerImportResponse500
) & {
  headers: Headers
}

export type validateCustomerImportResponse =
  | validateCustomerImportResponseSuccess
  | validateCustomerImportResponseError

export const getValidateCustomerImportUrl = () => {
  return `/import/customers/validate`
}

export const validateCustomerImport = async (
  validateCustomerImportBody: unknown | ValidateCustomerImportBodyTwo,
  options?: RequestInit
): Promise<validateCustomerImportResponse> => {
  return customInstance<validateCustomerImportResponse>(getValidateCustomerImportUrl(), {
    ...options,
    method: 'POST',
    body: JSON.stringify(validateCustomerImportBody),
  })
}

export const getValidateCustomerImportMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof validateCustomerImport>>,
    TError,
    { data: unknown | ValidateCustomerImportBodyTwo },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof validateCustomerImport>>,
  TError,
  { data: unknown | ValidateCustomerImportBodyTwo },
  TContext
> => {
  const mutationKey = ['validateCustomerImport']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof validateCustomerImport>>,
    { data: unknown | ValidateCustomerImportBodyTwo }
  > = (props) => {
    const { data } = props ?? {}

    return validateCustomerImport(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ValidateCustomerImportMutationResult = NonNullable<
  Awaited<ReturnType<typeof validateCustomerImport>>
>
export type ValidateCustomerImportMutationBody = unknown | ValidateCustomerImportBodyTwo
export type ValidateCustomerImportMutationError = DtoErrorResponse

/**
 * @summary Validate customer CSV file for import
 */
export const useValidateCustomerImport = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof validateCustomerImport>>,
      TError,
      { data: unknown | ValidateCustomerImportBodyTwo },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof validateCustomerImport>>,
  TError,
  { data: unknown | ValidateCustomerImportBodyTwo },
  TContext
> => {
  return useMutation(getValidateCustomerImportMutationOptions(options), queryClient)
}
/**
 * Returns a paginated list of import histories with optional filtering
 * @summary List import histories
 */
export type listImportHistoryResponse200 = {
  data: HandlerAPIResponseDtoImportHistoryListResponse
  status: 200
}

export type listImportHistoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listImportHistoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listImportHistoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listImportHistoryResponseSuccess = listImportHistoryResponse200 & {
  headers: Headers
}
export type listImportHistoryResponseError = (
  | listImportHistoryResponse400
  | listImportHistoryResponse401
  | listImportHistoryResponse500
) & {
  headers: Headers
}

export type listImportHistoryResponse =
  | listImportHistoryResponseSuccess
  | listImportHistoryResponseError

export const getListImportHistoryUrl = (params?: ListImportHistoryParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/import/history?${stringifiedParams}` : `/import/history`
}

export const listImportHistory = async (
  params?: ListImportHistoryParams,
  options?: RequestInit
): Promise<listImportHistoryResponse> => {
  return customInstance<listImportHistoryResponse>(getListImportHistoryUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getListImportHistoryQueryKey = (params?: ListImportHistoryParams) => {
  return [`/import/history`, ...(params ? [params] : [])] as const
}

export const getListImportHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof listImportHistory>>,
  TError = DtoErrorResponse,
>(
  params?: ListImportHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listImportHistory>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListImportHistoryQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listImportHistory>>> = ({ signal }) =>
    listImportHistory(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listImportHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListImportHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof listImportHistory>>
>
export type ListImportHistoryQueryError = DtoErrorResponse

export function useListImportHistory<
  TData = Awaited<ReturnType<typeof listImportHistory>>,
  TError = DtoErrorResponse,
>(
  params: undefined | ListImportHistoryParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listImportHistory>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listImportHistory>>,
          TError,
          Awaited<ReturnType<typeof listImportHistory>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListImportHistory<
  TData = Awaited<ReturnType<typeof listImportHistory>>,
  TError = DtoErrorResponse,
>(
  params?: ListImportHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listImportHistory>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listImportHistory>>,
          TError,
          Awaited<ReturnType<typeof listImportHistory>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListImportHistory<
  TData = Awaited<ReturnType<typeof listImportHistory>>,
  TError = DtoErrorResponse,
>(
  params?: ListImportHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listImportHistory>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List import histories
 */

export function useListImportHistory<
  TData = Awaited<ReturnType<typeof listImportHistory>>,
  TError = DtoErrorResponse,
>(
  params?: ListImportHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listImportHistory>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListImportHistoryQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Deletes an import history record
 * @summary Delete import history
 */
export type deleteImportHistoryResponse204 = {
  data: void
  status: 204
}

export type deleteImportHistoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type deleteImportHistoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type deleteImportHistoryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type deleteImportHistoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type deleteImportHistoryResponseSuccess = deleteImportHistoryResponse204 & {
  headers: Headers
}
export type deleteImportHistoryResponseError = (
  | deleteImportHistoryResponse400
  | deleteImportHistoryResponse401
  | deleteImportHistoryResponse404
  | deleteImportHistoryResponse500
) & {
  headers: Headers
}

export type deleteImportHistoryResponse =
  | deleteImportHistoryResponseSuccess
  | deleteImportHistoryResponseError

export const getDeleteImportHistoryUrl = (id: string) => {
  return `/import/history/${id}`
}

export const deleteImportHistory = async (
  id: string,
  options?: RequestInit
): Promise<deleteImportHistoryResponse> => {
  return customInstance<deleteImportHistoryResponse>(getDeleteImportHistoryUrl(id), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteImportHistoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteImportHistory>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteImportHistory>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteImportHistory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteImportHistory>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteImportHistory(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteImportHistoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteImportHistory>>
>

export type DeleteImportHistoryMutationError = DtoErrorResponse

/**
 * @summary Delete import history
 */
export const useDeleteImportHistory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteImportHistory>>,
      TError,
      { id: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteImportHistory>>,
  TError,
  { id: string },
  TContext
> => {
  return useMutation(getDeleteImportHistoryMutationOptions(options), queryClient)
}
/**
 * Returns detailed information about a specific import operation
 * @summary Get import history details
 */
export type getImportHistoryResponse200 = {
  data: HandlerAPIResponseDtoImportHistoryResponse
  status: 200
}

export type getImportHistoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getImportHistoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getImportHistoryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getImportHistoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getImportHistoryResponseSuccess = getImportHistoryResponse200 & {
  headers: Headers
}
export type getImportHistoryResponseError = (
  | getImportHistoryResponse400
  | getImportHistoryResponse401
  | getImportHistoryResponse404
  | getImportHistoryResponse500
) & {
  headers: Headers
}

export type getImportHistoryResponse =
  | getImportHistoryResponseSuccess
  | getImportHistoryResponseError

export const getGetImportHistoryUrl = (id: string) => {
  return `/import/history/${id}`
}

export const getImportHistory = async (
  id: string,
  options?: RequestInit
): Promise<getImportHistoryResponse> => {
  return customInstance<getImportHistoryResponse>(getGetImportHistoryUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetImportHistoryQueryKey = (id: string) => {
  return [`/import/history/${id}`] as const
}

export const getGetImportHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getImportHistory>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportHistory>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetImportHistoryQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImportHistory>>> = ({ signal }) =>
    getImportHistory(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getImportHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetImportHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getImportHistory>>>
export type GetImportHistoryQueryError = DtoErrorResponse

export function useGetImportHistory<
  TData = Awaited<ReturnType<typeof getImportHistory>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportHistory>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getImportHistory>>,
          TError,
          Awaited<ReturnType<typeof getImportHistory>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetImportHistory<
  TData = Awaited<ReturnType<typeof getImportHistory>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportHistory>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getImportHistory>>,
          TError,
          Awaited<ReturnType<typeof getImportHistory>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetImportHistory<
  TData = Awaited<ReturnType<typeof getImportHistory>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportHistory>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get import history details
 */

export function useGetImportHistory<
  TData = Awaited<ReturnType<typeof getImportHistory>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportHistory>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetImportHistoryQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Downloads error details from an import operation as a CSV file
 * @summary Download import errors as CSV
 */
export type getImportErrorsResponse200 = {
  data: string
  status: 200
}

export type getImportErrorsResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getImportErrorsResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getImportErrorsResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getImportErrorsResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getImportErrorsResponseSuccess = getImportErrorsResponse200 & {
  headers: Headers
}
export type getImportErrorsResponseError = (
  | getImportErrorsResponse400
  | getImportErrorsResponse401
  | getImportErrorsResponse404
  | getImportErrorsResponse500
) & {
  headers: Headers
}

export type getImportErrorsResponse = getImportErrorsResponseSuccess | getImportErrorsResponseError

export const getGetImportErrorsUrl = (id: string) => {
  return `/import/history/${id}/errors`
}

export const getImportErrors = async (
  id: string,
  options?: RequestInit
): Promise<getImportErrorsResponse> => {
  return customInstance<getImportErrorsResponse>(getGetImportErrorsUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetImportErrorsQueryKey = (id: string) => {
  return [`/import/history/${id}/errors`] as const
}

export const getGetImportErrorsQueryOptions = <
  TData = Awaited<ReturnType<typeof getImportErrors>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportErrors>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetImportErrorsQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImportErrors>>> = ({ signal }) =>
    getImportErrors(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getImportErrors>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetImportErrorsQueryResult = NonNullable<Awaited<ReturnType<typeof getImportErrors>>>
export type GetImportErrorsQueryError = DtoErrorResponse

export function useGetImportErrors<
  TData = Awaited<ReturnType<typeof getImportErrors>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportErrors>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getImportErrors>>,
          TError,
          Awaited<ReturnType<typeof getImportErrors>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetImportErrors<
  TData = Awaited<ReturnType<typeof getImportErrors>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportErrors>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getImportErrors>>,
          TError,
          Awaited<ReturnType<typeof getImportErrors>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetImportErrors<
  TData = Awaited<ReturnType<typeof getImportErrors>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportErrors>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download import errors as CSV
 */

export function useGetImportErrors<
  TData = Awaited<ReturnType<typeof getImportErrors>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportErrors>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetImportErrorsQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Imports inventory from a previously validated CSV file. CRITICAL: This is for initial data migration only, not for regular stock operations. Requires admin permission.
 * @summary Import inventory from validated CSV
 */
export type importInventoryResponse200 = {
  data: HandlerAPIResponseHandlerInventoryImportResponse
  status: 200
}

export type importInventoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type importInventoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type importInventoryResponse403 = {
  data: DtoErrorResponse
  status: 403
}

export type importInventoryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type importInventoryResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type importInventoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type importInventoryResponseSuccess = importInventoryResponse200 & {
  headers: Headers
}
export type importInventoryResponseError = (
  | importInventoryResponse400
  | importInventoryResponse401
  | importInventoryResponse403
  | importInventoryResponse404
  | importInventoryResponse422
  | importInventoryResponse500
) & {
  headers: Headers
}

export type importInventoryResponse = importInventoryResponseSuccess | importInventoryResponseError

export const getImportInventoryUrl = () => {
  return `/import/inventory`
}

export const importInventory = async (
  importInventoryBody: ImportInventoryBody,
  options?: RequestInit
): Promise<importInventoryResponse> => {
  return customInstance<importInventoryResponse>(getImportInventoryUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(importInventoryBody),
  })
}

export const getImportInventoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof importInventory>>,
    TError,
    { data: ImportInventoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof importInventory>>,
  TError,
  { data: ImportInventoryBody },
  TContext
> => {
  const mutationKey = ['importInventory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importInventory>>,
    { data: ImportInventoryBody }
  > = (props) => {
    const { data } = props ?? {}

    return importInventory(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ImportInventoryMutationResult = NonNullable<Awaited<ReturnType<typeof importInventory>>>
export type ImportInventoryMutationBody = ImportInventoryBody
export type ImportInventoryMutationError = DtoErrorResponse

/**
 * @summary Import inventory from validated CSV
 */
export const useImportInventory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof importInventory>>,
      TError,
      { data: ImportInventoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof importInventory>>,
  TError,
  { data: ImportInventoryBody },
  TContext
> => {
  return useMutation(getImportInventoryMutationOptions(options), queryClient)
}
/**
 * Validates an inventory CSV file for import without actually importing the data. CRITICAL: This is for initial data migration only, not for regular stock operations.
 * @summary Validate inventory CSV file for import
 */
export type validateInventoryImportResponse200 = {
  data: HandlerAPIResponseHandlerInventoryValidationResponse
  status: 200
}

export type validateInventoryImportResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type validateInventoryImportResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type validateInventoryImportResponse413 = {
  data: DtoErrorResponse
  status: 413
}

export type validateInventoryImportResponse415 = {
  data: DtoErrorResponse
  status: 415
}

export type validateInventoryImportResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type validateInventoryImportResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type validateInventoryImportResponseSuccess = validateInventoryImportResponse200 & {
  headers: Headers
}
export type validateInventoryImportResponseError = (
  | validateInventoryImportResponse400
  | validateInventoryImportResponse401
  | validateInventoryImportResponse413
  | validateInventoryImportResponse415
  | validateInventoryImportResponse422
  | validateInventoryImportResponse500
) & {
  headers: Headers
}

export type validateInventoryImportResponse =
  | validateInventoryImportResponseSuccess
  | validateInventoryImportResponseError

export const getValidateInventoryImportUrl = () => {
  return `/import/inventory/validate`
}

export const validateInventoryImport = async (
  validateInventoryImportBody: unknown | ValidateInventoryImportBodyTwo,
  options?: RequestInit
): Promise<validateInventoryImportResponse> => {
  return customInstance<validateInventoryImportResponse>(getValidateInventoryImportUrl(), {
    ...options,
    method: 'POST',
    body: JSON.stringify(validateInventoryImportBody),
  })
}

export const getValidateInventoryImportMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof validateInventoryImport>>,
    TError,
    { data: unknown | ValidateInventoryImportBodyTwo },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof validateInventoryImport>>,
  TError,
  { data: unknown | ValidateInventoryImportBodyTwo },
  TContext
> => {
  const mutationKey = ['validateInventoryImport']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof validateInventoryImport>>,
    { data: unknown | ValidateInventoryImportBodyTwo }
  > = (props) => {
    const { data } = props ?? {}

    return validateInventoryImport(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ValidateInventoryImportMutationResult = NonNullable<
  Awaited<ReturnType<typeof validateInventoryImport>>
>
export type ValidateInventoryImportMutationBody = unknown | ValidateInventoryImportBodyTwo
export type ValidateInventoryImportMutationError = DtoErrorResponse

/**
 * @summary Validate inventory CSV file for import
 */
export const useValidateInventoryImport = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof validateInventoryImport>>,
      TError,
      { data: unknown | ValidateInventoryImportBodyTwo },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof validateInventoryImport>>,
  TError,
  { data: unknown | ValidateInventoryImportBodyTwo },
  TContext
> => {
  return useMutation(getValidateInventoryImportMutationOptions(options), queryClient)
}
/**
 * Imports products from a previously validated CSV file
 * @summary Import products from validated CSV
 */
export type importProductsResponse200 = {
  data: HandlerAPIResponseHandlerProductImportResponse
  status: 200
}

export type importProductsResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type importProductsResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type importProductsResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type importProductsResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type importProductsResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type importProductsResponseSuccess = importProductsResponse200 & {
  headers: Headers
}
export type importProductsResponseError = (
  | importProductsResponse400
  | importProductsResponse401
  | importProductsResponse404
  | importProductsResponse422
  | importProductsResponse500
) & {
  headers: Headers
}

export type importProductsResponse = importProductsResponseSuccess | importProductsResponseError

export const getImportProductsUrl = () => {
  return `/import/products`
}

export const importProducts = async (
  importProductsBody: ImportProductsBody,
  options?: RequestInit
): Promise<importProductsResponse> => {
  return customInstance<importProductsResponse>(getImportProductsUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(importProductsBody),
  })
}

export const getImportProductsMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof importProducts>>,
    TError,
    { data: ImportProductsBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof importProducts>>,
  TError,
  { data: ImportProductsBody },
  TContext
> => {
  const mutationKey = ['importProducts']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importProducts>>,
    { data: ImportProductsBody }
  > = (props) => {
    const { data } = props ?? {}

    return importProducts(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ImportProductsMutationResult = NonNullable<Awaited<ReturnType<typeof importProducts>>>
export type ImportProductsMutationBody = ImportProductsBody
export type ImportProductsMutationError = DtoErrorResponse

/**
 * @summary Import products from validated CSV
 */
export const useImportProducts = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof importProducts>>,
      TError,
      { data: ImportProductsBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof importProducts>>,
  TError,
  { data: ImportProductsBody },
  TContext
> => {
  return useMutation(getImportProductsMutationOptions(options), queryClient)
}
/**
 * Validates a product CSV file for import without actually importing the data
 * @summary Validate product CSV file for import
 */
export type validateProductImportResponse200 = {
  data: HandlerAPIResponseHandlerProductValidationResponse
  status: 200
}

export type validateProductImportResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type validateProductImportResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type validateProductImportResponse413 = {
  data: DtoErrorResponse
  status: 413
}

export type validateProductImportResponse415 = {
  data: DtoErrorResponse
  status: 415
}

export type validateProductImportResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type validateProductImportResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type validateProductImportResponseSuccess = validateProductImportResponse200 & {
  headers: Headers
}
export type validateProductImportResponseError = (
  | validateProductImportResponse400
  | validateProductImportResponse401
  | validateProductImportResponse413
  | validateProductImportResponse415
  | validateProductImportResponse422
  | validateProductImportResponse500
) & {
  headers: Headers
}

export type validateProductImportResponse =
  | validateProductImportResponseSuccess
  | validateProductImportResponseError

export const getValidateProductImportUrl = () => {
  return `/import/products/validate`
}

export const validateProductImport = async (
  validateProductImportBody: unknown | ValidateProductImportBodyTwo,
  options?: RequestInit
): Promise<validateProductImportResponse> => {
  return customInstance<validateProductImportResponse>(getValidateProductImportUrl(), {
    ...options,
    method: 'POST',
    body: JSON.stringify(validateProductImportBody),
  })
}

export const getValidateProductImportMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof validateProductImport>>,
    TError,
    { data: unknown | ValidateProductImportBodyTwo },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof validateProductImport>>,
  TError,
  { data: unknown | ValidateProductImportBodyTwo },
  TContext
> => {
  const mutationKey = ['validateProductImport']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof validateProductImport>>,
    { data: unknown | ValidateProductImportBodyTwo }
  > = (props) => {
    const { data } = props ?? {}

    return validateProductImport(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ValidateProductImportMutationResult = NonNullable<
  Awaited<ReturnType<typeof validateProductImport>>
>
export type ValidateProductImportMutationBody = unknown | ValidateProductImportBodyTwo
export type ValidateProductImportMutationError = DtoErrorResponse

/**
 * @summary Validate product CSV file for import
 */
export const useValidateProductImport = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof validateProductImport>>,
      TError,
      { data: unknown | ValidateProductImportBodyTwo },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof validateProductImport>>,
  TError,
  { data: unknown | ValidateProductImportBodyTwo },
  TContext
> => {
  return useMutation(getValidateProductImportMutationOptions(options), queryClient)
}
/**
 * Retrieves the status and details of an import session
 * @summary Get import session
 */
export type getImportSessionResponse200 = {
  data: HandlerAPIResponseCsvimportImportSession
  status: 200
}

export type getImportSessionResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getImportSessionResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getImportSessionResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getImportSessionResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getImportSessionResponseSuccess = getImportSessionResponse200 & {
  headers: Headers
}
export type getImportSessionResponseError = (
  | getImportSessionResponse400
  | getImportSessionResponse401
  | getImportSessionResponse404
  | getImportSessionResponse500
) & {
  headers: Headers
}

export type getImportSessionResponse =
  | getImportSessionResponseSuccess
  | getImportSessionResponseError

export const getGetImportSessionUrl = (id: string) => {
  return `/import/sessions/${id}`
}

export const getImportSession = async (
  id: string,
  options?: RequestInit
): Promise<getImportSessionResponse> => {
  return customInstance<getImportSessionResponse>(getGetImportSessionUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetImportSessionQueryKey = (id: string) => {
  return [`/import/sessions/${id}`] as const
}

export const getGetImportSessionQueryOptions = <
  TData = Awaited<ReturnType<typeof getImportSession>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportSession>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetImportSessionQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImportSession>>> = ({ signal }) =>
    getImportSession(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getImportSession>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetImportSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getImportSession>>>
export type GetImportSessionQueryError = DtoErrorResponse

export function useGetImportSession<
  TData = Awaited<ReturnType<typeof getImportSession>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportSession>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getImportSession>>,
          TError,
          Awaited<ReturnType<typeof getImportSession>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetImportSession<
  TData = Awaited<ReturnType<typeof getImportSession>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportSession>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getImportSession>>,
          TError,
          Awaited<ReturnType<typeof getImportSession>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetImportSession<
  TData = Awaited<ReturnType<typeof getImportSession>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportSession>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get import session
 */

export function useGetImportSession<
  TData = Awaited<ReturnType<typeof getImportSession>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportSession>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetImportSessionQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Imports suppliers from a previously validated CSV file
 * @summary Import suppliers from validated CSV
 */
export type importSuppliersResponse200 = {
  data: HandlerAPIResponseHandlerSupplierImportResponse
  status: 200
}

export type importSuppliersResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type importSuppliersResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type importSuppliersResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type importSuppliersResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type importSuppliersResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type importSuppliersResponseSuccess = importSuppliersResponse200 & {
  headers: Headers
}
export type importSuppliersResponseError = (
  | importSuppliersResponse400
  | importSuppliersResponse401
  | importSuppliersResponse404
  | importSuppliersResponse422
  | importSuppliersResponse500
) & {
  headers: Headers
}

export type importSuppliersResponse = importSuppliersResponseSuccess | importSuppliersResponseError

export const getImportSuppliersUrl = () => {
  return `/import/suppliers`
}

export const importSuppliers = async (
  importSuppliersBody: ImportSuppliersBody,
  options?: RequestInit
): Promise<importSuppliersResponse> => {
  return customInstance<importSuppliersResponse>(getImportSuppliersUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(importSuppliersBody),
  })
}

export const getImportSuppliersMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof importSuppliers>>,
    TError,
    { data: ImportSuppliersBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof importSuppliers>>,
  TError,
  { data: ImportSuppliersBody },
  TContext
> => {
  const mutationKey = ['importSuppliers']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importSuppliers>>,
    { data: ImportSuppliersBody }
  > = (props) => {
    const { data } = props ?? {}

    return importSuppliers(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ImportSuppliersMutationResult = NonNullable<Awaited<ReturnType<typeof importSuppliers>>>
export type ImportSuppliersMutationBody = ImportSuppliersBody
export type ImportSuppliersMutationError = DtoErrorResponse

/**
 * @summary Import suppliers from validated CSV
 */
export const useImportSuppliers = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof importSuppliers>>,
      TError,
      { data: ImportSuppliersBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof importSuppliers>>,
  TError,
  { data: ImportSuppliersBody },
  TContext
> => {
  return useMutation(getImportSuppliersMutationOptions(options), queryClient)
}
/**
 * Validates a supplier CSV file for import without actually importing the data
 * @summary Validate supplier CSV file for import
 */
export type validateSupplierImportResponse200 = {
  data: HandlerAPIResponseHandlerSupplierValidationResponse
  status: 200
}

export type validateSupplierImportResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type validateSupplierImportResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type validateSupplierImportResponse413 = {
  data: DtoErrorResponse
  status: 413
}

export type validateSupplierImportResponse415 = {
  data: DtoErrorResponse
  status: 415
}

export type validateSupplierImportResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type validateSupplierImportResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type validateSupplierImportResponseSuccess = validateSupplierImportResponse200 & {
  headers: Headers
}
export type validateSupplierImportResponseError = (
  | validateSupplierImportResponse400
  | validateSupplierImportResponse401
  | validateSupplierImportResponse413
  | validateSupplierImportResponse415
  | validateSupplierImportResponse422
  | validateSupplierImportResponse500
) & {
  headers: Headers
}

export type validateSupplierImportResponse =
  | validateSupplierImportResponseSuccess
  | validateSupplierImportResponseError

export const getValidateSupplierImportUrl = () => {
  return `/import/suppliers/validate`
}

export const validateSupplierImport = async (
  validateSupplierImportBody: unknown | ValidateSupplierImportBodyTwo,
  options?: RequestInit
): Promise<validateSupplierImportResponse> => {
  return customInstance<validateSupplierImportResponse>(getValidateSupplierImportUrl(), {
    ...options,
    method: 'POST',
    body: JSON.stringify(validateSupplierImportBody),
  })
}

export const getValidateSupplierImportMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof validateSupplierImport>>,
    TError,
    { data: unknown | ValidateSupplierImportBodyTwo },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof validateSupplierImport>>,
  TError,
  { data: unknown | ValidateSupplierImportBodyTwo },
  TContext
> => {
  const mutationKey = ['validateSupplierImport']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof validateSupplierImport>>,
    { data: unknown | ValidateSupplierImportBodyTwo }
  > = (props) => {
    const { data } = props ?? {}

    return validateSupplierImport(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ValidateSupplierImportMutationResult = NonNullable<
  Awaited<ReturnType<typeof validateSupplierImport>>
>
export type ValidateSupplierImportMutationBody = unknown | ValidateSupplierImportBodyTwo
export type ValidateSupplierImportMutationError = DtoErrorResponse

/**
 * @summary Validate supplier CSV file for import
 */
export const useValidateSupplierImport = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof validateSupplierImport>>,
      TError,
      { data: unknown | ValidateSupplierImportBodyTwo },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof validateSupplierImport>>,
  TError,
  { data: unknown | ValidateSupplierImportBodyTwo },
  TContext
> => {
  return useMutation(getValidateSupplierImportMutationOptions(options), queryClient)
}
/**
 * Validates a CSV file for import without actually importing the data
 * @summary Validate CSV file for import
 */
export type validateImportResponse200 = {
  data: HandlerAPIResponseHandlerValidationResponse
  status: 200
}

export type validateImportResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type validateImportResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type validateImportResponse413 = {
  data: DtoErrorResponse
  status: 413
}

export type validateImportResponse415 = {
  data: DtoErrorResponse
  status: 415
}

export type validateImportResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type validateImportResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type validateImportResponseSuccess = validateImportResponse200 & {
  headers: Headers
}
export type validateImportResponseError = (
  | validateImportResponse400
  | validateImportResponse401
  | validateImportResponse413
  | validateImportResponse415
  | validateImportResponse422
  | validateImportResponse500
) & {
  headers: Headers
}

export type validateImportResponse = validateImportResponseSuccess | validateImportResponseError

export const getValidateImportUrl = () => {
  return `/import/validate`
}

export const validateImport = async (
  validateImportBody:
    | unknown
    | 'products'
    | 'customers'
    | 'suppliers'
    | 'inventory'
    | ValidateImportBodyTwo,
  options?: RequestInit
): Promise<validateImportResponse> => {
  return customInstance<validateImportResponse>(getValidateImportUrl(), {
    ...options,
    method: 'POST',
    body: JSON.stringify(validateImportBody),
  })
}

export const getValidateImportMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof validateImport>>,
    TError,
    {
      data: unknown | 'products' | 'customers' | 'suppliers' | 'inventory' | ValidateImportBodyTwo
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof validateImport>>,
  TError,
  { data: unknown | 'products' | 'customers' | 'suppliers' | 'inventory' | ValidateImportBodyTwo },
  TContext
> => {
  const mutationKey = ['validateImport']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof validateImport>>,
    { data: unknown | 'products' | 'customers' | 'suppliers' | 'inventory' | ValidateImportBodyTwo }
  > = (props) => {
    const { data } = props ?? {}

    return validateImport(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ValidateImportMutationResult = NonNullable<Awaited<ReturnType<typeof validateImport>>>
export type ValidateImportMutationBody =
  | unknown
  | 'products'
  | 'customers'
  | 'suppliers'
  | 'inventory'
  | ValidateImportBodyTwo
export type ValidateImportMutationError = DtoErrorResponse

/**
 * @summary Validate CSV file for import
 */
export const useValidateImport = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof validateImport>>,
      TError,
      {
        data: unknown | 'products' | 'customers' | 'suppliers' | 'inventory' | ValidateImportBodyTwo
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof validateImport>>,
  TError,
  { data: unknown | 'products' | 'customers' | 'suppliers' | 'inventory' | ValidateImportBodyTwo },
  TContext
> => {
  return useMutation(getValidateImportMutationOptions(options), queryClient)
}

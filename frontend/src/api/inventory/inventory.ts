/**
 * // This file is auto-generated by orval
 * // Do not edit manually
 *
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  AdjustStockInventoryBody,
  CheckAvailabilityInventoryBody,
  DeductStockInventoryBody,
  DtoErrorResponse,
  GetInventoryActiveLocksParams,
  GetInventoryByWarehouseAndProductParams,
  HandlerAPIResponseArrayHandlerInventoryItemResponse,
  HandlerAPIResponseArrayHandlerStockLockResponse,
  HandlerAPIResponseArrayHandlerTransactionResponse,
  HandlerAPIResponseHandlerCheckAvailabilityResponse,
  HandlerAPIResponseHandlerInventoryItemResponse,
  HandlerAPIResponseHandlerLockStockResponse,
  HandlerAPIResponseHandlerStockLockResponse,
  HandlerAPIResponseHandlerTransactionResponse,
  IncreaseStockInventoryBody,
  ListInventoriesParams,
  ListInventoryBelowMinimumParams,
  ListInventoryByProductParams,
  ListInventoryByWarehouseParams,
  ListInventoryTransactionsByItemParams,
  ListInventoryTransactionsParams,
  LockStockInventoryBody,
  SetThresholdsInventoryBody,
  UnlockStockInventoryBody,
} from '.././models'

import { customInstance } from '../../services/axios-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Check if a specific quantity is available for a product in a warehouse
 * @summary Check stock availability
 */
export type checkAvailabilityInventoryResponse200 = {
  data: HandlerAPIResponseHandlerCheckAvailabilityResponse
  status: 200
}

export type checkAvailabilityInventoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type checkAvailabilityInventoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type checkAvailabilityInventoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type checkAvailabilityInventoryResponseSuccess = checkAvailabilityInventoryResponse200 & {
  headers: Headers
}
export type checkAvailabilityInventoryResponseError = (
  | checkAvailabilityInventoryResponse400
  | checkAvailabilityInventoryResponse401
  | checkAvailabilityInventoryResponse500
) & {
  headers: Headers
}

export type checkAvailabilityInventoryResponse =
  | checkAvailabilityInventoryResponseSuccess
  | checkAvailabilityInventoryResponseError

export const getCheckAvailabilityInventoryUrl = () => {
  return `/inventory/availability/check`
}

export const checkAvailabilityInventory = async (
  checkAvailabilityInventoryBody: CheckAvailabilityInventoryBody,
  options?: RequestInit
): Promise<checkAvailabilityInventoryResponse> => {
  return customInstance<checkAvailabilityInventoryResponse>(getCheckAvailabilityInventoryUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(checkAvailabilityInventoryBody),
  })
}

export const getCheckAvailabilityInventoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof checkAvailabilityInventory>>,
    TError,
    { data: CheckAvailabilityInventoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof checkAvailabilityInventory>>,
  TError,
  { data: CheckAvailabilityInventoryBody },
  TContext
> => {
  const mutationKey = ['checkAvailabilityInventory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof checkAvailabilityInventory>>,
    { data: CheckAvailabilityInventoryBody }
  > = (props) => {
    const { data } = props ?? {}

    return checkAvailabilityInventory(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CheckAvailabilityInventoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof checkAvailabilityInventory>>
>
export type CheckAvailabilityInventoryMutationBody = CheckAvailabilityInventoryBody
export type CheckAvailabilityInventoryMutationError = DtoErrorResponse

/**
 * @summary Check stock availability
 */
export const useCheckAvailabilityInventory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof checkAvailabilityInventory>>,
      TError,
      { data: CheckAvailabilityInventoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof checkAvailabilityInventory>>,
  TError,
  { data: CheckAvailabilityInventoryBody },
  TContext
> => {
  return useMutation(getCheckAvailabilityInventoryMutationOptions(options), queryClient)
}
/**
 * Retrieve a paginated list of inventory items with optional filtering
 * @summary List inventory items
 */
export type listInventoriesResponse200 = {
  data: HandlerAPIResponseArrayHandlerInventoryItemResponse
  status: 200
}

export type listInventoriesResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listInventoriesResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listInventoriesResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listInventoriesResponseSuccess = listInventoriesResponse200 & {
  headers: Headers
}
export type listInventoriesResponseError = (
  | listInventoriesResponse400
  | listInventoriesResponse401
  | listInventoriesResponse500
) & {
  headers: Headers
}

export type listInventoriesResponse = listInventoriesResponseSuccess | listInventoriesResponseError

export const getListInventoriesUrl = (params?: ListInventoriesParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/inventory/items?${stringifiedParams}` : `/inventory/items`
}

export const listInventories = async (
  params?: ListInventoriesParams,
  options?: RequestInit
): Promise<listInventoriesResponse> => {
  return customInstance<listInventoriesResponse>(getListInventoriesUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getListInventoriesQueryKey = (params?: ListInventoriesParams) => {
  return [`/inventory/items`, ...(params ? [params] : [])] as const
}

export const getListInventoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof listInventories>>,
  TError = DtoErrorResponse,
>(
  params?: ListInventoriesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listInventories>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListInventoriesQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listInventories>>> = ({ signal }) =>
    listInventories(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listInventories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListInventoriesQueryResult = NonNullable<Awaited<ReturnType<typeof listInventories>>>
export type ListInventoriesQueryError = DtoErrorResponse

export function useListInventories<
  TData = Awaited<ReturnType<typeof listInventories>>,
  TError = DtoErrorResponse,
>(
  params: undefined | ListInventoriesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listInventories>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventories>>,
          TError,
          Awaited<ReturnType<typeof listInventories>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInventories<
  TData = Awaited<ReturnType<typeof listInventories>>,
  TError = DtoErrorResponse,
>(
  params?: ListInventoriesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listInventories>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventories>>,
          TError,
          Awaited<ReturnType<typeof listInventories>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInventories<
  TData = Awaited<ReturnType<typeof listInventories>>,
  TError = DtoErrorResponse,
>(
  params?: ListInventoriesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listInventories>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List inventory items
 */

export function useListInventories<
  TData = Awaited<ReturnType<typeof listInventories>>,
  TError = DtoErrorResponse,
>(
  params?: ListInventoriesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listInventories>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListInventoriesQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Retrieve an inventory item by its ID
 * @summary Get inventory item by ID
 */
export type getInventoryByIdResponse200 = {
  data: HandlerAPIResponseHandlerInventoryItemResponse
  status: 200
}

export type getInventoryByIdResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getInventoryByIdResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getInventoryByIdResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getInventoryByIdResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getInventoryByIdResponseSuccess = getInventoryByIdResponse200 & {
  headers: Headers
}
export type getInventoryByIdResponseError = (
  | getInventoryByIdResponse400
  | getInventoryByIdResponse401
  | getInventoryByIdResponse404
  | getInventoryByIdResponse500
) & {
  headers: Headers
}

export type getInventoryByIdResponse =
  | getInventoryByIdResponseSuccess
  | getInventoryByIdResponseError

export const getGetInventoryByIdUrl = (id: string) => {
  return `/inventory/items/${id}`
}

export const getInventoryById = async (
  id: string,
  options?: RequestInit
): Promise<getInventoryByIdResponse> => {
  return customInstance<getInventoryByIdResponse>(getGetInventoryByIdUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetInventoryByIdQueryKey = (id: string) => {
  return [`/inventory/items/${id}`] as const
}

export const getGetInventoryByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getInventoryById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInventoryById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInventoryByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInventoryById>>> = ({ signal }) =>
    getInventoryById(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventoryById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInventoryByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getInventoryById>>>
export type GetInventoryByIdQueryError = DtoErrorResponse

export function useGetInventoryById<
  TData = Awaited<ReturnType<typeof getInventoryById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInventoryById>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryById>>,
          TError,
          Awaited<ReturnType<typeof getInventoryById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInventoryById<
  TData = Awaited<ReturnType<typeof getInventoryById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInventoryById>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryById>>,
          TError,
          Awaited<ReturnType<typeof getInventoryById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInventoryById<
  TData = Awaited<ReturnType<typeof getInventoryById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInventoryById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get inventory item by ID
 */

export function useGetInventoryById<
  TData = Awaited<ReturnType<typeof getInventoryById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getInventoryById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInventoryByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Retrieve transactions for a specific inventory item
 * @summary List transactions by inventory item
 */
export type listInventoryTransactionsByItemResponse200 = {
  data: HandlerAPIResponseArrayHandlerTransactionResponse
  status: 200
}

export type listInventoryTransactionsByItemResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listInventoryTransactionsByItemResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listInventoryTransactionsByItemResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type listInventoryTransactionsByItemResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listInventoryTransactionsByItemResponseSuccess =
  listInventoryTransactionsByItemResponse200 & {
    headers: Headers
  }
export type listInventoryTransactionsByItemResponseError = (
  | listInventoryTransactionsByItemResponse400
  | listInventoryTransactionsByItemResponse401
  | listInventoryTransactionsByItemResponse404
  | listInventoryTransactionsByItemResponse500
) & {
  headers: Headers
}

export type listInventoryTransactionsByItemResponse =
  | listInventoryTransactionsByItemResponseSuccess
  | listInventoryTransactionsByItemResponseError

export const getListInventoryTransactionsByItemUrl = (
  id: string,
  params?: ListInventoryTransactionsByItemParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/inventory/items/${id}/transactions?${stringifiedParams}`
    : `/inventory/items/${id}/transactions`
}

export const listInventoryTransactionsByItem = async (
  id: string,
  params?: ListInventoryTransactionsByItemParams,
  options?: RequestInit
): Promise<listInventoryTransactionsByItemResponse> => {
  return customInstance<listInventoryTransactionsByItemResponse>(
    getListInventoryTransactionsByItemUrl(id, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getListInventoryTransactionsByItemQueryKey = (
  id: string,
  params?: ListInventoryTransactionsByItemParams
) => {
  return [`/inventory/items/${id}/transactions`, ...(params ? [params] : [])] as const
}

export const getListInventoryTransactionsByItemQueryOptions = <
  TData = Awaited<ReturnType<typeof listInventoryTransactionsByItem>>,
  TError = DtoErrorResponse,
>(
  id: string,
  params?: ListInventoryTransactionsByItemParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryTransactionsByItem>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListInventoryTransactionsByItemQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listInventoryTransactionsByItem>>> = ({
    signal,
  }) => listInventoryTransactionsByItem(id, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listInventoryTransactionsByItem>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListInventoryTransactionsByItemQueryResult = NonNullable<
  Awaited<ReturnType<typeof listInventoryTransactionsByItem>>
>
export type ListInventoryTransactionsByItemQueryError = DtoErrorResponse

export function useListInventoryTransactionsByItem<
  TData = Awaited<ReturnType<typeof listInventoryTransactionsByItem>>,
  TError = DtoErrorResponse,
>(
  id: string,
  params: undefined | ListInventoryTransactionsByItemParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryTransactionsByItem>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventoryTransactionsByItem>>,
          TError,
          Awaited<ReturnType<typeof listInventoryTransactionsByItem>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInventoryTransactionsByItem<
  TData = Awaited<ReturnType<typeof listInventoryTransactionsByItem>>,
  TError = DtoErrorResponse,
>(
  id: string,
  params?: ListInventoryTransactionsByItemParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryTransactionsByItem>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventoryTransactionsByItem>>,
          TError,
          Awaited<ReturnType<typeof listInventoryTransactionsByItem>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInventoryTransactionsByItem<
  TData = Awaited<ReturnType<typeof listInventoryTransactionsByItem>>,
  TError = DtoErrorResponse,
>(
  id: string,
  params?: ListInventoryTransactionsByItemParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryTransactionsByItem>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List transactions by inventory item
 */

export function useListInventoryTransactionsByItem<
  TData = Awaited<ReturnType<typeof listInventoryTransactionsByItem>>,
  TError = DtoErrorResponse,
>(
  id: string,
  params?: ListInventoryTransactionsByItemParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryTransactionsByItem>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListInventoryTransactionsByItemQueryOptions(id, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Retrieve inventory items that are below their minimum threshold (low stock alerts)
 * @summary List inventory below minimum threshold
 */
export type listInventoryBelowMinimumResponse200 = {
  data: HandlerAPIResponseArrayHandlerInventoryItemResponse
  status: 200
}

export type listInventoryBelowMinimumResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listInventoryBelowMinimumResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listInventoryBelowMinimumResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listInventoryBelowMinimumResponseSuccess = listInventoryBelowMinimumResponse200 & {
  headers: Headers
}
export type listInventoryBelowMinimumResponseError = (
  | listInventoryBelowMinimumResponse400
  | listInventoryBelowMinimumResponse401
  | listInventoryBelowMinimumResponse500
) & {
  headers: Headers
}

export type listInventoryBelowMinimumResponse =
  | listInventoryBelowMinimumResponseSuccess
  | listInventoryBelowMinimumResponseError

export const getListInventoryBelowMinimumUrl = (params?: ListInventoryBelowMinimumParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/inventory/items/alerts/low-stock?${stringifiedParams}`
    : `/inventory/items/alerts/low-stock`
}

export const listInventoryBelowMinimum = async (
  params?: ListInventoryBelowMinimumParams,
  options?: RequestInit
): Promise<listInventoryBelowMinimumResponse> => {
  return customInstance<listInventoryBelowMinimumResponse>(
    getListInventoryBelowMinimumUrl(params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getListInventoryBelowMinimumQueryKey = (params?: ListInventoryBelowMinimumParams) => {
  return [`/inventory/items/alerts/low-stock`, ...(params ? [params] : [])] as const
}

export const getListInventoryBelowMinimumQueryOptions = <
  TData = Awaited<ReturnType<typeof listInventoryBelowMinimum>>,
  TError = DtoErrorResponse,
>(
  params?: ListInventoryBelowMinimumParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryBelowMinimum>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListInventoryBelowMinimumQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listInventoryBelowMinimum>>> = ({
    signal,
  }) => listInventoryBelowMinimum(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listInventoryBelowMinimum>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListInventoryBelowMinimumQueryResult = NonNullable<
  Awaited<ReturnType<typeof listInventoryBelowMinimum>>
>
export type ListInventoryBelowMinimumQueryError = DtoErrorResponse

export function useListInventoryBelowMinimum<
  TData = Awaited<ReturnType<typeof listInventoryBelowMinimum>>,
  TError = DtoErrorResponse,
>(
  params: undefined | ListInventoryBelowMinimumParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryBelowMinimum>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventoryBelowMinimum>>,
          TError,
          Awaited<ReturnType<typeof listInventoryBelowMinimum>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInventoryBelowMinimum<
  TData = Awaited<ReturnType<typeof listInventoryBelowMinimum>>,
  TError = DtoErrorResponse,
>(
  params?: ListInventoryBelowMinimumParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryBelowMinimum>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventoryBelowMinimum>>,
          TError,
          Awaited<ReturnType<typeof listInventoryBelowMinimum>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInventoryBelowMinimum<
  TData = Awaited<ReturnType<typeof listInventoryBelowMinimum>>,
  TError = DtoErrorResponse,
>(
  params?: ListInventoryBelowMinimumParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryBelowMinimum>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List inventory below minimum threshold
 */

export function useListInventoryBelowMinimum<
  TData = Awaited<ReturnType<typeof listInventoryBelowMinimum>>,
  TError = DtoErrorResponse,
>(
  params?: ListInventoryBelowMinimumParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryBelowMinimum>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListInventoryBelowMinimumQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Retrieve inventory for a specific warehouse-product combination
 * @summary Get inventory by warehouse and product
 */
export type getInventoryByWarehouseAndProductResponse200 = {
  data: HandlerAPIResponseHandlerInventoryItemResponse
  status: 200
}

export type getInventoryByWarehouseAndProductResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getInventoryByWarehouseAndProductResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getInventoryByWarehouseAndProductResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getInventoryByWarehouseAndProductResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getInventoryByWarehouseAndProductResponseSuccess =
  getInventoryByWarehouseAndProductResponse200 & {
    headers: Headers
  }
export type getInventoryByWarehouseAndProductResponseError = (
  | getInventoryByWarehouseAndProductResponse400
  | getInventoryByWarehouseAndProductResponse401
  | getInventoryByWarehouseAndProductResponse404
  | getInventoryByWarehouseAndProductResponse500
) & {
  headers: Headers
}

export type getInventoryByWarehouseAndProductResponse =
  | getInventoryByWarehouseAndProductResponseSuccess
  | getInventoryByWarehouseAndProductResponseError

export const getGetInventoryByWarehouseAndProductUrl = (
  params: GetInventoryByWarehouseAndProductParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/inventory/items/lookup?${stringifiedParams}`
    : `/inventory/items/lookup`
}

export const getInventoryByWarehouseAndProduct = async (
  params: GetInventoryByWarehouseAndProductParams,
  options?: RequestInit
): Promise<getInventoryByWarehouseAndProductResponse> => {
  return customInstance<getInventoryByWarehouseAndProductResponse>(
    getGetInventoryByWarehouseAndProductUrl(params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getGetInventoryByWarehouseAndProductQueryKey = (
  params?: GetInventoryByWarehouseAndProductParams
) => {
  return [`/inventory/items/lookup`, ...(params ? [params] : [])] as const
}

export const getGetInventoryByWarehouseAndProductQueryOptions = <
  TData = Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>,
  TError = DtoErrorResponse,
>(
  params: GetInventoryByWarehouseAndProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInventoryByWarehouseAndProductQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>> = ({
    signal,
  }) => getInventoryByWarehouseAndProduct(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInventoryByWarehouseAndProductQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>
>
export type GetInventoryByWarehouseAndProductQueryError = DtoErrorResponse

export function useGetInventoryByWarehouseAndProduct<
  TData = Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>,
  TError = DtoErrorResponse,
>(
  params: GetInventoryByWarehouseAndProductParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>,
          TError,
          Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInventoryByWarehouseAndProduct<
  TData = Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>,
  TError = DtoErrorResponse,
>(
  params: GetInventoryByWarehouseAndProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>,
          TError,
          Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInventoryByWarehouseAndProduct<
  TData = Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>,
  TError = DtoErrorResponse,
>(
  params: GetInventoryByWarehouseAndProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get inventory by warehouse and product
 */

export function useGetInventoryByWarehouseAndProduct<
  TData = Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>,
  TError = DtoErrorResponse,
>(
  params: GetInventoryByWarehouseAndProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryByWarehouseAndProduct>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInventoryByWarehouseAndProductQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Retrieve all active (unexpired, unreleased) locks for an inventory item
 * @summary Get active locks
 */
export type getInventoryActiveLocksResponse200 = {
  data: HandlerAPIResponseArrayHandlerStockLockResponse
  status: 200
}

export type getInventoryActiveLocksResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getInventoryActiveLocksResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getInventoryActiveLocksResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getInventoryActiveLocksResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getInventoryActiveLocksResponseSuccess = getInventoryActiveLocksResponse200 & {
  headers: Headers
}
export type getInventoryActiveLocksResponseError = (
  | getInventoryActiveLocksResponse400
  | getInventoryActiveLocksResponse401
  | getInventoryActiveLocksResponse404
  | getInventoryActiveLocksResponse500
) & {
  headers: Headers
}

export type getInventoryActiveLocksResponse =
  | getInventoryActiveLocksResponseSuccess
  | getInventoryActiveLocksResponseError

export const getGetInventoryActiveLocksUrl = (params: GetInventoryActiveLocksParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/inventory/locks?${stringifiedParams}` : `/inventory/locks`
}

export const getInventoryActiveLocks = async (
  params: GetInventoryActiveLocksParams,
  options?: RequestInit
): Promise<getInventoryActiveLocksResponse> => {
  return customInstance<getInventoryActiveLocksResponse>(getGetInventoryActiveLocksUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getGetInventoryActiveLocksQueryKey = (params?: GetInventoryActiveLocksParams) => {
  return [`/inventory/locks`, ...(params ? [params] : [])] as const
}

export const getGetInventoryActiveLocksQueryOptions = <
  TData = Awaited<ReturnType<typeof getInventoryActiveLocks>>,
  TError = DtoErrorResponse,
>(
  params: GetInventoryActiveLocksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryActiveLocks>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInventoryActiveLocksQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInventoryActiveLocks>>> = ({
    signal,
  }) => getInventoryActiveLocks(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventoryActiveLocks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInventoryActiveLocksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInventoryActiveLocks>>
>
export type GetInventoryActiveLocksQueryError = DtoErrorResponse

export function useGetInventoryActiveLocks<
  TData = Awaited<ReturnType<typeof getInventoryActiveLocks>>,
  TError = DtoErrorResponse,
>(
  params: GetInventoryActiveLocksParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryActiveLocks>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryActiveLocks>>,
          TError,
          Awaited<ReturnType<typeof getInventoryActiveLocks>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInventoryActiveLocks<
  TData = Awaited<ReturnType<typeof getInventoryActiveLocks>>,
  TError = DtoErrorResponse,
>(
  params: GetInventoryActiveLocksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryActiveLocks>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryActiveLocks>>,
          TError,
          Awaited<ReturnType<typeof getInventoryActiveLocks>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInventoryActiveLocks<
  TData = Awaited<ReturnType<typeof getInventoryActiveLocks>>,
  TError = DtoErrorResponse,
>(
  params: GetInventoryActiveLocksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryActiveLocks>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get active locks
 */

export function useGetInventoryActiveLocks<
  TData = Awaited<ReturnType<typeof getInventoryActiveLocks>>,
  TError = DtoErrorResponse,
>(
  params: GetInventoryActiveLocksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryActiveLocks>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInventoryActiveLocksQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Retrieve a specific stock lock by ID
 * @summary Get lock by ID
 */
export type getInventoryLockByIDResponse200 = {
  data: HandlerAPIResponseHandlerStockLockResponse
  status: 200
}

export type getInventoryLockByIDResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getInventoryLockByIDResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getInventoryLockByIDResponse403 = {
  data: DtoErrorResponse
  status: 403
}

export type getInventoryLockByIDResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getInventoryLockByIDResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getInventoryLockByIDResponseSuccess = getInventoryLockByIDResponse200 & {
  headers: Headers
}
export type getInventoryLockByIDResponseError = (
  | getInventoryLockByIDResponse400
  | getInventoryLockByIDResponse401
  | getInventoryLockByIDResponse403
  | getInventoryLockByIDResponse404
  | getInventoryLockByIDResponse500
) & {
  headers: Headers
}

export type getInventoryLockByIDResponse =
  | getInventoryLockByIDResponseSuccess
  | getInventoryLockByIDResponseError

export const getGetInventoryLockByIDUrl = (id: string) => {
  return `/inventory/locks/${id}`
}

export const getInventoryLockByID = async (
  id: string,
  options?: RequestInit
): Promise<getInventoryLockByIDResponse> => {
  return customInstance<getInventoryLockByIDResponse>(getGetInventoryLockByIDUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetInventoryLockByIDQueryKey = (id: string) => {
  return [`/inventory/locks/${id}`] as const
}

export const getGetInventoryLockByIDQueryOptions = <
  TData = Awaited<ReturnType<typeof getInventoryLockByID>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryLockByID>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInventoryLockByIDQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInventoryLockByID>>> = ({ signal }) =>
    getInventoryLockByID(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventoryLockByID>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInventoryLockByIDQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInventoryLockByID>>
>
export type GetInventoryLockByIDQueryError = DtoErrorResponse

export function useGetInventoryLockByID<
  TData = Awaited<ReturnType<typeof getInventoryLockByID>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryLockByID>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryLockByID>>,
          TError,
          Awaited<ReturnType<typeof getInventoryLockByID>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInventoryLockByID<
  TData = Awaited<ReturnType<typeof getInventoryLockByID>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryLockByID>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryLockByID>>,
          TError,
          Awaited<ReturnType<typeof getInventoryLockByID>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInventoryLockByID<
  TData = Awaited<ReturnType<typeof getInventoryLockByID>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryLockByID>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get lock by ID
 */

export function useGetInventoryLockByID<
  TData = Awaited<ReturnType<typeof getInventoryLockByID>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryLockByID>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInventoryLockByIDQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Retrieve inventory items for a specific product across all warehouses
 * @summary List inventory by product
 */
export type listInventoryByProductResponse200 = {
  data: HandlerAPIResponseArrayHandlerInventoryItemResponse
  status: 200
}

export type listInventoryByProductResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listInventoryByProductResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listInventoryByProductResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listInventoryByProductResponseSuccess = listInventoryByProductResponse200 & {
  headers: Headers
}
export type listInventoryByProductResponseError = (
  | listInventoryByProductResponse400
  | listInventoryByProductResponse401
  | listInventoryByProductResponse500
) & {
  headers: Headers
}

export type listInventoryByProductResponse =
  | listInventoryByProductResponseSuccess
  | listInventoryByProductResponseError

export const getListInventoryByProductUrl = (
  productId: string,
  params?: ListInventoryByProductParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/inventory/products/${productId}/items?${stringifiedParams}`
    : `/inventory/products/${productId}/items`
}

export const listInventoryByProduct = async (
  productId: string,
  params?: ListInventoryByProductParams,
  options?: RequestInit
): Promise<listInventoryByProductResponse> => {
  return customInstance<listInventoryByProductResponse>(
    getListInventoryByProductUrl(productId, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getListInventoryByProductQueryKey = (
  productId: string,
  params?: ListInventoryByProductParams
) => {
  return [`/inventory/products/${productId}/items`, ...(params ? [params] : [])] as const
}

export const getListInventoryByProductQueryOptions = <
  TData = Awaited<ReturnType<typeof listInventoryByProduct>>,
  TError = DtoErrorResponse,
>(
  productId: string,
  params?: ListInventoryByProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryByProduct>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListInventoryByProductQueryKey(productId, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listInventoryByProduct>>> = ({ signal }) =>
    listInventoryByProduct(productId, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!productId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listInventoryByProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListInventoryByProductQueryResult = NonNullable<
  Awaited<ReturnType<typeof listInventoryByProduct>>
>
export type ListInventoryByProductQueryError = DtoErrorResponse

export function useListInventoryByProduct<
  TData = Awaited<ReturnType<typeof listInventoryByProduct>>,
  TError = DtoErrorResponse,
>(
  productId: string,
  params: undefined | ListInventoryByProductParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryByProduct>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventoryByProduct>>,
          TError,
          Awaited<ReturnType<typeof listInventoryByProduct>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInventoryByProduct<
  TData = Awaited<ReturnType<typeof listInventoryByProduct>>,
  TError = DtoErrorResponse,
>(
  productId: string,
  params?: ListInventoryByProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryByProduct>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventoryByProduct>>,
          TError,
          Awaited<ReturnType<typeof listInventoryByProduct>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInventoryByProduct<
  TData = Awaited<ReturnType<typeof listInventoryByProduct>>,
  TError = DtoErrorResponse,
>(
  productId: string,
  params?: ListInventoryByProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryByProduct>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List inventory by product
 */

export function useListInventoryByProduct<
  TData = Awaited<ReturnType<typeof listInventoryByProduct>>,
  TError = DtoErrorResponse,
>(
  productId: string,
  params?: ListInventoryByProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryByProduct>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListInventoryByProductQueryOptions(productId, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Adjust stock to match actual quantity (stock count/adjustment)
 * @summary Adjust stock
 */
export type adjustStockInventoryResponse200 = {
  data: HandlerAPIResponseHandlerInventoryItemResponse
  status: 200
}

export type adjustStockInventoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type adjustStockInventoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type adjustStockInventoryResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type adjustStockInventoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type adjustStockInventoryResponseSuccess = adjustStockInventoryResponse200 & {
  headers: Headers
}
export type adjustStockInventoryResponseError = (
  | adjustStockInventoryResponse400
  | adjustStockInventoryResponse401
  | adjustStockInventoryResponse422
  | adjustStockInventoryResponse500
) & {
  headers: Headers
}

export type adjustStockInventoryResponse =
  | adjustStockInventoryResponseSuccess
  | adjustStockInventoryResponseError

export const getAdjustStockInventoryUrl = () => {
  return `/inventory/stock/adjust`
}

export const adjustStockInventory = async (
  adjustStockInventoryBody: AdjustStockInventoryBody,
  options?: RequestInit
): Promise<adjustStockInventoryResponse> => {
  return customInstance<adjustStockInventoryResponse>(getAdjustStockInventoryUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(adjustStockInventoryBody),
  })
}

export const getAdjustStockInventoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adjustStockInventory>>,
    TError,
    { data: AdjustStockInventoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof adjustStockInventory>>,
  TError,
  { data: AdjustStockInventoryBody },
  TContext
> => {
  const mutationKey = ['adjustStockInventory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adjustStockInventory>>,
    { data: AdjustStockInventoryBody }
  > = (props) => {
    const { data } = props ?? {}

    return adjustStockInventory(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AdjustStockInventoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof adjustStockInventory>>
>
export type AdjustStockInventoryMutationBody = AdjustStockInventoryBody
export type AdjustStockInventoryMutationError = DtoErrorResponse

/**
 * @summary Adjust stock
 */
export const useAdjustStockInventory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof adjustStockInventory>>,
      TError,
      { data: AdjustStockInventoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof adjustStockInventory>>,
  TError,
  { data: AdjustStockInventoryBody },
  TContext
> => {
  return useMutation(getAdjustStockInventoryMutationOptions(options), queryClient)
}
/**
 * Deduct locked stock (actual shipment/consumption)
 * @summary Deduct stock
 */
export type deductStockInventoryResponse204 = {
  data: void
  status: 204
}

export type deductStockInventoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type deductStockInventoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type deductStockInventoryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type deductStockInventoryResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type deductStockInventoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type deductStockInventoryResponseSuccess = deductStockInventoryResponse204 & {
  headers: Headers
}
export type deductStockInventoryResponseError = (
  | deductStockInventoryResponse400
  | deductStockInventoryResponse401
  | deductStockInventoryResponse404
  | deductStockInventoryResponse422
  | deductStockInventoryResponse500
) & {
  headers: Headers
}

export type deductStockInventoryResponse =
  | deductStockInventoryResponseSuccess
  | deductStockInventoryResponseError

export const getDeductStockInventoryUrl = () => {
  return `/inventory/stock/deduct`
}

export const deductStockInventory = async (
  deductStockInventoryBody: DeductStockInventoryBody,
  options?: RequestInit
): Promise<deductStockInventoryResponse> => {
  return customInstance<deductStockInventoryResponse>(getDeductStockInventoryUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(deductStockInventoryBody),
  })
}

export const getDeductStockInventoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deductStockInventory>>,
    TError,
    { data: DeductStockInventoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deductStockInventory>>,
  TError,
  { data: DeductStockInventoryBody },
  TContext
> => {
  const mutationKey = ['deductStockInventory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deductStockInventory>>,
    { data: DeductStockInventoryBody }
  > = (props) => {
    const { data } = props ?? {}

    return deductStockInventory(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeductStockInventoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deductStockInventory>>
>
export type DeductStockInventoryMutationBody = DeductStockInventoryBody
export type DeductStockInventoryMutationError = DtoErrorResponse

/**
 * @summary Deduct stock
 */
export const useDeductStockInventory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deductStockInventory>>,
      TError,
      { data: DeductStockInventoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deductStockInventory>>,
  TError,
  { data: DeductStockInventoryBody },
  TContext
> => {
  return useMutation(getDeductStockInventoryMutationOptions(options), queryClient)
}
/**
 * Increase stock for a product in a warehouse (e.g., purchase receiving, returns)
 * @summary Increase stock
 */
export type increaseStockInventoryResponse200 = {
  data: HandlerAPIResponseHandlerInventoryItemResponse
  status: 200
}

export type increaseStockInventoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type increaseStockInventoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type increaseStockInventoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type increaseStockInventoryResponseSuccess = increaseStockInventoryResponse200 & {
  headers: Headers
}
export type increaseStockInventoryResponseError = (
  | increaseStockInventoryResponse400
  | increaseStockInventoryResponse401
  | increaseStockInventoryResponse500
) & {
  headers: Headers
}

export type increaseStockInventoryResponse =
  | increaseStockInventoryResponseSuccess
  | increaseStockInventoryResponseError

export const getIncreaseStockInventoryUrl = () => {
  return `/inventory/stock/increase`
}

export const increaseStockInventory = async (
  increaseStockInventoryBody: IncreaseStockInventoryBody,
  options?: RequestInit
): Promise<increaseStockInventoryResponse> => {
  return customInstance<increaseStockInventoryResponse>(getIncreaseStockInventoryUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(increaseStockInventoryBody),
  })
}

export const getIncreaseStockInventoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof increaseStockInventory>>,
    TError,
    { data: IncreaseStockInventoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof increaseStockInventory>>,
  TError,
  { data: IncreaseStockInventoryBody },
  TContext
> => {
  const mutationKey = ['increaseStockInventory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof increaseStockInventory>>,
    { data: IncreaseStockInventoryBody }
  > = (props) => {
    const { data } = props ?? {}

    return increaseStockInventory(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type IncreaseStockInventoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof increaseStockInventory>>
>
export type IncreaseStockInventoryMutationBody = IncreaseStockInventoryBody
export type IncreaseStockInventoryMutationError = DtoErrorResponse

/**
 * @summary Increase stock
 */
export const useIncreaseStockInventory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof increaseStockInventory>>,
      TError,
      { data: IncreaseStockInventoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof increaseStockInventory>>,
  TError,
  { data: IncreaseStockInventoryBody },
  TContext
> => {
  return useMutation(getIncreaseStockInventoryMutationOptions(options), queryClient)
}
/**
 * Lock stock for a pending order (reserve inventory)
 * @summary Lock stock
 */
export type lockStockInventoryResponse200 = {
  data: HandlerAPIResponseHandlerLockStockResponse
  status: 200
}

export type lockStockInventoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type lockStockInventoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type lockStockInventoryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type lockStockInventoryResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type lockStockInventoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type lockStockInventoryResponseSuccess = lockStockInventoryResponse200 & {
  headers: Headers
}
export type lockStockInventoryResponseError = (
  | lockStockInventoryResponse400
  | lockStockInventoryResponse401
  | lockStockInventoryResponse404
  | lockStockInventoryResponse422
  | lockStockInventoryResponse500
) & {
  headers: Headers
}

export type lockStockInventoryResponse =
  | lockStockInventoryResponseSuccess
  | lockStockInventoryResponseError

export const getLockStockInventoryUrl = () => {
  return `/inventory/stock/lock`
}

export const lockStockInventory = async (
  lockStockInventoryBody: LockStockInventoryBody,
  options?: RequestInit
): Promise<lockStockInventoryResponse> => {
  return customInstance<lockStockInventoryResponse>(getLockStockInventoryUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(lockStockInventoryBody),
  })
}

export const getLockStockInventoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof lockStockInventory>>,
    TError,
    { data: LockStockInventoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof lockStockInventory>>,
  TError,
  { data: LockStockInventoryBody },
  TContext
> => {
  const mutationKey = ['lockStockInventory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof lockStockInventory>>,
    { data: LockStockInventoryBody }
  > = (props) => {
    const { data } = props ?? {}

    return lockStockInventory(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type LockStockInventoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof lockStockInventory>>
>
export type LockStockInventoryMutationBody = LockStockInventoryBody
export type LockStockInventoryMutationError = DtoErrorResponse

/**
 * @summary Lock stock
 */
export const useLockStockInventory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof lockStockInventory>>,
      TError,
      { data: LockStockInventoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof lockStockInventory>>,
  TError,
  { data: LockStockInventoryBody },
  TContext
> => {
  return useMutation(getLockStockInventoryMutationOptions(options), queryClient)
}
/**
 * Release previously locked stock back to available (e.g., order cancelled)
 * @summary Unlock stock
 */
export type unlockStockInventoryResponse204 = {
  data: void
  status: 204
}

export type unlockStockInventoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type unlockStockInventoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type unlockStockInventoryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type unlockStockInventoryResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type unlockStockInventoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type unlockStockInventoryResponseSuccess = unlockStockInventoryResponse204 & {
  headers: Headers
}
export type unlockStockInventoryResponseError = (
  | unlockStockInventoryResponse400
  | unlockStockInventoryResponse401
  | unlockStockInventoryResponse404
  | unlockStockInventoryResponse422
  | unlockStockInventoryResponse500
) & {
  headers: Headers
}

export type unlockStockInventoryResponse =
  | unlockStockInventoryResponseSuccess
  | unlockStockInventoryResponseError

export const getUnlockStockInventoryUrl = () => {
  return `/inventory/stock/unlock`
}

export const unlockStockInventory = async (
  unlockStockInventoryBody: UnlockStockInventoryBody,
  options?: RequestInit
): Promise<unlockStockInventoryResponse> => {
  return customInstance<unlockStockInventoryResponse>(getUnlockStockInventoryUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(unlockStockInventoryBody),
  })
}

export const getUnlockStockInventoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unlockStockInventory>>,
    TError,
    { data: UnlockStockInventoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof unlockStockInventory>>,
  TError,
  { data: UnlockStockInventoryBody },
  TContext
> => {
  const mutationKey = ['unlockStockInventory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unlockStockInventory>>,
    { data: UnlockStockInventoryBody }
  > = (props) => {
    const { data } = props ?? {}

    return unlockStockInventory(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UnlockStockInventoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof unlockStockInventory>>
>
export type UnlockStockInventoryMutationBody = UnlockStockInventoryBody
export type UnlockStockInventoryMutationError = DtoErrorResponse

/**
 * @summary Unlock stock
 */
export const useUnlockStockInventory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof unlockStockInventory>>,
      TError,
      { data: UnlockStockInventoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof unlockStockInventory>>,
  TError,
  { data: UnlockStockInventoryBody },
  TContext
> => {
  return useMutation(getUnlockStockInventoryMutationOptions(options), queryClient)
}
/**
 * Set min/max quantity thresholds for inventory alerts
 * @summary Set inventory thresholds
 */
export type setThresholdsInventoryResponse200 = {
  data: HandlerAPIResponseHandlerInventoryItemResponse
  status: 200
}

export type setThresholdsInventoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type setThresholdsInventoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type setThresholdsInventoryResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type setThresholdsInventoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type setThresholdsInventoryResponseSuccess = setThresholdsInventoryResponse200 & {
  headers: Headers
}
export type setThresholdsInventoryResponseError = (
  | setThresholdsInventoryResponse400
  | setThresholdsInventoryResponse401
  | setThresholdsInventoryResponse422
  | setThresholdsInventoryResponse500
) & {
  headers: Headers
}

export type setThresholdsInventoryResponse =
  | setThresholdsInventoryResponseSuccess
  | setThresholdsInventoryResponseError

export const getSetThresholdsInventoryUrl = () => {
  return `/inventory/thresholds`
}

export const setThresholdsInventory = async (
  setThresholdsInventoryBody: SetThresholdsInventoryBody,
  options?: RequestInit
): Promise<setThresholdsInventoryResponse> => {
  return customInstance<setThresholdsInventoryResponse>(getSetThresholdsInventoryUrl(), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(setThresholdsInventoryBody),
  })
}

export const getSetThresholdsInventoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setThresholdsInventory>>,
    TError,
    { data: SetThresholdsInventoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof setThresholdsInventory>>,
  TError,
  { data: SetThresholdsInventoryBody },
  TContext
> => {
  const mutationKey = ['setThresholdsInventory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setThresholdsInventory>>,
    { data: SetThresholdsInventoryBody }
  > = (props) => {
    const { data } = props ?? {}

    return setThresholdsInventory(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SetThresholdsInventoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof setThresholdsInventory>>
>
export type SetThresholdsInventoryMutationBody = SetThresholdsInventoryBody
export type SetThresholdsInventoryMutationError = DtoErrorResponse

/**
 * @summary Set inventory thresholds
 */
export const useSetThresholdsInventory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof setThresholdsInventory>>,
      TError,
      { data: SetThresholdsInventoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof setThresholdsInventory>>,
  TError,
  { data: SetThresholdsInventoryBody },
  TContext
> => {
  return useMutation(getSetThresholdsInventoryMutationOptions(options), queryClient)
}
/**
 * Retrieve a paginated list of inventory transactions with optional filtering
 * @summary List inventory transactions
 */
export type listInventoryTransactionsResponse200 = {
  data: HandlerAPIResponseArrayHandlerTransactionResponse
  status: 200
}

export type listInventoryTransactionsResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listInventoryTransactionsResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listInventoryTransactionsResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listInventoryTransactionsResponseSuccess = listInventoryTransactionsResponse200 & {
  headers: Headers
}
export type listInventoryTransactionsResponseError = (
  | listInventoryTransactionsResponse400
  | listInventoryTransactionsResponse401
  | listInventoryTransactionsResponse500
) & {
  headers: Headers
}

export type listInventoryTransactionsResponse =
  | listInventoryTransactionsResponseSuccess
  | listInventoryTransactionsResponseError

export const getListInventoryTransactionsUrl = (params?: ListInventoryTransactionsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/inventory/transactions?${stringifiedParams}`
    : `/inventory/transactions`
}

export const listInventoryTransactions = async (
  params?: ListInventoryTransactionsParams,
  options?: RequestInit
): Promise<listInventoryTransactionsResponse> => {
  return customInstance<listInventoryTransactionsResponse>(
    getListInventoryTransactionsUrl(params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getListInventoryTransactionsQueryKey = (params?: ListInventoryTransactionsParams) => {
  return [`/inventory/transactions`, ...(params ? [params] : [])] as const
}

export const getListInventoryTransactionsQueryOptions = <
  TData = Awaited<ReturnType<typeof listInventoryTransactions>>,
  TError = DtoErrorResponse,
>(
  params?: ListInventoryTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryTransactions>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListInventoryTransactionsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listInventoryTransactions>>> = ({
    signal,
  }) => listInventoryTransactions(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listInventoryTransactions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListInventoryTransactionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listInventoryTransactions>>
>
export type ListInventoryTransactionsQueryError = DtoErrorResponse

export function useListInventoryTransactions<
  TData = Awaited<ReturnType<typeof listInventoryTransactions>>,
  TError = DtoErrorResponse,
>(
  params: undefined | ListInventoryTransactionsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryTransactions>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventoryTransactions>>,
          TError,
          Awaited<ReturnType<typeof listInventoryTransactions>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInventoryTransactions<
  TData = Awaited<ReturnType<typeof listInventoryTransactions>>,
  TError = DtoErrorResponse,
>(
  params?: ListInventoryTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryTransactions>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventoryTransactions>>,
          TError,
          Awaited<ReturnType<typeof listInventoryTransactions>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInventoryTransactions<
  TData = Awaited<ReturnType<typeof listInventoryTransactions>>,
  TError = DtoErrorResponse,
>(
  params?: ListInventoryTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryTransactions>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List inventory transactions
 */

export function useListInventoryTransactions<
  TData = Awaited<ReturnType<typeof listInventoryTransactions>>,
  TError = DtoErrorResponse,
>(
  params?: ListInventoryTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryTransactions>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListInventoryTransactionsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Retrieve a specific inventory transaction by ID
 * @summary Get transaction by ID
 */
export type getInventoryTransactionByIDResponse200 = {
  data: HandlerAPIResponseHandlerTransactionResponse
  status: 200
}

export type getInventoryTransactionByIDResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getInventoryTransactionByIDResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getInventoryTransactionByIDResponse403 = {
  data: DtoErrorResponse
  status: 403
}

export type getInventoryTransactionByIDResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getInventoryTransactionByIDResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getInventoryTransactionByIDResponseSuccess = getInventoryTransactionByIDResponse200 & {
  headers: Headers
}
export type getInventoryTransactionByIDResponseError = (
  | getInventoryTransactionByIDResponse400
  | getInventoryTransactionByIDResponse401
  | getInventoryTransactionByIDResponse403
  | getInventoryTransactionByIDResponse404
  | getInventoryTransactionByIDResponse500
) & {
  headers: Headers
}

export type getInventoryTransactionByIDResponse =
  | getInventoryTransactionByIDResponseSuccess
  | getInventoryTransactionByIDResponseError

export const getGetInventoryTransactionByIDUrl = (id: string) => {
  return `/inventory/transactions/${id}`
}

export const getInventoryTransactionByID = async (
  id: string,
  options?: RequestInit
): Promise<getInventoryTransactionByIDResponse> => {
  return customInstance<getInventoryTransactionByIDResponse>(
    getGetInventoryTransactionByIDUrl(id),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getGetInventoryTransactionByIDQueryKey = (id: string) => {
  return [`/inventory/transactions/${id}`] as const
}

export const getGetInventoryTransactionByIDQueryOptions = <
  TData = Awaited<ReturnType<typeof getInventoryTransactionByID>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryTransactionByID>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInventoryTransactionByIDQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInventoryTransactionByID>>> = ({
    signal,
  }) => getInventoryTransactionByID(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventoryTransactionByID>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInventoryTransactionByIDQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInventoryTransactionByID>>
>
export type GetInventoryTransactionByIDQueryError = DtoErrorResponse

export function useGetInventoryTransactionByID<
  TData = Awaited<ReturnType<typeof getInventoryTransactionByID>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryTransactionByID>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryTransactionByID>>,
          TError,
          Awaited<ReturnType<typeof getInventoryTransactionByID>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInventoryTransactionByID<
  TData = Awaited<ReturnType<typeof getInventoryTransactionByID>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryTransactionByID>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryTransactionByID>>,
          TError,
          Awaited<ReturnType<typeof getInventoryTransactionByID>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInventoryTransactionByID<
  TData = Awaited<ReturnType<typeof getInventoryTransactionByID>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryTransactionByID>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get transaction by ID
 */

export function useGetInventoryTransactionByID<
  TData = Awaited<ReturnType<typeof getInventoryTransactionByID>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getInventoryTransactionByID>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInventoryTransactionByIDQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Retrieve inventory items for a specific warehouse
 * @summary List inventory by warehouse
 */
export type listInventoryByWarehouseResponse200 = {
  data: HandlerAPIResponseArrayHandlerInventoryItemResponse
  status: 200
}

export type listInventoryByWarehouseResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listInventoryByWarehouseResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listInventoryByWarehouseResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listInventoryByWarehouseResponseSuccess = listInventoryByWarehouseResponse200 & {
  headers: Headers
}
export type listInventoryByWarehouseResponseError = (
  | listInventoryByWarehouseResponse400
  | listInventoryByWarehouseResponse401
  | listInventoryByWarehouseResponse500
) & {
  headers: Headers
}

export type listInventoryByWarehouseResponse =
  | listInventoryByWarehouseResponseSuccess
  | listInventoryByWarehouseResponseError

export const getListInventoryByWarehouseUrl = (
  warehouseId: string,
  params?: ListInventoryByWarehouseParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/inventory/warehouses/${warehouseId}/items?${stringifiedParams}`
    : `/inventory/warehouses/${warehouseId}/items`
}

export const listInventoryByWarehouse = async (
  warehouseId: string,
  params?: ListInventoryByWarehouseParams,
  options?: RequestInit
): Promise<listInventoryByWarehouseResponse> => {
  return customInstance<listInventoryByWarehouseResponse>(
    getListInventoryByWarehouseUrl(warehouseId, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getListInventoryByWarehouseQueryKey = (
  warehouseId: string,
  params?: ListInventoryByWarehouseParams
) => {
  return [`/inventory/warehouses/${warehouseId}/items`, ...(params ? [params] : [])] as const
}

export const getListInventoryByWarehouseQueryOptions = <
  TData = Awaited<ReturnType<typeof listInventoryByWarehouse>>,
  TError = DtoErrorResponse,
>(
  warehouseId: string,
  params?: ListInventoryByWarehouseParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryByWarehouse>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getListInventoryByWarehouseQueryKey(warehouseId, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listInventoryByWarehouse>>> = ({
    signal,
  }) => listInventoryByWarehouse(warehouseId, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!warehouseId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listInventoryByWarehouse>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListInventoryByWarehouseQueryResult = NonNullable<
  Awaited<ReturnType<typeof listInventoryByWarehouse>>
>
export type ListInventoryByWarehouseQueryError = DtoErrorResponse

export function useListInventoryByWarehouse<
  TData = Awaited<ReturnType<typeof listInventoryByWarehouse>>,
  TError = DtoErrorResponse,
>(
  warehouseId: string,
  params: undefined | ListInventoryByWarehouseParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryByWarehouse>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventoryByWarehouse>>,
          TError,
          Awaited<ReturnType<typeof listInventoryByWarehouse>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInventoryByWarehouse<
  TData = Awaited<ReturnType<typeof listInventoryByWarehouse>>,
  TError = DtoErrorResponse,
>(
  warehouseId: string,
  params?: ListInventoryByWarehouseParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryByWarehouse>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventoryByWarehouse>>,
          TError,
          Awaited<ReturnType<typeof listInventoryByWarehouse>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInventoryByWarehouse<
  TData = Awaited<ReturnType<typeof listInventoryByWarehouse>>,
  TError = DtoErrorResponse,
>(
  warehouseId: string,
  params?: ListInventoryByWarehouseParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryByWarehouse>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List inventory by warehouse
 */

export function useListInventoryByWarehouse<
  TData = Awaited<ReturnType<typeof listInventoryByWarehouse>>,
  TError = DtoErrorResponse,
>(
  warehouseId: string,
  params?: ListInventoryByWarehouseParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventoryByWarehouse>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListInventoryByWarehouseQueryOptions(warehouseId, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

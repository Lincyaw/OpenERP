/**
 * // This file is auto-generated by orval
 * // Do not edit manually
 *
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  BatchEvaluateFeatureFlagBody,
  CreateFeatureFlagFlagBody,
  CreateFeatureFlagOverrideBody,
  DisableFlagFeatureFlagBody,
  EnableFlagFeatureFlagBody,
  EvaluateFlagFeatureFlagBody,
  GetFeatureFlagAuditLogsParams,
  GetFeatureFlagClientConfigBody,
  HandlerAPIResponseDtoAuditLogListResponse,
  HandlerAPIResponseDtoBatchEvaluateResponse,
  HandlerAPIResponseDtoEvaluateFlagResponse,
  HandlerAPIResponseDtoFlagListResponse,
  HandlerAPIResponseDtoFlagResponse,
  HandlerAPIResponseDtoGetClientConfigResponse,
  HandlerAPIResponseDtoMessageResponse,
  HandlerAPIResponseDtoOverrideListResponse,
  HandlerAPIResponseDtoOverrideResponse,
  HandlerErrorResponse,
  ListFeatureFlagFlagsParams,
  ListFeatureFlagOverridesParams,
  UpdateFeatureFlagFlagBody,
} from '.././models'

import { customInstance } from '../../services/axios-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Retrieve a paginated list of feature flags with optional filtering
 * @summary List feature flags
 */
export type listFeatureFlagFlagsResponse200 = {
  data: HandlerAPIResponseDtoFlagListResponse
  status: 200
}

export type listFeatureFlagFlagsResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type listFeatureFlagFlagsResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type listFeatureFlagFlagsResponse403 = {
  data: HandlerErrorResponse
  status: 403
}

export type listFeatureFlagFlagsResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type listFeatureFlagFlagsResponseSuccess = listFeatureFlagFlagsResponse200 & {
  headers: Headers
}
export type listFeatureFlagFlagsResponseError = (
  | listFeatureFlagFlagsResponse400
  | listFeatureFlagFlagsResponse401
  | listFeatureFlagFlagsResponse403
  | listFeatureFlagFlagsResponse500
) & {
  headers: Headers
}

export type listFeatureFlagFlagsResponse =
  | listFeatureFlagFlagsResponseSuccess
  | listFeatureFlagFlagsResponseError

export const getListFeatureFlagFlagsUrl = (params?: ListFeatureFlagFlagsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/feature-flags?${stringifiedParams}` : `/feature-flags`
}

export const listFeatureFlagFlags = async (
  params?: ListFeatureFlagFlagsParams,
  options?: RequestInit
): Promise<listFeatureFlagFlagsResponse> => {
  return customInstance<listFeatureFlagFlagsResponse>(getListFeatureFlagFlagsUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getListFeatureFlagFlagsQueryKey = (params?: ListFeatureFlagFlagsParams) => {
  return [`/feature-flags`, ...(params ? [params] : [])] as const
}

export const getListFeatureFlagFlagsQueryOptions = <
  TData = Awaited<ReturnType<typeof listFeatureFlagFlags>>,
  TError = HandlerErrorResponse,
>(
  params?: ListFeatureFlagFlagsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listFeatureFlagFlags>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListFeatureFlagFlagsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listFeatureFlagFlags>>> = ({ signal }) =>
    listFeatureFlagFlags(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listFeatureFlagFlags>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListFeatureFlagFlagsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listFeatureFlagFlags>>
>
export type ListFeatureFlagFlagsQueryError = HandlerErrorResponse

export function useListFeatureFlagFlags<
  TData = Awaited<ReturnType<typeof listFeatureFlagFlags>>,
  TError = HandlerErrorResponse,
>(
  params: undefined | ListFeatureFlagFlagsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listFeatureFlagFlags>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listFeatureFlagFlags>>,
          TError,
          Awaited<ReturnType<typeof listFeatureFlagFlags>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListFeatureFlagFlags<
  TData = Awaited<ReturnType<typeof listFeatureFlagFlags>>,
  TError = HandlerErrorResponse,
>(
  params?: ListFeatureFlagFlagsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listFeatureFlagFlags>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listFeatureFlagFlags>>,
          TError,
          Awaited<ReturnType<typeof listFeatureFlagFlags>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListFeatureFlagFlags<
  TData = Awaited<ReturnType<typeof listFeatureFlagFlags>>,
  TError = HandlerErrorResponse,
>(
  params?: ListFeatureFlagFlagsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listFeatureFlagFlags>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List feature flags
 */

export function useListFeatureFlagFlags<
  TData = Awaited<ReturnType<typeof listFeatureFlagFlags>>,
  TError = HandlerErrorResponse,
>(
  params?: ListFeatureFlagFlagsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listFeatureFlagFlags>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListFeatureFlagFlagsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Create a new feature flag with the specified configuration
 * @summary Create a new feature flag
 */
export type createFeatureFlagFlagResponse201 = {
  data: HandlerAPIResponseDtoFlagResponse
  status: 201
}

export type createFeatureFlagFlagResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type createFeatureFlagFlagResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type createFeatureFlagFlagResponse403 = {
  data: HandlerErrorResponse
  status: 403
}

export type createFeatureFlagFlagResponse409 = {
  data: HandlerErrorResponse
  status: 409
}

export type createFeatureFlagFlagResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type createFeatureFlagFlagResponseSuccess = createFeatureFlagFlagResponse201 & {
  headers: Headers
}
export type createFeatureFlagFlagResponseError = (
  | createFeatureFlagFlagResponse400
  | createFeatureFlagFlagResponse401
  | createFeatureFlagFlagResponse403
  | createFeatureFlagFlagResponse409
  | createFeatureFlagFlagResponse500
) & {
  headers: Headers
}

export type createFeatureFlagFlagResponse =
  | createFeatureFlagFlagResponseSuccess
  | createFeatureFlagFlagResponseError

export const getCreateFeatureFlagFlagUrl = () => {
  return `/feature-flags`
}

export const createFeatureFlagFlag = async (
  createFeatureFlagFlagBody: CreateFeatureFlagFlagBody,
  options?: RequestInit
): Promise<createFeatureFlagFlagResponse> => {
  return customInstance<createFeatureFlagFlagResponse>(getCreateFeatureFlagFlagUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createFeatureFlagFlagBody),
  })
}

export const getCreateFeatureFlagFlagMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFeatureFlagFlag>>,
    TError,
    { data: CreateFeatureFlagFlagBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createFeatureFlagFlag>>,
  TError,
  { data: CreateFeatureFlagFlagBody },
  TContext
> => {
  const mutationKey = ['createFeatureFlagFlag']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createFeatureFlagFlag>>,
    { data: CreateFeatureFlagFlagBody }
  > = (props) => {
    const { data } = props ?? {}

    return createFeatureFlagFlag(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateFeatureFlagFlagMutationResult = NonNullable<
  Awaited<ReturnType<typeof createFeatureFlagFlag>>
>
export type CreateFeatureFlagFlagMutationBody = CreateFeatureFlagFlagBody
export type CreateFeatureFlagFlagMutationError = HandlerErrorResponse

/**
 * @summary Create a new feature flag
 */
export const useCreateFeatureFlagFlag = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createFeatureFlagFlag>>,
      TError,
      { data: CreateFeatureFlagFlagBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createFeatureFlagFlag>>,
  TError,
  { data: CreateFeatureFlagFlagBody },
  TContext
> => {
  return useMutation(getCreateFeatureFlagFlagMutationOptions(options), queryClient)
}
/**
 * Archive a feature flag (soft delete). Archived flags cannot be evaluated.
 * @summary Archive a feature flag
 */
export type archiveFlagFeatureFlagResponse204 = {
  data: void
  status: 204
}

export type archiveFlagFeatureFlagResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type archiveFlagFeatureFlagResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type archiveFlagFeatureFlagResponse403 = {
  data: HandlerErrorResponse
  status: 403
}

export type archiveFlagFeatureFlagResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type archiveFlagFeatureFlagResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type archiveFlagFeatureFlagResponseSuccess = archiveFlagFeatureFlagResponse204 & {
  headers: Headers
}
export type archiveFlagFeatureFlagResponseError = (
  | archiveFlagFeatureFlagResponse400
  | archiveFlagFeatureFlagResponse401
  | archiveFlagFeatureFlagResponse403
  | archiveFlagFeatureFlagResponse404
  | archiveFlagFeatureFlagResponse500
) & {
  headers: Headers
}

export type archiveFlagFeatureFlagResponse =
  | archiveFlagFeatureFlagResponseSuccess
  | archiveFlagFeatureFlagResponseError

export const getArchiveFlagFeatureFlagUrl = (key: string) => {
  return `/feature-flags/${key}`
}

export const archiveFlagFeatureFlag = async (
  key: string,
  options?: RequestInit
): Promise<archiveFlagFeatureFlagResponse> => {
  return customInstance<archiveFlagFeatureFlagResponse>(getArchiveFlagFeatureFlagUrl(key), {
    ...options,
    method: 'DELETE',
  })
}

export const getArchiveFlagFeatureFlagMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof archiveFlagFeatureFlag>>,
    TError,
    { key: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof archiveFlagFeatureFlag>>,
  TError,
  { key: string },
  TContext
> => {
  const mutationKey = ['archiveFlagFeatureFlag']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof archiveFlagFeatureFlag>>,
    { key: string }
  > = (props) => {
    const { key } = props ?? {}

    return archiveFlagFeatureFlag(key, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ArchiveFlagFeatureFlagMutationResult = NonNullable<
  Awaited<ReturnType<typeof archiveFlagFeatureFlag>>
>

export type ArchiveFlagFeatureFlagMutationError = HandlerErrorResponse

/**
 * @summary Archive a feature flag
 */
export const useArchiveFlagFeatureFlag = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof archiveFlagFeatureFlag>>,
      TError,
      { key: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof archiveFlagFeatureFlag>>,
  TError,
  { key: string },
  TContext
> => {
  return useMutation(getArchiveFlagFeatureFlagMutationOptions(options), queryClient)
}
/**
 * Retrieve a feature flag by its unique key
 * @summary Get feature flag by key
 */
export type getFeatureFlagFlagResponse200 = {
  data: HandlerAPIResponseDtoFlagResponse
  status: 200
}

export type getFeatureFlagFlagResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type getFeatureFlagFlagResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type getFeatureFlagFlagResponse403 = {
  data: HandlerErrorResponse
  status: 403
}

export type getFeatureFlagFlagResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type getFeatureFlagFlagResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type getFeatureFlagFlagResponseSuccess = getFeatureFlagFlagResponse200 & {
  headers: Headers
}
export type getFeatureFlagFlagResponseError = (
  | getFeatureFlagFlagResponse400
  | getFeatureFlagFlagResponse401
  | getFeatureFlagFlagResponse403
  | getFeatureFlagFlagResponse404
  | getFeatureFlagFlagResponse500
) & {
  headers: Headers
}

export type getFeatureFlagFlagResponse =
  | getFeatureFlagFlagResponseSuccess
  | getFeatureFlagFlagResponseError

export const getGetFeatureFlagFlagUrl = (key: string) => {
  return `/feature-flags/${key}`
}

export const getFeatureFlagFlag = async (
  key: string,
  options?: RequestInit
): Promise<getFeatureFlagFlagResponse> => {
  return customInstance<getFeatureFlagFlagResponse>(getGetFeatureFlagFlagUrl(key), {
    ...options,
    method: 'GET',
  })
}

export const getGetFeatureFlagFlagQueryKey = (key: string) => {
  return [`/feature-flags/${key}`] as const
}

export const getGetFeatureFlagFlagQueryOptions = <
  TData = Awaited<ReturnType<typeof getFeatureFlagFlag>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeatureFlagFlag>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFeatureFlagFlagQueryKey(key)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeatureFlagFlag>>> = ({ signal }) =>
    getFeatureFlagFlag(key, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!key, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFeatureFlagFlag>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFeatureFlagFlagQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFeatureFlagFlag>>
>
export type GetFeatureFlagFlagQueryError = HandlerErrorResponse

export function useGetFeatureFlagFlag<
  TData = Awaited<ReturnType<typeof getFeatureFlagFlag>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeatureFlagFlag>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeatureFlagFlag>>,
          TError,
          Awaited<ReturnType<typeof getFeatureFlagFlag>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeatureFlagFlag<
  TData = Awaited<ReturnType<typeof getFeatureFlagFlag>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFeatureFlagFlag>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeatureFlagFlag>>,
          TError,
          Awaited<ReturnType<typeof getFeatureFlagFlag>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeatureFlagFlag<
  TData = Awaited<ReturnType<typeof getFeatureFlagFlag>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeatureFlagFlag>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get feature flag by key
 */

export function useGetFeatureFlagFlag<
  TData = Awaited<ReturnType<typeof getFeatureFlagFlag>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeatureFlagFlag>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFeatureFlagFlagQueryOptions(key, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Update an existing feature flag's configuration
 * @summary Update a feature flag
 */
export type updateFeatureFlagFlagResponse200 = {
  data: HandlerAPIResponseDtoFlagResponse
  status: 200
}

export type updateFeatureFlagFlagResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type updateFeatureFlagFlagResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type updateFeatureFlagFlagResponse403 = {
  data: HandlerErrorResponse
  status: 403
}

export type updateFeatureFlagFlagResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type updateFeatureFlagFlagResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type updateFeatureFlagFlagResponseSuccess = updateFeatureFlagFlagResponse200 & {
  headers: Headers
}
export type updateFeatureFlagFlagResponseError = (
  | updateFeatureFlagFlagResponse400
  | updateFeatureFlagFlagResponse401
  | updateFeatureFlagFlagResponse403
  | updateFeatureFlagFlagResponse404
  | updateFeatureFlagFlagResponse500
) & {
  headers: Headers
}

export type updateFeatureFlagFlagResponse =
  | updateFeatureFlagFlagResponseSuccess
  | updateFeatureFlagFlagResponseError

export const getUpdateFeatureFlagFlagUrl = (key: string) => {
  return `/feature-flags/${key}`
}

export const updateFeatureFlagFlag = async (
  key: string,
  updateFeatureFlagFlagBody: UpdateFeatureFlagFlagBody,
  options?: RequestInit
): Promise<updateFeatureFlagFlagResponse> => {
  return customInstance<updateFeatureFlagFlagResponse>(getUpdateFeatureFlagFlagUrl(key), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateFeatureFlagFlagBody),
  })
}

export const getUpdateFeatureFlagFlagMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateFeatureFlagFlag>>,
    TError,
    { key: string; data: UpdateFeatureFlagFlagBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateFeatureFlagFlag>>,
  TError,
  { key: string; data: UpdateFeatureFlagFlagBody },
  TContext
> => {
  const mutationKey = ['updateFeatureFlagFlag']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateFeatureFlagFlag>>,
    { key: string; data: UpdateFeatureFlagFlagBody }
  > = (props) => {
    const { key, data } = props ?? {}

    return updateFeatureFlagFlag(key, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateFeatureFlagFlagMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateFeatureFlagFlag>>
>
export type UpdateFeatureFlagFlagMutationBody = UpdateFeatureFlagFlagBody
export type UpdateFeatureFlagFlagMutationError = HandlerErrorResponse

/**
 * @summary Update a feature flag
 */
export const useUpdateFeatureFlagFlag = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateFeatureFlagFlag>>,
      TError,
      { key: string; data: UpdateFeatureFlagFlagBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateFeatureFlagFlag>>,
  TError,
  { key: string; data: UpdateFeatureFlagFlagBody },
  TContext
> => {
  return useMutation(getUpdateFeatureFlagFlagMutationOptions(options), queryClient)
}
/**
 * Retrieve audit logs for a specific feature flag
 * @summary Get flag audit logs
 */
export type getFeatureFlagAuditLogsResponse200 = {
  data: HandlerAPIResponseDtoAuditLogListResponse
  status: 200
}

export type getFeatureFlagAuditLogsResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type getFeatureFlagAuditLogsResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type getFeatureFlagAuditLogsResponse403 = {
  data: HandlerErrorResponse
  status: 403
}

export type getFeatureFlagAuditLogsResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type getFeatureFlagAuditLogsResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type getFeatureFlagAuditLogsResponseSuccess = getFeatureFlagAuditLogsResponse200 & {
  headers: Headers
}
export type getFeatureFlagAuditLogsResponseError = (
  | getFeatureFlagAuditLogsResponse400
  | getFeatureFlagAuditLogsResponse401
  | getFeatureFlagAuditLogsResponse403
  | getFeatureFlagAuditLogsResponse404
  | getFeatureFlagAuditLogsResponse500
) & {
  headers: Headers
}

export type getFeatureFlagAuditLogsResponse =
  | getFeatureFlagAuditLogsResponseSuccess
  | getFeatureFlagAuditLogsResponseError

export const getGetFeatureFlagAuditLogsUrl = (
  key: string,
  params?: GetFeatureFlagAuditLogsParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/feature-flags/${key}/audit-logs?${stringifiedParams}`
    : `/feature-flags/${key}/audit-logs`
}

export const getFeatureFlagAuditLogs = async (
  key: string,
  params?: GetFeatureFlagAuditLogsParams,
  options?: RequestInit
): Promise<getFeatureFlagAuditLogsResponse> => {
  return customInstance<getFeatureFlagAuditLogsResponse>(
    getGetFeatureFlagAuditLogsUrl(key, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getGetFeatureFlagAuditLogsQueryKey = (
  key: string,
  params?: GetFeatureFlagAuditLogsParams
) => {
  return [`/feature-flags/${key}/audit-logs`, ...(params ? [params] : [])] as const
}

export const getGetFeatureFlagAuditLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  params?: GetFeatureFlagAuditLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFeatureFlagAuditLogsQueryKey(key, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>> = ({
    signal,
  }) => getFeatureFlagAuditLogs(key, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!key, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFeatureFlagAuditLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>
>
export type GetFeatureFlagAuditLogsQueryError = HandlerErrorResponse

export function useGetFeatureFlagAuditLogs<
  TData = Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  params: undefined | GetFeatureFlagAuditLogsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>,
          TError,
          Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeatureFlagAuditLogs<
  TData = Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  params?: GetFeatureFlagAuditLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>,
          TError,
          Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeatureFlagAuditLogs<
  TData = Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  params?: GetFeatureFlagAuditLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get flag audit logs
 */

export function useGetFeatureFlagAuditLogs<
  TData = Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  params?: GetFeatureFlagAuditLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFeatureFlagAuditLogs>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFeatureFlagAuditLogsQueryOptions(key, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Disable an enabled feature flag
 * @summary Disable a feature flag
 */
export type disableFlagFeatureFlagResponse200 = {
  data: HandlerAPIResponseDtoMessageResponse
  status: 200
}

export type disableFlagFeatureFlagResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type disableFlagFeatureFlagResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type disableFlagFeatureFlagResponse403 = {
  data: HandlerErrorResponse
  status: 403
}

export type disableFlagFeatureFlagResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type disableFlagFeatureFlagResponse422 = {
  data: HandlerErrorResponse
  status: 422
}

export type disableFlagFeatureFlagResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type disableFlagFeatureFlagResponseSuccess = disableFlagFeatureFlagResponse200 & {
  headers: Headers
}
export type disableFlagFeatureFlagResponseError = (
  | disableFlagFeatureFlagResponse400
  | disableFlagFeatureFlagResponse401
  | disableFlagFeatureFlagResponse403
  | disableFlagFeatureFlagResponse404
  | disableFlagFeatureFlagResponse422
  | disableFlagFeatureFlagResponse500
) & {
  headers: Headers
}

export type disableFlagFeatureFlagResponse =
  | disableFlagFeatureFlagResponseSuccess
  | disableFlagFeatureFlagResponseError

export const getDisableFlagFeatureFlagUrl = (key: string) => {
  return `/feature-flags/${key}/disable`
}

export const disableFlagFeatureFlag = async (
  key: string,
  disableFlagFeatureFlagBody: DisableFlagFeatureFlagBody,
  options?: RequestInit
): Promise<disableFlagFeatureFlagResponse> => {
  return customInstance<disableFlagFeatureFlagResponse>(getDisableFlagFeatureFlagUrl(key), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(disableFlagFeatureFlagBody),
  })
}

export const getDisableFlagFeatureFlagMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof disableFlagFeatureFlag>>,
    TError,
    { key: string; data: DisableFlagFeatureFlagBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof disableFlagFeatureFlag>>,
  TError,
  { key: string; data: DisableFlagFeatureFlagBody },
  TContext
> => {
  const mutationKey = ['disableFlagFeatureFlag']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof disableFlagFeatureFlag>>,
    { key: string; data: DisableFlagFeatureFlagBody }
  > = (props) => {
    const { key, data } = props ?? {}

    return disableFlagFeatureFlag(key, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DisableFlagFeatureFlagMutationResult = NonNullable<
  Awaited<ReturnType<typeof disableFlagFeatureFlag>>
>
export type DisableFlagFeatureFlagMutationBody = DisableFlagFeatureFlagBody
export type DisableFlagFeatureFlagMutationError = HandlerErrorResponse

/**
 * @summary Disable a feature flag
 */
export const useDisableFlagFeatureFlag = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof disableFlagFeatureFlag>>,
      TError,
      { key: string; data: DisableFlagFeatureFlagBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof disableFlagFeatureFlag>>,
  TError,
  { key: string; data: DisableFlagFeatureFlagBody },
  TContext
> => {
  return useMutation(getDisableFlagFeatureFlagMutationOptions(options), queryClient)
}
/**
 * Enable a disabled feature flag
 * @summary Enable a feature flag
 */
export type enableFlagFeatureFlagResponse200 = {
  data: HandlerAPIResponseDtoMessageResponse
  status: 200
}

export type enableFlagFeatureFlagResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type enableFlagFeatureFlagResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type enableFlagFeatureFlagResponse403 = {
  data: HandlerErrorResponse
  status: 403
}

export type enableFlagFeatureFlagResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type enableFlagFeatureFlagResponse422 = {
  data: HandlerErrorResponse
  status: 422
}

export type enableFlagFeatureFlagResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type enableFlagFeatureFlagResponseSuccess = enableFlagFeatureFlagResponse200 & {
  headers: Headers
}
export type enableFlagFeatureFlagResponseError = (
  | enableFlagFeatureFlagResponse400
  | enableFlagFeatureFlagResponse401
  | enableFlagFeatureFlagResponse403
  | enableFlagFeatureFlagResponse404
  | enableFlagFeatureFlagResponse422
  | enableFlagFeatureFlagResponse500
) & {
  headers: Headers
}

export type enableFlagFeatureFlagResponse =
  | enableFlagFeatureFlagResponseSuccess
  | enableFlagFeatureFlagResponseError

export const getEnableFlagFeatureFlagUrl = (key: string) => {
  return `/feature-flags/${key}/enable`
}

export const enableFlagFeatureFlag = async (
  key: string,
  enableFlagFeatureFlagBody: EnableFlagFeatureFlagBody,
  options?: RequestInit
): Promise<enableFlagFeatureFlagResponse> => {
  return customInstance<enableFlagFeatureFlagResponse>(getEnableFlagFeatureFlagUrl(key), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(enableFlagFeatureFlagBody),
  })
}

export const getEnableFlagFeatureFlagMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof enableFlagFeatureFlag>>,
    TError,
    { key: string; data: EnableFlagFeatureFlagBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof enableFlagFeatureFlag>>,
  TError,
  { key: string; data: EnableFlagFeatureFlagBody },
  TContext
> => {
  const mutationKey = ['enableFlagFeatureFlag']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof enableFlagFeatureFlag>>,
    { key: string; data: EnableFlagFeatureFlagBody }
  > = (props) => {
    const { key, data } = props ?? {}

    return enableFlagFeatureFlag(key, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type EnableFlagFeatureFlagMutationResult = NonNullable<
  Awaited<ReturnType<typeof enableFlagFeatureFlag>>
>
export type EnableFlagFeatureFlagMutationBody = EnableFlagFeatureFlagBody
export type EnableFlagFeatureFlagMutationError = HandlerErrorResponse

/**
 * @summary Enable a feature flag
 */
export const useEnableFlagFeatureFlag = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof enableFlagFeatureFlag>>,
      TError,
      { key: string; data: EnableFlagFeatureFlagBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof enableFlagFeatureFlag>>,
  TError,
  { key: string; data: EnableFlagFeatureFlagBody },
  TContext
> => {
  return useMutation(getEnableFlagFeatureFlagMutationOptions(options), queryClient)
}
/**
 * Evaluate a single feature flag for the given context
 * @summary Evaluate a feature flag
 */
export type evaluateFlagFeatureFlagResponse200 = {
  data: HandlerAPIResponseDtoEvaluateFlagResponse
  status: 200
}

export type evaluateFlagFeatureFlagResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type evaluateFlagFeatureFlagResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type evaluateFlagFeatureFlagResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type evaluateFlagFeatureFlagResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type evaluateFlagFeatureFlagResponseSuccess = evaluateFlagFeatureFlagResponse200 & {
  headers: Headers
}
export type evaluateFlagFeatureFlagResponseError = (
  | evaluateFlagFeatureFlagResponse400
  | evaluateFlagFeatureFlagResponse401
  | evaluateFlagFeatureFlagResponse404
  | evaluateFlagFeatureFlagResponse500
) & {
  headers: Headers
}

export type evaluateFlagFeatureFlagResponse =
  | evaluateFlagFeatureFlagResponseSuccess
  | evaluateFlagFeatureFlagResponseError

export const getEvaluateFlagFeatureFlagUrl = (key: string) => {
  return `/feature-flags/${key}/evaluate`
}

export const evaluateFlagFeatureFlag = async (
  key: string,
  evaluateFlagFeatureFlagBody: EvaluateFlagFeatureFlagBody,
  options?: RequestInit
): Promise<evaluateFlagFeatureFlagResponse> => {
  return customInstance<evaluateFlagFeatureFlagResponse>(getEvaluateFlagFeatureFlagUrl(key), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(evaluateFlagFeatureFlagBody),
  })
}

export const getEvaluateFlagFeatureFlagMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof evaluateFlagFeatureFlag>>,
    TError,
    { key: string; data: EvaluateFlagFeatureFlagBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof evaluateFlagFeatureFlag>>,
  TError,
  { key: string; data: EvaluateFlagFeatureFlagBody },
  TContext
> => {
  const mutationKey = ['evaluateFlagFeatureFlag']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof evaluateFlagFeatureFlag>>,
    { key: string; data: EvaluateFlagFeatureFlagBody }
  > = (props) => {
    const { key, data } = props ?? {}

    return evaluateFlagFeatureFlag(key, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type EvaluateFlagFeatureFlagMutationResult = NonNullable<
  Awaited<ReturnType<typeof evaluateFlagFeatureFlag>>
>
export type EvaluateFlagFeatureFlagMutationBody = EvaluateFlagFeatureFlagBody
export type EvaluateFlagFeatureFlagMutationError = HandlerErrorResponse

/**
 * @summary Evaluate a feature flag
 */
export const useEvaluateFlagFeatureFlag = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof evaluateFlagFeatureFlag>>,
      TError,
      { key: string; data: EvaluateFlagFeatureFlagBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof evaluateFlagFeatureFlag>>,
  TError,
  { key: string; data: EvaluateFlagFeatureFlagBody },
  TContext
> => {
  return useMutation(getEvaluateFlagFeatureFlagMutationOptions(options), queryClient)
}
/**
 * Retrieve all overrides for a specific feature flag
 * @summary List flag overrides
 */
export type listFeatureFlagOverridesResponse200 = {
  data: HandlerAPIResponseDtoOverrideListResponse
  status: 200
}

export type listFeatureFlagOverridesResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type listFeatureFlagOverridesResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type listFeatureFlagOverridesResponse403 = {
  data: HandlerErrorResponse
  status: 403
}

export type listFeatureFlagOverridesResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type listFeatureFlagOverridesResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type listFeatureFlagOverridesResponseSuccess = listFeatureFlagOverridesResponse200 & {
  headers: Headers
}
export type listFeatureFlagOverridesResponseError = (
  | listFeatureFlagOverridesResponse400
  | listFeatureFlagOverridesResponse401
  | listFeatureFlagOverridesResponse403
  | listFeatureFlagOverridesResponse404
  | listFeatureFlagOverridesResponse500
) & {
  headers: Headers
}

export type listFeatureFlagOverridesResponse =
  | listFeatureFlagOverridesResponseSuccess
  | listFeatureFlagOverridesResponseError

export const getListFeatureFlagOverridesUrl = (
  key: string,
  params?: ListFeatureFlagOverridesParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/feature-flags/${key}/overrides?${stringifiedParams}`
    : `/feature-flags/${key}/overrides`
}

export const listFeatureFlagOverrides = async (
  key: string,
  params?: ListFeatureFlagOverridesParams,
  options?: RequestInit
): Promise<listFeatureFlagOverridesResponse> => {
  return customInstance<listFeatureFlagOverridesResponse>(
    getListFeatureFlagOverridesUrl(key, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getListFeatureFlagOverridesQueryKey = (
  key: string,
  params?: ListFeatureFlagOverridesParams
) => {
  return [`/feature-flags/${key}/overrides`, ...(params ? [params] : [])] as const
}

export const getListFeatureFlagOverridesQueryOptions = <
  TData = Awaited<ReturnType<typeof listFeatureFlagOverrides>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  params?: ListFeatureFlagOverridesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listFeatureFlagOverrides>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListFeatureFlagOverridesQueryKey(key, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listFeatureFlagOverrides>>> = ({
    signal,
  }) => listFeatureFlagOverrides(key, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!key, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listFeatureFlagOverrides>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListFeatureFlagOverridesQueryResult = NonNullable<
  Awaited<ReturnType<typeof listFeatureFlagOverrides>>
>
export type ListFeatureFlagOverridesQueryError = HandlerErrorResponse

export function useListFeatureFlagOverrides<
  TData = Awaited<ReturnType<typeof listFeatureFlagOverrides>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  params: undefined | ListFeatureFlagOverridesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listFeatureFlagOverrides>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listFeatureFlagOverrides>>,
          TError,
          Awaited<ReturnType<typeof listFeatureFlagOverrides>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListFeatureFlagOverrides<
  TData = Awaited<ReturnType<typeof listFeatureFlagOverrides>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  params?: ListFeatureFlagOverridesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listFeatureFlagOverrides>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listFeatureFlagOverrides>>,
          TError,
          Awaited<ReturnType<typeof listFeatureFlagOverrides>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListFeatureFlagOverrides<
  TData = Awaited<ReturnType<typeof listFeatureFlagOverrides>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  params?: ListFeatureFlagOverridesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listFeatureFlagOverrides>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List flag overrides
 */

export function useListFeatureFlagOverrides<
  TData = Awaited<ReturnType<typeof listFeatureFlagOverrides>>,
  TError = HandlerErrorResponse,
>(
  key: string,
  params?: ListFeatureFlagOverridesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listFeatureFlagOverrides>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListFeatureFlagOverridesQueryOptions(key, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Create a new override for a feature flag to target specific users or tenants
 * @summary Create a flag override
 */
export type createFeatureFlagOverrideResponse201 = {
  data: HandlerAPIResponseDtoOverrideResponse
  status: 201
}

export type createFeatureFlagOverrideResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type createFeatureFlagOverrideResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type createFeatureFlagOverrideResponse403 = {
  data: HandlerErrorResponse
  status: 403
}

export type createFeatureFlagOverrideResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type createFeatureFlagOverrideResponse409 = {
  data: HandlerErrorResponse
  status: 409
}

export type createFeatureFlagOverrideResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type createFeatureFlagOverrideResponseSuccess = createFeatureFlagOverrideResponse201 & {
  headers: Headers
}
export type createFeatureFlagOverrideResponseError = (
  | createFeatureFlagOverrideResponse400
  | createFeatureFlagOverrideResponse401
  | createFeatureFlagOverrideResponse403
  | createFeatureFlagOverrideResponse404
  | createFeatureFlagOverrideResponse409
  | createFeatureFlagOverrideResponse500
) & {
  headers: Headers
}

export type createFeatureFlagOverrideResponse =
  | createFeatureFlagOverrideResponseSuccess
  | createFeatureFlagOverrideResponseError

export const getCreateFeatureFlagOverrideUrl = (key: string) => {
  return `/feature-flags/${key}/overrides`
}

export const createFeatureFlagOverride = async (
  key: string,
  createFeatureFlagOverrideBody: CreateFeatureFlagOverrideBody,
  options?: RequestInit
): Promise<createFeatureFlagOverrideResponse> => {
  return customInstance<createFeatureFlagOverrideResponse>(getCreateFeatureFlagOverrideUrl(key), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createFeatureFlagOverrideBody),
  })
}

export const getCreateFeatureFlagOverrideMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFeatureFlagOverride>>,
    TError,
    { key: string; data: CreateFeatureFlagOverrideBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createFeatureFlagOverride>>,
  TError,
  { key: string; data: CreateFeatureFlagOverrideBody },
  TContext
> => {
  const mutationKey = ['createFeatureFlagOverride']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createFeatureFlagOverride>>,
    { key: string; data: CreateFeatureFlagOverrideBody }
  > = (props) => {
    const { key, data } = props ?? {}

    return createFeatureFlagOverride(key, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateFeatureFlagOverrideMutationResult = NonNullable<
  Awaited<ReturnType<typeof createFeatureFlagOverride>>
>
export type CreateFeatureFlagOverrideMutationBody = CreateFeatureFlagOverrideBody
export type CreateFeatureFlagOverrideMutationError = HandlerErrorResponse

/**
 * @summary Create a flag override
 */
export const useCreateFeatureFlagOverride = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createFeatureFlagOverride>>,
      TError,
      { key: string; data: CreateFeatureFlagOverrideBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createFeatureFlagOverride>>,
  TError,
  { key: string; data: CreateFeatureFlagOverrideBody },
  TContext
> => {
  return useMutation(getCreateFeatureFlagOverrideMutationOptions(options), queryClient)
}
/**
 * Delete a specific override by its ID
 * @summary Delete a flag override
 */
export type deleteFeatureFlagOverrideResponse204 = {
  data: void
  status: 204
}

export type deleteFeatureFlagOverrideResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type deleteFeatureFlagOverrideResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type deleteFeatureFlagOverrideResponse403 = {
  data: HandlerErrorResponse
  status: 403
}

export type deleteFeatureFlagOverrideResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type deleteFeatureFlagOverrideResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type deleteFeatureFlagOverrideResponseSuccess = deleteFeatureFlagOverrideResponse204 & {
  headers: Headers
}
export type deleteFeatureFlagOverrideResponseError = (
  | deleteFeatureFlagOverrideResponse400
  | deleteFeatureFlagOverrideResponse401
  | deleteFeatureFlagOverrideResponse403
  | deleteFeatureFlagOverrideResponse404
  | deleteFeatureFlagOverrideResponse500
) & {
  headers: Headers
}

export type deleteFeatureFlagOverrideResponse =
  | deleteFeatureFlagOverrideResponseSuccess
  | deleteFeatureFlagOverrideResponseError

export const getDeleteFeatureFlagOverrideUrl = (key: string, id: string) => {
  return `/feature-flags/${key}/overrides/${id}`
}

export const deleteFeatureFlagOverride = async (
  key: string,
  id: string,
  options?: RequestInit
): Promise<deleteFeatureFlagOverrideResponse> => {
  return customInstance<deleteFeatureFlagOverrideResponse>(
    getDeleteFeatureFlagOverrideUrl(key, id),
    {
      ...options,
      method: 'DELETE',
    }
  )
}

export const getDeleteFeatureFlagOverrideMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteFeatureFlagOverride>>,
    TError,
    { key: string; id: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteFeatureFlagOverride>>,
  TError,
  { key: string; id: string },
  TContext
> => {
  const mutationKey = ['deleteFeatureFlagOverride']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteFeatureFlagOverride>>,
    { key: string; id: string }
  > = (props) => {
    const { key, id } = props ?? {}

    return deleteFeatureFlagOverride(key, id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteFeatureFlagOverrideMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteFeatureFlagOverride>>
>

export type DeleteFeatureFlagOverrideMutationError = HandlerErrorResponse

/**
 * @summary Delete a flag override
 */
export const useDeleteFeatureFlagOverride = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteFeatureFlagOverride>>,
      TError,
      { key: string; id: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteFeatureFlagOverride>>,
  TError,
  { key: string; id: string },
  TContext
> => {
  return useMutation(getDeleteFeatureFlagOverrideMutationOptions(options), queryClient)
}
/**
 * Get all enabled feature flags and their values for client SDK initialization
 * @summary Get client configuration
 */
export type getFeatureFlagClientConfigResponse200 = {
  data: HandlerAPIResponseDtoGetClientConfigResponse
  status: 200
}

export type getFeatureFlagClientConfigResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type getFeatureFlagClientConfigResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type getFeatureFlagClientConfigResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type getFeatureFlagClientConfigResponseSuccess = getFeatureFlagClientConfigResponse200 & {
  headers: Headers
}
export type getFeatureFlagClientConfigResponseError = (
  | getFeatureFlagClientConfigResponse400
  | getFeatureFlagClientConfigResponse401
  | getFeatureFlagClientConfigResponse500
) & {
  headers: Headers
}

export type getFeatureFlagClientConfigResponse =
  | getFeatureFlagClientConfigResponseSuccess
  | getFeatureFlagClientConfigResponseError

export const getGetFeatureFlagClientConfigUrl = () => {
  return `/feature-flags/client-config`
}

export const getFeatureFlagClientConfig = async (
  getFeatureFlagClientConfigBody: GetFeatureFlagClientConfigBody,
  options?: RequestInit
): Promise<getFeatureFlagClientConfigResponse> => {
  return customInstance<getFeatureFlagClientConfigResponse>(getGetFeatureFlagClientConfigUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(getFeatureFlagClientConfigBody),
  })
}

export const getGetFeatureFlagClientConfigMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getFeatureFlagClientConfig>>,
    TError,
    { data: GetFeatureFlagClientConfigBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof getFeatureFlagClientConfig>>,
  TError,
  { data: GetFeatureFlagClientConfigBody },
  TContext
> => {
  const mutationKey = ['getFeatureFlagClientConfig']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getFeatureFlagClientConfig>>,
    { data: GetFeatureFlagClientConfigBody }
  > = (props) => {
    const { data } = props ?? {}

    return getFeatureFlagClientConfig(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type GetFeatureFlagClientConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof getFeatureFlagClientConfig>>
>
export type GetFeatureFlagClientConfigMutationBody = GetFeatureFlagClientConfigBody
export type GetFeatureFlagClientConfigMutationError = HandlerErrorResponse

/**
 * @summary Get client configuration
 */
export const useGetFeatureFlagClientConfig = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof getFeatureFlagClientConfig>>,
      TError,
      { data: GetFeatureFlagClientConfigBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof getFeatureFlagClientConfig>>,
  TError,
  { data: GetFeatureFlagClientConfigBody },
  TContext
> => {
  return useMutation(getGetFeatureFlagClientConfigMutationOptions(options), queryClient)
}
/**
 * Evaluate multiple feature flags at once for the given context
 * @summary Batch evaluate feature flags
 */
export type batchEvaluateFeatureFlagResponse200 = {
  data: HandlerAPIResponseDtoBatchEvaluateResponse
  status: 200
}

export type batchEvaluateFeatureFlagResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type batchEvaluateFeatureFlagResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type batchEvaluateFeatureFlagResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type batchEvaluateFeatureFlagResponseSuccess = batchEvaluateFeatureFlagResponse200 & {
  headers: Headers
}
export type batchEvaluateFeatureFlagResponseError = (
  | batchEvaluateFeatureFlagResponse400
  | batchEvaluateFeatureFlagResponse401
  | batchEvaluateFeatureFlagResponse500
) & {
  headers: Headers
}

export type batchEvaluateFeatureFlagResponse =
  | batchEvaluateFeatureFlagResponseSuccess
  | batchEvaluateFeatureFlagResponseError

export const getBatchEvaluateFeatureFlagUrl = () => {
  return `/feature-flags/evaluate-batch`
}

export const batchEvaluateFeatureFlag = async (
  batchEvaluateFeatureFlagBody: BatchEvaluateFeatureFlagBody,
  options?: RequestInit
): Promise<batchEvaluateFeatureFlagResponse> => {
  return customInstance<batchEvaluateFeatureFlagResponse>(getBatchEvaluateFeatureFlagUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(batchEvaluateFeatureFlagBody),
  })
}

export const getBatchEvaluateFeatureFlagMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof batchEvaluateFeatureFlag>>,
    TError,
    { data: BatchEvaluateFeatureFlagBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof batchEvaluateFeatureFlag>>,
  TError,
  { data: BatchEvaluateFeatureFlagBody },
  TContext
> => {
  const mutationKey = ['batchEvaluateFeatureFlag']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof batchEvaluateFeatureFlag>>,
    { data: BatchEvaluateFeatureFlagBody }
  > = (props) => {
    const { data } = props ?? {}

    return batchEvaluateFeatureFlag(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type BatchEvaluateFeatureFlagMutationResult = NonNullable<
  Awaited<ReturnType<typeof batchEvaluateFeatureFlag>>
>
export type BatchEvaluateFeatureFlagMutationBody = BatchEvaluateFeatureFlagBody
export type BatchEvaluateFeatureFlagMutationError = HandlerErrorResponse

/**
 * @summary Batch evaluate feature flags
 */
export const useBatchEvaluateFeatureFlag = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof batchEvaluateFeatureFlag>>,
      TError,
      { data: BatchEvaluateFeatureFlagBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof batchEvaluateFeatureFlag>>,
  TError,
  { data: BatchEvaluateFeatureFlagBody },
  TContext
> => {
  return useMutation(getBatchEvaluateFeatureFlagMutationOptions(options), queryClient)
}
/**
 * Establishes a Server-Sent Events connection for real-time feature flag updates
 * @summary Subscribe to feature flag updates via SSE
 */
export type streamFeatureFlagResponse200 = {
  data: string
  status: 200
}

export type streamFeatureFlagResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type streamFeatureFlagResponse503 = {
  data: HandlerErrorResponse
  status: 503
}

export type streamFeatureFlagResponseSuccess = streamFeatureFlagResponse200 & {
  headers: Headers
}
export type streamFeatureFlagResponseError = (
  | streamFeatureFlagResponse401
  | streamFeatureFlagResponse503
) & {
  headers: Headers
}

export type streamFeatureFlagResponse =
  | streamFeatureFlagResponseSuccess
  | streamFeatureFlagResponseError

export const getStreamFeatureFlagUrl = () => {
  return `/feature-flags/stream`
}

export const streamFeatureFlag = async (
  options?: RequestInit
): Promise<streamFeatureFlagResponse> => {
  return customInstance<streamFeatureFlagResponse>(getStreamFeatureFlagUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getStreamFeatureFlagQueryKey = () => {
  return [`/feature-flags/stream`] as const
}

export const getStreamFeatureFlagQueryOptions = <
  TData = Awaited<ReturnType<typeof streamFeatureFlag>>,
  TError = HandlerErrorResponse,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof streamFeatureFlag>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getStreamFeatureFlagQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof streamFeatureFlag>>> = ({ signal }) =>
    streamFeatureFlag({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof streamFeatureFlag>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamFeatureFlagQueryResult = NonNullable<
  Awaited<ReturnType<typeof streamFeatureFlag>>
>
export type StreamFeatureFlagQueryError = HandlerErrorResponse

export function useStreamFeatureFlag<
  TData = Awaited<ReturnType<typeof streamFeatureFlag>>,
  TError = HandlerErrorResponse,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof streamFeatureFlag>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamFeatureFlag>>,
          TError,
          Awaited<ReturnType<typeof streamFeatureFlag>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamFeatureFlag<
  TData = Awaited<ReturnType<typeof streamFeatureFlag>>,
  TError = HandlerErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof streamFeatureFlag>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamFeatureFlag>>,
          TError,
          Awaited<ReturnType<typeof streamFeatureFlag>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamFeatureFlag<
  TData = Awaited<ReturnType<typeof streamFeatureFlag>>,
  TError = HandlerErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof streamFeatureFlag>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Subscribe to feature flag updates via SSE
 */

export function useStreamFeatureFlag<
  TData = Awaited<ReturnType<typeof streamFeatureFlag>>,
  TError = HandlerErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof streamFeatureFlag>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getStreamFeatureFlagQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

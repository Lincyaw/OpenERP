/**
 * // This file is auto-generated by orval
 * // Do not edit manually
 *
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  ApproveExpenseExpensBody,
  CancelExpenseExpensBody,
  CreateExpensExpenseBody,
  GetExpensCashFlowParams,
  GetExpensExpensesSummaryParams,
  HandlerAPIResponseArrayHandlerExpenseRecordResponse,
  HandlerAPIResponseHandlerCashFlowSummaryResponse,
  HandlerAPIResponseHandlerExpenseRecordResponse,
  HandlerAPIResponseHandlerExpenseSummaryResponse,
  HandlerErrorResponse,
  HandlerSuccessResponse,
  ListExpensExpensesParams,
  MarkExpensePaidExpensBody,
  RejectExpenseExpensBody,
  SubmitExpenseExpensBody,
  UpdateExpensExpenseBody,
} from '.././models'

import { customInstance } from '../../services/axios-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Get combined expense and income cash flow summary
 * @summary Get cash flow summary
 */
export type getExpensCashFlowResponse200 = {
  data: HandlerAPIResponseHandlerCashFlowSummaryResponse
  status: 200
}

export type getExpensCashFlowResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type getExpensCashFlowResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type getExpensCashFlowResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type getExpensCashFlowResponseSuccess = getExpensCashFlowResponse200 & {
  headers: Headers
}
export type getExpensCashFlowResponseError = (
  | getExpensCashFlowResponse400
  | getExpensCashFlowResponse401
  | getExpensCashFlowResponse500
) & {
  headers: Headers
}

export type getExpensCashFlowResponse =
  | getExpensCashFlowResponseSuccess
  | getExpensCashFlowResponseError

export const getGetExpensCashFlowUrl = (params?: GetExpensCashFlowParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/finance/cash-flow?${stringifiedParams}`
    : `/finance/cash-flow`
}

export const getExpensCashFlow = async (
  params?: GetExpensCashFlowParams,
  options?: RequestInit
): Promise<getExpensCashFlowResponse> => {
  return customInstance<getExpensCashFlowResponse>(getGetExpensCashFlowUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getGetExpensCashFlowQueryKey = (params?: GetExpensCashFlowParams) => {
  return [`/finance/cash-flow`, ...(params ? [params] : [])] as const
}

export const getGetExpensCashFlowQueryOptions = <
  TData = Awaited<ReturnType<typeof getExpensCashFlow>>,
  TError = HandlerErrorResponse,
>(
  params?: GetExpensCashFlowParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensCashFlow>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetExpensCashFlowQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpensCashFlow>>> = ({ signal }) =>
    getExpensCashFlow(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExpensCashFlow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExpensCashFlowQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExpensCashFlow>>
>
export type GetExpensCashFlowQueryError = HandlerErrorResponse

export function useGetExpensCashFlow<
  TData = Awaited<ReturnType<typeof getExpensCashFlow>>,
  TError = HandlerErrorResponse,
>(
  params: undefined | GetExpensCashFlowParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensCashFlow>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpensCashFlow>>,
          TError,
          Awaited<ReturnType<typeof getExpensCashFlow>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExpensCashFlow<
  TData = Awaited<ReturnType<typeof getExpensCashFlow>>,
  TError = HandlerErrorResponse,
>(
  params?: GetExpensCashFlowParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensCashFlow>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpensCashFlow>>,
          TError,
          Awaited<ReturnType<typeof getExpensCashFlow>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExpensCashFlow<
  TData = Awaited<ReturnType<typeof getExpensCashFlow>>,
  TError = HandlerErrorResponse,
>(
  params?: GetExpensCashFlowParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensCashFlow>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get cash flow summary
 */

export function useGetExpensCashFlow<
  TData = Awaited<ReturnType<typeof getExpensCashFlow>>,
  TError = HandlerErrorResponse,
>(
  params?: GetExpensCashFlowParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensCashFlow>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetExpensCashFlowQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Get a paginated list of expense records
 * @summary List expense records
 */
export type listExpensExpensesResponse200 = {
  data: HandlerAPIResponseArrayHandlerExpenseRecordResponse
  status: 200
}

export type listExpensExpensesResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type listExpensExpensesResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type listExpensExpensesResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type listExpensExpensesResponseSuccess = listExpensExpensesResponse200 & {
  headers: Headers
}
export type listExpensExpensesResponseError = (
  | listExpensExpensesResponse400
  | listExpensExpensesResponse401
  | listExpensExpensesResponse500
) & {
  headers: Headers
}

export type listExpensExpensesResponse =
  | listExpensExpensesResponseSuccess
  | listExpensExpensesResponseError

export const getListExpensExpensesUrl = (params?: ListExpensExpensesParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/finance/expenses?${stringifiedParams}`
    : `/finance/expenses`
}

export const listExpensExpenses = async (
  params?: ListExpensExpensesParams,
  options?: RequestInit
): Promise<listExpensExpensesResponse> => {
  return customInstance<listExpensExpensesResponse>(getListExpensExpensesUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getListExpensExpensesQueryKey = (params?: ListExpensExpensesParams) => {
  return [`/finance/expenses`, ...(params ? [params] : [])] as const
}

export const getListExpensExpensesQueryOptions = <
  TData = Awaited<ReturnType<typeof listExpensExpenses>>,
  TError = HandlerErrorResponse,
>(
  params?: ListExpensExpensesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensExpenses>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListExpensExpensesQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listExpensExpenses>>> = ({ signal }) =>
    listExpensExpenses(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listExpensExpenses>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListExpensExpensesQueryResult = NonNullable<
  Awaited<ReturnType<typeof listExpensExpenses>>
>
export type ListExpensExpensesQueryError = HandlerErrorResponse

export function useListExpensExpenses<
  TData = Awaited<ReturnType<typeof listExpensExpenses>>,
  TError = HandlerErrorResponse,
>(
  params: undefined | ListExpensExpensesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensExpenses>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listExpensExpenses>>,
          TError,
          Awaited<ReturnType<typeof listExpensExpenses>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListExpensExpenses<
  TData = Awaited<ReturnType<typeof listExpensExpenses>>,
  TError = HandlerErrorResponse,
>(
  params?: ListExpensExpensesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listExpensExpenses>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listExpensExpenses>>,
          TError,
          Awaited<ReturnType<typeof listExpensExpenses>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListExpensExpenses<
  TData = Awaited<ReturnType<typeof listExpensExpenses>>,
  TError = HandlerErrorResponse,
>(
  params?: ListExpensExpensesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensExpenses>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List expense records
 */

export function useListExpensExpenses<
  TData = Awaited<ReturnType<typeof listExpensExpenses>>,
  TError = HandlerErrorResponse,
>(
  params?: ListExpensExpensesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensExpenses>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListExpensExpensesQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Create a new expense record
 * @summary Create expense record
 */
export type createExpensExpenseResponse201 = {
  data: HandlerAPIResponseHandlerExpenseRecordResponse
  status: 201
}

export type createExpensExpenseResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type createExpensExpenseResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type createExpensExpenseResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type createExpensExpenseResponseSuccess = createExpensExpenseResponse201 & {
  headers: Headers
}
export type createExpensExpenseResponseError = (
  | createExpensExpenseResponse400
  | createExpensExpenseResponse401
  | createExpensExpenseResponse500
) & {
  headers: Headers
}

export type createExpensExpenseResponse =
  | createExpensExpenseResponseSuccess
  | createExpensExpenseResponseError

export const getCreateExpensExpenseUrl = () => {
  return `/finance/expenses`
}

export const createExpensExpense = async (
  createExpensExpenseBody: CreateExpensExpenseBody,
  options?: RequestInit
): Promise<createExpensExpenseResponse> => {
  return customInstance<createExpensExpenseResponse>(getCreateExpensExpenseUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createExpensExpenseBody),
  })
}

export const getCreateExpensExpenseMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createExpensExpense>>,
    TError,
    { data: CreateExpensExpenseBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createExpensExpense>>,
  TError,
  { data: CreateExpensExpenseBody },
  TContext
> => {
  const mutationKey = ['createExpensExpense']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createExpensExpense>>,
    { data: CreateExpensExpenseBody }
  > = (props) => {
    const { data } = props ?? {}

    return createExpensExpense(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateExpensExpenseMutationResult = NonNullable<
  Awaited<ReturnType<typeof createExpensExpense>>
>
export type CreateExpensExpenseMutationBody = CreateExpensExpenseBody
export type CreateExpensExpenseMutationError = HandlerErrorResponse

/**
 * @summary Create expense record
 */
export const useCreateExpensExpense = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createExpensExpense>>,
      TError,
      { data: CreateExpensExpenseBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createExpensExpense>>,
  TError,
  { data: CreateExpensExpenseBody },
  TContext
> => {
  return useMutation(getCreateExpensExpenseMutationOptions(options), queryClient)
}
/**
 * Delete an expense record (soft delete, only draft status)
 * @summary Delete expense record
 */
export type deleteExpensExpenseResponse200 = {
  data: HandlerSuccessResponse
  status: 200
}

export type deleteExpensExpenseResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type deleteExpensExpenseResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type deleteExpensExpenseResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type deleteExpensExpenseResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type deleteExpensExpenseResponseSuccess = deleteExpensExpenseResponse200 & {
  headers: Headers
}
export type deleteExpensExpenseResponseError = (
  | deleteExpensExpenseResponse400
  | deleteExpensExpenseResponse401
  | deleteExpensExpenseResponse404
  | deleteExpensExpenseResponse500
) & {
  headers: Headers
}

export type deleteExpensExpenseResponse =
  | deleteExpensExpenseResponseSuccess
  | deleteExpensExpenseResponseError

export const getDeleteExpensExpenseUrl = (id: string) => {
  return `/finance/expenses/${id}`
}

export const deleteExpensExpense = async (
  id: string,
  options?: RequestInit
): Promise<deleteExpensExpenseResponse> => {
  return customInstance<deleteExpensExpenseResponse>(getDeleteExpensExpenseUrl(id), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteExpensExpenseMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteExpensExpense>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteExpensExpense>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteExpensExpense']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteExpensExpense>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteExpensExpense(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteExpensExpenseMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteExpensExpense>>
>

export type DeleteExpensExpenseMutationError = HandlerErrorResponse

/**
 * @summary Delete expense record
 */
export const useDeleteExpensExpense = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteExpensExpense>>,
      TError,
      { id: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteExpensExpense>>,
  TError,
  { id: string },
  TContext
> => {
  return useMutation(getDeleteExpensExpenseMutationOptions(options), queryClient)
}
/**
 * Get a single expense record by its ID
 * @summary Get expense record by ID
 */
export type getExpensExpenseResponse200 = {
  data: HandlerAPIResponseHandlerExpenseRecordResponse
  status: 200
}

export type getExpensExpenseResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type getExpensExpenseResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type getExpensExpenseResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type getExpensExpenseResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type getExpensExpenseResponseSuccess = getExpensExpenseResponse200 & {
  headers: Headers
}
export type getExpensExpenseResponseError = (
  | getExpensExpenseResponse400
  | getExpensExpenseResponse401
  | getExpensExpenseResponse404
  | getExpensExpenseResponse500
) & {
  headers: Headers
}

export type getExpensExpenseResponse =
  | getExpensExpenseResponseSuccess
  | getExpensExpenseResponseError

export const getGetExpensExpenseUrl = (id: string) => {
  return `/finance/expenses/${id}`
}

export const getExpensExpense = async (
  id: string,
  options?: RequestInit
): Promise<getExpensExpenseResponse> => {
  return customInstance<getExpensExpenseResponse>(getGetExpensExpenseUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetExpensExpenseQueryKey = (id: string) => {
  return [`/finance/expenses/${id}`] as const
}

export const getGetExpensExpenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getExpensExpense>>,
  TError = HandlerErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensExpense>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetExpensExpenseQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpensExpense>>> = ({ signal }) =>
    getExpensExpense(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExpensExpense>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExpensExpenseQueryResult = NonNullable<Awaited<ReturnType<typeof getExpensExpense>>>
export type GetExpensExpenseQueryError = HandlerErrorResponse

export function useGetExpensExpense<
  TData = Awaited<ReturnType<typeof getExpensExpense>>,
  TError = HandlerErrorResponse,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensExpense>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpensExpense>>,
          TError,
          Awaited<ReturnType<typeof getExpensExpense>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExpensExpense<
  TData = Awaited<ReturnType<typeof getExpensExpense>>,
  TError = HandlerErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensExpense>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpensExpense>>,
          TError,
          Awaited<ReturnType<typeof getExpensExpense>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExpensExpense<
  TData = Awaited<ReturnType<typeof getExpensExpense>>,
  TError = HandlerErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensExpense>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get expense record by ID
 */

export function useGetExpensExpense<
  TData = Awaited<ReturnType<typeof getExpensExpense>>,
  TError = HandlerErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensExpense>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetExpensExpenseQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Update an existing expense record (only draft status)
 * @summary Update expense record
 */
export type updateExpensExpenseResponse200 = {
  data: HandlerAPIResponseHandlerExpenseRecordResponse
  status: 200
}

export type updateExpensExpenseResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type updateExpensExpenseResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type updateExpensExpenseResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type updateExpensExpenseResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type updateExpensExpenseResponseSuccess = updateExpensExpenseResponse200 & {
  headers: Headers
}
export type updateExpensExpenseResponseError = (
  | updateExpensExpenseResponse400
  | updateExpensExpenseResponse401
  | updateExpensExpenseResponse404
  | updateExpensExpenseResponse500
) & {
  headers: Headers
}

export type updateExpensExpenseResponse =
  | updateExpensExpenseResponseSuccess
  | updateExpensExpenseResponseError

export const getUpdateExpensExpenseUrl = (id: string) => {
  return `/finance/expenses/${id}`
}

export const updateExpensExpense = async (
  id: string,
  updateExpensExpenseBody: UpdateExpensExpenseBody,
  options?: RequestInit
): Promise<updateExpensExpenseResponse> => {
  return customInstance<updateExpensExpenseResponse>(getUpdateExpensExpenseUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateExpensExpenseBody),
  })
}

export const getUpdateExpensExpenseMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateExpensExpense>>,
    TError,
    { id: string; data: UpdateExpensExpenseBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateExpensExpense>>,
  TError,
  { id: string; data: UpdateExpensExpenseBody },
  TContext
> => {
  const mutationKey = ['updateExpensExpense']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateExpensExpense>>,
    { id: string; data: UpdateExpensExpenseBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateExpensExpense(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateExpensExpenseMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateExpensExpense>>
>
export type UpdateExpensExpenseMutationBody = UpdateExpensExpenseBody
export type UpdateExpensExpenseMutationError = HandlerErrorResponse

/**
 * @summary Update expense record
 */
export const useUpdateExpensExpense = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateExpensExpense>>,
      TError,
      { id: string; data: UpdateExpensExpenseBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateExpensExpense>>,
  TError,
  { id: string; data: UpdateExpensExpenseBody },
  TContext
> => {
  return useMutation(getUpdateExpensExpenseMutationOptions(options), queryClient)
}
/**
 * Approve an expense record
 * @summary Approve expense
 */
export type approveExpenseExpensResponse200 = {
  data: HandlerAPIResponseHandlerExpenseRecordResponse
  status: 200
}

export type approveExpenseExpensResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type approveExpenseExpensResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type approveExpenseExpensResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type approveExpenseExpensResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type approveExpenseExpensResponseSuccess = approveExpenseExpensResponse200 & {
  headers: Headers
}
export type approveExpenseExpensResponseError = (
  | approveExpenseExpensResponse400
  | approveExpenseExpensResponse401
  | approveExpenseExpensResponse404
  | approveExpenseExpensResponse500
) & {
  headers: Headers
}

export type approveExpenseExpensResponse =
  | approveExpenseExpensResponseSuccess
  | approveExpenseExpensResponseError

export const getApproveExpenseExpensUrl = (id: string) => {
  return `/finance/expenses/${id}/approve`
}

export const approveExpenseExpens = async (
  id: string,
  approveExpenseExpensBody: ApproveExpenseExpensBody,
  options?: RequestInit
): Promise<approveExpenseExpensResponse> => {
  return customInstance<approveExpenseExpensResponse>(getApproveExpenseExpensUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(approveExpenseExpensBody),
  })
}

export const getApproveExpenseExpensMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof approveExpenseExpens>>,
    TError,
    { id: string; data: ApproveExpenseExpensBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof approveExpenseExpens>>,
  TError,
  { id: string; data: ApproveExpenseExpensBody },
  TContext
> => {
  const mutationKey = ['approveExpenseExpens']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof approveExpenseExpens>>,
    { id: string; data: ApproveExpenseExpensBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return approveExpenseExpens(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ApproveExpenseExpensMutationResult = NonNullable<
  Awaited<ReturnType<typeof approveExpenseExpens>>
>
export type ApproveExpenseExpensMutationBody = ApproveExpenseExpensBody
export type ApproveExpenseExpensMutationError = HandlerErrorResponse

/**
 * @summary Approve expense
 */
export const useApproveExpenseExpens = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof approveExpenseExpens>>,
      TError,
      { id: string; data: ApproveExpenseExpensBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof approveExpenseExpens>>,
  TError,
  { id: string; data: ApproveExpenseExpensBody },
  TContext
> => {
  return useMutation(getApproveExpenseExpensMutationOptions(options), queryClient)
}
/**
 * Cancel an expense record
 * @summary Cancel expense
 */
export type cancelExpenseExpensResponse200 = {
  data: HandlerAPIResponseHandlerExpenseRecordResponse
  status: 200
}

export type cancelExpenseExpensResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type cancelExpenseExpensResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type cancelExpenseExpensResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type cancelExpenseExpensResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type cancelExpenseExpensResponseSuccess = cancelExpenseExpensResponse200 & {
  headers: Headers
}
export type cancelExpenseExpensResponseError = (
  | cancelExpenseExpensResponse400
  | cancelExpenseExpensResponse401
  | cancelExpenseExpensResponse404
  | cancelExpenseExpensResponse500
) & {
  headers: Headers
}

export type cancelExpenseExpensResponse =
  | cancelExpenseExpensResponseSuccess
  | cancelExpenseExpensResponseError

export const getCancelExpenseExpensUrl = (id: string) => {
  return `/finance/expenses/${id}/cancel`
}

export const cancelExpenseExpens = async (
  id: string,
  cancelExpenseExpensBody: CancelExpenseExpensBody,
  options?: RequestInit
): Promise<cancelExpenseExpensResponse> => {
  return customInstance<cancelExpenseExpensResponse>(getCancelExpenseExpensUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(cancelExpenseExpensBody),
  })
}

export const getCancelExpenseExpensMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelExpenseExpens>>,
    TError,
    { id: string; data: CancelExpenseExpensBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelExpenseExpens>>,
  TError,
  { id: string; data: CancelExpenseExpensBody },
  TContext
> => {
  const mutationKey = ['cancelExpenseExpens']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelExpenseExpens>>,
    { id: string; data: CancelExpenseExpensBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return cancelExpenseExpens(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CancelExpenseExpensMutationResult = NonNullable<
  Awaited<ReturnType<typeof cancelExpenseExpens>>
>
export type CancelExpenseExpensMutationBody = CancelExpenseExpensBody
export type CancelExpenseExpensMutationError = HandlerErrorResponse

/**
 * @summary Cancel expense
 */
export const useCancelExpenseExpens = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cancelExpenseExpens>>,
      TError,
      { id: string; data: CancelExpenseExpensBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof cancelExpenseExpens>>,
  TError,
  { id: string; data: CancelExpenseExpensBody },
  TContext
> => {
  return useMutation(getCancelExpenseExpensMutationOptions(options), queryClient)
}
/**
 * Mark an approved expense as paid
 * @summary Mark expense as paid
 */
export type markExpensePaidExpensResponse200 = {
  data: HandlerAPIResponseHandlerExpenseRecordResponse
  status: 200
}

export type markExpensePaidExpensResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type markExpensePaidExpensResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type markExpensePaidExpensResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type markExpensePaidExpensResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type markExpensePaidExpensResponseSuccess = markExpensePaidExpensResponse200 & {
  headers: Headers
}
export type markExpensePaidExpensResponseError = (
  | markExpensePaidExpensResponse400
  | markExpensePaidExpensResponse401
  | markExpensePaidExpensResponse404
  | markExpensePaidExpensResponse500
) & {
  headers: Headers
}

export type markExpensePaidExpensResponse =
  | markExpensePaidExpensResponseSuccess
  | markExpensePaidExpensResponseError

export const getMarkExpensePaidExpensUrl = (id: string) => {
  return `/finance/expenses/${id}/pay`
}

export const markExpensePaidExpens = async (
  id: string,
  markExpensePaidExpensBody: MarkExpensePaidExpensBody,
  options?: RequestInit
): Promise<markExpensePaidExpensResponse> => {
  return customInstance<markExpensePaidExpensResponse>(getMarkExpensePaidExpensUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(markExpensePaidExpensBody),
  })
}

export const getMarkExpensePaidExpensMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markExpensePaidExpens>>,
    TError,
    { id: string; data: MarkExpensePaidExpensBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof markExpensePaidExpens>>,
  TError,
  { id: string; data: MarkExpensePaidExpensBody },
  TContext
> => {
  const mutationKey = ['markExpensePaidExpens']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markExpensePaidExpens>>,
    { id: string; data: MarkExpensePaidExpensBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return markExpensePaidExpens(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MarkExpensePaidExpensMutationResult = NonNullable<
  Awaited<ReturnType<typeof markExpensePaidExpens>>
>
export type MarkExpensePaidExpensMutationBody = MarkExpensePaidExpensBody
export type MarkExpensePaidExpensMutationError = HandlerErrorResponse

/**
 * @summary Mark expense as paid
 */
export const useMarkExpensePaidExpens = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markExpensePaidExpens>>,
      TError,
      { id: string; data: MarkExpensePaidExpensBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof markExpensePaidExpens>>,
  TError,
  { id: string; data: MarkExpensePaidExpensBody },
  TContext
> => {
  return useMutation(getMarkExpensePaidExpensMutationOptions(options), queryClient)
}
/**
 * Reject an expense record
 * @summary Reject expense
 */
export type rejectExpenseExpensResponse200 = {
  data: HandlerAPIResponseHandlerExpenseRecordResponse
  status: 200
}

export type rejectExpenseExpensResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type rejectExpenseExpensResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type rejectExpenseExpensResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type rejectExpenseExpensResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type rejectExpenseExpensResponseSuccess = rejectExpenseExpensResponse200 & {
  headers: Headers
}
export type rejectExpenseExpensResponseError = (
  | rejectExpenseExpensResponse400
  | rejectExpenseExpensResponse401
  | rejectExpenseExpensResponse404
  | rejectExpenseExpensResponse500
) & {
  headers: Headers
}

export type rejectExpenseExpensResponse =
  | rejectExpenseExpensResponseSuccess
  | rejectExpenseExpensResponseError

export const getRejectExpenseExpensUrl = (id: string) => {
  return `/finance/expenses/${id}/reject`
}

export const rejectExpenseExpens = async (
  id: string,
  rejectExpenseExpensBody: RejectExpenseExpensBody,
  options?: RequestInit
): Promise<rejectExpenseExpensResponse> => {
  return customInstance<rejectExpenseExpensResponse>(getRejectExpenseExpensUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(rejectExpenseExpensBody),
  })
}

export const getRejectExpenseExpensMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rejectExpenseExpens>>,
    TError,
    { id: string; data: RejectExpenseExpensBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof rejectExpenseExpens>>,
  TError,
  { id: string; data: RejectExpenseExpensBody },
  TContext
> => {
  const mutationKey = ['rejectExpenseExpens']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rejectExpenseExpens>>,
    { id: string; data: RejectExpenseExpensBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return rejectExpenseExpens(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RejectExpenseExpensMutationResult = NonNullable<
  Awaited<ReturnType<typeof rejectExpenseExpens>>
>
export type RejectExpenseExpensMutationBody = RejectExpenseExpensBody
export type RejectExpenseExpensMutationError = HandlerErrorResponse

/**
 * @summary Reject expense
 */
export const useRejectExpenseExpens = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rejectExpenseExpens>>,
      TError,
      { id: string; data: RejectExpenseExpensBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof rejectExpenseExpens>>,
  TError,
  { id: string; data: RejectExpenseExpensBody },
  TContext
> => {
  return useMutation(getRejectExpenseExpensMutationOptions(options), queryClient)
}
/**
 * Submit an expense record for approval
 * @summary Submit expense for approval
 */
export type submitExpenseExpensResponse200 = {
  data: HandlerAPIResponseHandlerExpenseRecordResponse
  status: 200
}

export type submitExpenseExpensResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type submitExpenseExpensResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type submitExpenseExpensResponse404 = {
  data: HandlerErrorResponse
  status: 404
}

export type submitExpenseExpensResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type submitExpenseExpensResponseSuccess = submitExpenseExpensResponse200 & {
  headers: Headers
}
export type submitExpenseExpensResponseError = (
  | submitExpenseExpensResponse400
  | submitExpenseExpensResponse401
  | submitExpenseExpensResponse404
  | submitExpenseExpensResponse500
) & {
  headers: Headers
}

export type submitExpenseExpensResponse =
  | submitExpenseExpensResponseSuccess
  | submitExpenseExpensResponseError

export const getSubmitExpenseExpensUrl = (id: string) => {
  return `/finance/expenses/${id}/submit`
}

export const submitExpenseExpens = async (
  id: string,
  submitExpenseExpensBody: SubmitExpenseExpensBody,
  options?: RequestInit
): Promise<submitExpenseExpensResponse> => {
  return customInstance<submitExpenseExpensResponse>(getSubmitExpenseExpensUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(submitExpenseExpensBody),
  })
}

export const getSubmitExpenseExpensMutationOptions = <
  TError = HandlerErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof submitExpenseExpens>>,
    TError,
    { id: string; data: SubmitExpenseExpensBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof submitExpenseExpens>>,
  TError,
  { id: string; data: SubmitExpenseExpensBody },
  TContext
> => {
  const mutationKey = ['submitExpenseExpens']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof submitExpenseExpens>>,
    { id: string; data: SubmitExpenseExpensBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return submitExpenseExpens(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SubmitExpenseExpensMutationResult = NonNullable<
  Awaited<ReturnType<typeof submitExpenseExpens>>
>
export type SubmitExpenseExpensMutationBody = SubmitExpenseExpensBody
export type SubmitExpenseExpensMutationError = HandlerErrorResponse

/**
 * @summary Submit expense for approval
 */
export const useSubmitExpenseExpens = <TError = HandlerErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof submitExpenseExpens>>,
      TError,
      { id: string; data: SubmitExpenseExpensBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof submitExpenseExpens>>,
  TError,
  { id: string; data: SubmitExpenseExpensBody },
  TContext
> => {
  return useMutation(getSubmitExpenseExpensMutationOptions(options), queryClient)
}
/**
 * Get expense statistics summary
 * @summary Get expenses summary
 */
export type getExpensExpensesSummaryResponse200 = {
  data: HandlerAPIResponseHandlerExpenseSummaryResponse
  status: 200
}

export type getExpensExpensesSummaryResponse400 = {
  data: HandlerErrorResponse
  status: 400
}

export type getExpensExpensesSummaryResponse401 = {
  data: HandlerErrorResponse
  status: 401
}

export type getExpensExpensesSummaryResponse500 = {
  data: HandlerErrorResponse
  status: 500
}

export type getExpensExpensesSummaryResponseSuccess = getExpensExpensesSummaryResponse200 & {
  headers: Headers
}
export type getExpensExpensesSummaryResponseError = (
  | getExpensExpensesSummaryResponse400
  | getExpensExpensesSummaryResponse401
  | getExpensExpensesSummaryResponse500
) & {
  headers: Headers
}

export type getExpensExpensesSummaryResponse =
  | getExpensExpensesSummaryResponseSuccess
  | getExpensExpensesSummaryResponseError

export const getGetExpensExpensesSummaryUrl = (params?: GetExpensExpensesSummaryParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/finance/expenses/summary?${stringifiedParams}`
    : `/finance/expenses/summary`
}

export const getExpensExpensesSummary = async (
  params?: GetExpensExpensesSummaryParams,
  options?: RequestInit
): Promise<getExpensExpensesSummaryResponse> => {
  return customInstance<getExpensExpensesSummaryResponse>(getGetExpensExpensesSummaryUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getGetExpensExpensesSummaryQueryKey = (params?: GetExpensExpensesSummaryParams) => {
  return [`/finance/expenses/summary`, ...(params ? [params] : [])] as const
}

export const getGetExpensExpensesSummaryQueryOptions = <
  TData = Awaited<ReturnType<typeof getExpensExpensesSummary>>,
  TError = HandlerErrorResponse,
>(
  params?: GetExpensExpensesSummaryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExpensExpensesSummary>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetExpensExpensesSummaryQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpensExpensesSummary>>> = ({
    signal,
  }) => getExpensExpensesSummary(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExpensExpensesSummary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExpensExpensesSummaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExpensExpensesSummary>>
>
export type GetExpensExpensesSummaryQueryError = HandlerErrorResponse

export function useGetExpensExpensesSummary<
  TData = Awaited<ReturnType<typeof getExpensExpensesSummary>>,
  TError = HandlerErrorResponse,
>(
  params: undefined | GetExpensExpensesSummaryParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExpensExpensesSummary>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpensExpensesSummary>>,
          TError,
          Awaited<ReturnType<typeof getExpensExpensesSummary>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExpensExpensesSummary<
  TData = Awaited<ReturnType<typeof getExpensExpensesSummary>>,
  TError = HandlerErrorResponse,
>(
  params?: GetExpensExpensesSummaryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExpensExpensesSummary>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpensExpensesSummary>>,
          TError,
          Awaited<ReturnType<typeof getExpensExpensesSummary>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExpensExpensesSummary<
  TData = Awaited<ReturnType<typeof getExpensExpensesSummary>>,
  TError = HandlerErrorResponse,
>(
  params?: GetExpensExpensesSummaryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExpensExpensesSummary>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get expenses summary
 */

export function useGetExpensExpensesSummary<
  TData = Awaited<ReturnType<typeof getExpensExpensesSummary>>,
  TError = HandlerErrorResponse,
>(
  params?: GetExpensExpensesSummaryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExpensExpensesSummary>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetExpensExpensesSummaryQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

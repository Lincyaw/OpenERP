/**
 * // This file is auto-generated by orval
 * // Do not edit manually
 *
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  ActivateUserBody,
  AssignRolesUserBody,
  CreateUserBody,
  DeactivateUserBody,
  DtoErrorResponse,
  HandlerAPIResponseHandlerCountData,
  HandlerAPIResponseHandlerUserListResponse,
  HandlerAPIResponseHandlerUserResponse,
  HandlerSuccessResponse,
  ListUsersParams,
  LockUserBody,
  ResetPasswordUserBody,
  UnlockUserBody,
  UpdateUserBody,
} from '.././models'

import { customInstance } from '../../services/axios-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Get a paginated list of users
 * @summary List users
 */
export type listUsersResponse200 = {
  data: HandlerAPIResponseHandlerUserListResponse
  status: 200
}

export type listUsersResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listUsersResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listUsersResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listUsersResponseSuccess = listUsersResponse200 & {
  headers: Headers
}
export type listUsersResponseError = (
  | listUsersResponse400
  | listUsersResponse401
  | listUsersResponse500
) & {
  headers: Headers
}

export type listUsersResponse = listUsersResponseSuccess | listUsersResponseError

export const getListUsersUrl = (params?: ListUsersParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0 ? `/identity/users?${stringifiedParams}` : `/identity/users`
}

export const listUsers = async (
  params?: ListUsersParams,
  options?: RequestInit
): Promise<listUsersResponse> => {
  return customInstance<listUsersResponse>(getListUsersUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getListUsersQueryKey = (params?: ListUsersParams) => {
  return [`/identity/users`, ...(params ? [params] : [])] as const
}

export const getListUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = DtoErrorResponse,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListUsersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsers>>> = ({ signal }) =>
    listUsers(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListUsersQueryResult = NonNullable<Awaited<ReturnType<typeof listUsers>>>
export type ListUsersQueryError = DtoErrorResponse

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = DtoErrorResponse,
>(
  params: undefined | ListUsersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = DtoErrorResponse,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = DtoErrorResponse,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List users
 */

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = DtoErrorResponse,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListUsersQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Create a new user in the system
 * @summary Create a new user
 */
export type createUserResponse201 = {
  data: HandlerAPIResponseHandlerUserResponse
  status: 201
}

export type createUserResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type createUserResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type createUserResponse403 = {
  data: DtoErrorResponse
  status: 403
}

export type createUserResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type createUserResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type createUserResponseSuccess = createUserResponse201 & {
  headers: Headers
}
export type createUserResponseError = (
  | createUserResponse400
  | createUserResponse401
  | createUserResponse403
  | createUserResponse422
  | createUserResponse500
) & {
  headers: Headers
}

export type createUserResponse = createUserResponseSuccess | createUserResponseError

export const getCreateUserUrl = () => {
  return `/identity/users`
}

export const createUser = async (
  createUserBody: CreateUserBody,
  options?: RequestInit
): Promise<createUserResponse> => {
  return customInstance<createUserResponse>(getCreateUserUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createUserBody),
  })
}

export const getCreateUserMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: CreateUserBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: CreateUserBody },
  TContext
> => {
  const mutationKey = ['createUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: CreateUserBody }
  > = (props) => {
    const { data } = props ?? {}

    return createUser(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
export type CreateUserMutationBody = CreateUserBody
export type CreateUserMutationError = DtoErrorResponse

/**
 * @summary Create a new user
 */
export const useCreateUser = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUser>>,
      TError,
      { data: CreateUserBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: CreateUserBody },
  TContext
> => {
  return useMutation(getCreateUserMutationOptions(options), queryClient)
}
/**
 * Delete a user from the system
 * @summary Delete a user
 */
export type deleteUserResponse200 = {
  data: HandlerSuccessResponse
  status: 200
}

export type deleteUserResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type deleteUserResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type deleteUserResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type deleteUserResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type deleteUserResponseSuccess = deleteUserResponse200 & {
  headers: Headers
}
export type deleteUserResponseError = (
  | deleteUserResponse400
  | deleteUserResponse401
  | deleteUserResponse404
  | deleteUserResponse500
) & {
  headers: Headers
}

export type deleteUserResponse = deleteUserResponseSuccess | deleteUserResponseError

export const getDeleteUserUrl = (id: string) => {
  return `/identity/users/${id}`
}

export const deleteUser = async (
  id: string,
  options?: RequestInit
): Promise<deleteUserResponse> => {
  return customInstance<deleteUserResponse>(getDeleteUserUrl(id), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteUserMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, { id: string }> = (
    props
  ) => {
    const { id } = props ?? {}

    return deleteUser(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>

export type DeleteUserMutationError = DtoErrorResponse

/**
 * @summary Delete a user
 */
export const useDeleteUser = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUser>>,
      TError,
      { id: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteUser>>, TError, { id: string }, TContext> => {
  return useMutation(getDeleteUserMutationOptions(options), queryClient)
}
/**
 * Retrieve a user by their ID
 * @summary Get a user by ID
 */
export type getUserByIdResponse200 = {
  data: HandlerAPIResponseHandlerUserResponse
  status: 200
}

export type getUserByIdResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getUserByIdResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getUserByIdResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getUserByIdResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getUserByIdResponseSuccess = getUserByIdResponse200 & {
  headers: Headers
}
export type getUserByIdResponseError = (
  | getUserByIdResponse400
  | getUserByIdResponse401
  | getUserByIdResponse404
  | getUserByIdResponse500
) & {
  headers: Headers
}

export type getUserByIdResponse = getUserByIdResponseSuccess | getUserByIdResponseError

export const getGetUserByIdUrl = (id: string) => {
  return `/identity/users/${id}`
}

export const getUserById = async (
  id: string,
  options?: RequestInit
): Promise<getUserByIdResponse> => {
  return customInstance<getUserByIdResponse>(getGetUserByIdUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetUserByIdQueryKey = (id: string) => {
  return [`/identity/users/${id}`] as const
}

export const getGetUserByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) =>
    getUserById(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdQueryError = DtoErrorResponse

export function useGetUserById<
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a user by ID
 */

export function useGetUserById<
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUserByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Update a user's information
 * @summary Update a user
 */
export type updateUserResponse200 = {
  data: HandlerAPIResponseHandlerUserResponse
  status: 200
}

export type updateUserResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type updateUserResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type updateUserResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type updateUserResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type updateUserResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type updateUserResponseSuccess = updateUserResponse200 & {
  headers: Headers
}
export type updateUserResponseError = (
  | updateUserResponse400
  | updateUserResponse401
  | updateUserResponse404
  | updateUserResponse422
  | updateUserResponse500
) & {
  headers: Headers
}

export type updateUserResponse = updateUserResponseSuccess | updateUserResponseError

export const getUpdateUserUrl = (id: string) => {
  return `/identity/users/${id}`
}

export const updateUser = async (
  id: string,
  updateUserBody: UpdateUserBody,
  options?: RequestInit
): Promise<updateUserResponse> => {
  return customInstance<updateUserResponse>(getUpdateUserUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateUserBody),
  })
}

export const getUpdateUserMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { id: string; data: UpdateUserBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: UpdateUserBody },
  TContext
> => {
  const mutationKey = ['updateUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { id: string; data: UpdateUserBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateUser(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
export type UpdateUserMutationBody = UpdateUserBody
export type UpdateUserMutationError = DtoErrorResponse

/**
 * @summary Update a user
 */
export const useUpdateUser = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUser>>,
      TError,
      { id: string; data: UpdateUserBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: UpdateUserBody },
  TContext
> => {
  return useMutation(getUpdateUserMutationOptions(options), queryClient)
}
/**
 * Activate a user account
 * @summary Activate a user
 */
export type activateUserResponse200 = {
  data: HandlerAPIResponseHandlerUserResponse
  status: 200
}

export type activateUserResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type activateUserResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type activateUserResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type activateUserResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type activateUserResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type activateUserResponseSuccess = activateUserResponse200 & {
  headers: Headers
}
export type activateUserResponseError = (
  | activateUserResponse400
  | activateUserResponse401
  | activateUserResponse404
  | activateUserResponse422
  | activateUserResponse500
) & {
  headers: Headers
}

export type activateUserResponse = activateUserResponseSuccess | activateUserResponseError

export const getActivateUserUrl = (id: string) => {
  return `/identity/users/${id}/activate`
}

export const activateUser = async (
  id: string,
  activateUserBody: ActivateUserBody,
  options?: RequestInit
): Promise<activateUserResponse> => {
  return customInstance<activateUserResponse>(getActivateUserUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(activateUserBody),
  })
}

export const getActivateUserMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof activateUser>>,
    TError,
    { id: string; data: ActivateUserBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof activateUser>>,
  TError,
  { id: string; data: ActivateUserBody },
  TContext
> => {
  const mutationKey = ['activateUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof activateUser>>,
    { id: string; data: ActivateUserBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return activateUser(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ActivateUserMutationResult = NonNullable<Awaited<ReturnType<typeof activateUser>>>
export type ActivateUserMutationBody = ActivateUserBody
export type ActivateUserMutationError = DtoErrorResponse

/**
 * @summary Activate a user
 */
export const useActivateUser = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof activateUser>>,
      TError,
      { id: string; data: ActivateUserBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof activateUser>>,
  TError,
  { id: string; data: ActivateUserBody },
  TContext
> => {
  return useMutation(getActivateUserMutationOptions(options), queryClient)
}
/**
 * Deactivate a user account
 * @summary Deactivate a user
 */
export type deactivateUserResponse200 = {
  data: HandlerAPIResponseHandlerUserResponse
  status: 200
}

export type deactivateUserResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type deactivateUserResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type deactivateUserResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type deactivateUserResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type deactivateUserResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type deactivateUserResponseSuccess = deactivateUserResponse200 & {
  headers: Headers
}
export type deactivateUserResponseError = (
  | deactivateUserResponse400
  | deactivateUserResponse401
  | deactivateUserResponse404
  | deactivateUserResponse422
  | deactivateUserResponse500
) & {
  headers: Headers
}

export type deactivateUserResponse = deactivateUserResponseSuccess | deactivateUserResponseError

export const getDeactivateUserUrl = (id: string) => {
  return `/identity/users/${id}/deactivate`
}

export const deactivateUser = async (
  id: string,
  deactivateUserBody: DeactivateUserBody,
  options?: RequestInit
): Promise<deactivateUserResponse> => {
  return customInstance<deactivateUserResponse>(getDeactivateUserUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(deactivateUserBody),
  })
}

export const getDeactivateUserMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deactivateUser>>,
    TError,
    { id: string; data: DeactivateUserBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deactivateUser>>,
  TError,
  { id: string; data: DeactivateUserBody },
  TContext
> => {
  const mutationKey = ['deactivateUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deactivateUser>>,
    { id: string; data: DeactivateUserBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return deactivateUser(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeactivateUserMutationResult = NonNullable<Awaited<ReturnType<typeof deactivateUser>>>
export type DeactivateUserMutationBody = DeactivateUserBody
export type DeactivateUserMutationError = DtoErrorResponse

/**
 * @summary Deactivate a user
 */
export const useDeactivateUser = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deactivateUser>>,
      TError,
      { id: string; data: DeactivateUserBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deactivateUser>>,
  TError,
  { id: string; data: DeactivateUserBody },
  TContext
> => {
  return useMutation(getDeactivateUserMutationOptions(options), queryClient)
}
/**
 * Lock a user account for a specified duration
 * @summary Lock a user
 */
export type lockUserResponse200 = {
  data: HandlerAPIResponseHandlerUserResponse
  status: 200
}

export type lockUserResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type lockUserResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type lockUserResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type lockUserResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type lockUserResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type lockUserResponseSuccess = lockUserResponse200 & {
  headers: Headers
}
export type lockUserResponseError = (
  | lockUserResponse400
  | lockUserResponse401
  | lockUserResponse404
  | lockUserResponse422
  | lockUserResponse500
) & {
  headers: Headers
}

export type lockUserResponse = lockUserResponseSuccess | lockUserResponseError

export const getLockUserUrl = (id: string) => {
  return `/identity/users/${id}/lock`
}

export const lockUser = async (
  id: string,
  lockUserBody: LockUserBody,
  options?: RequestInit
): Promise<lockUserResponse> => {
  return customInstance<lockUserResponse>(getLockUserUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(lockUserBody),
  })
}

export const getLockUserMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof lockUser>>,
    TError,
    { id: string; data: LockUserBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof lockUser>>,
  TError,
  { id: string; data: LockUserBody },
  TContext
> => {
  const mutationKey = ['lockUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof lockUser>>,
    { id: string; data: LockUserBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return lockUser(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type LockUserMutationResult = NonNullable<Awaited<ReturnType<typeof lockUser>>>
export type LockUserMutationBody = LockUserBody
export type LockUserMutationError = DtoErrorResponse

/**
 * @summary Lock a user
 */
export const useLockUser = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof lockUser>>,
      TError,
      { id: string; data: LockUserBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof lockUser>>,
  TError,
  { id: string; data: LockUserBody },
  TContext
> => {
  return useMutation(getLockUserMutationOptions(options), queryClient)
}
/**
 * Reset a user's password (admin action)
 * @summary Reset user password
 */
export type resetPasswordUserResponse200 = {
  data: HandlerSuccessResponse
  status: 200
}

export type resetPasswordUserResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type resetPasswordUserResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type resetPasswordUserResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type resetPasswordUserResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type resetPasswordUserResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type resetPasswordUserResponseSuccess = resetPasswordUserResponse200 & {
  headers: Headers
}
export type resetPasswordUserResponseError = (
  | resetPasswordUserResponse400
  | resetPasswordUserResponse401
  | resetPasswordUserResponse404
  | resetPasswordUserResponse422
  | resetPasswordUserResponse500
) & {
  headers: Headers
}

export type resetPasswordUserResponse =
  | resetPasswordUserResponseSuccess
  | resetPasswordUserResponseError

export const getResetPasswordUserUrl = (id: string) => {
  return `/identity/users/${id}/reset-password`
}

export const resetPasswordUser = async (
  id: string,
  resetPasswordUserBody: ResetPasswordUserBody,
  options?: RequestInit
): Promise<resetPasswordUserResponse> => {
  return customInstance<resetPasswordUserResponse>(getResetPasswordUserUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(resetPasswordUserBody),
  })
}

export const getResetPasswordUserMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetPasswordUser>>,
    TError,
    { id: string; data: ResetPasswordUserBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetPasswordUser>>,
  TError,
  { id: string; data: ResetPasswordUserBody },
  TContext
> => {
  const mutationKey = ['resetPasswordUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetPasswordUser>>,
    { id: string; data: ResetPasswordUserBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return resetPasswordUser(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ResetPasswordUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetPasswordUser>>
>
export type ResetPasswordUserMutationBody = ResetPasswordUserBody
export type ResetPasswordUserMutationError = DtoErrorResponse

/**
 * @summary Reset user password
 */
export const useResetPasswordUser = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof resetPasswordUser>>,
      TError,
      { id: string; data: ResetPasswordUserBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof resetPasswordUser>>,
  TError,
  { id: string; data: ResetPasswordUserBody },
  TContext
> => {
  return useMutation(getResetPasswordUserMutationOptions(options), queryClient)
}
/**
 * Assign roles to a user (replaces existing roles)
 * @summary Assign roles to a user
 */
export type assignRolesUserResponse200 = {
  data: HandlerAPIResponseHandlerUserResponse
  status: 200
}

export type assignRolesUserResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type assignRolesUserResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type assignRolesUserResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type assignRolesUserResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type assignRolesUserResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type assignRolesUserResponseSuccess = assignRolesUserResponse200 & {
  headers: Headers
}
export type assignRolesUserResponseError = (
  | assignRolesUserResponse400
  | assignRolesUserResponse401
  | assignRolesUserResponse404
  | assignRolesUserResponse422
  | assignRolesUserResponse500
) & {
  headers: Headers
}

export type assignRolesUserResponse = assignRolesUserResponseSuccess | assignRolesUserResponseError

export const getAssignRolesUserUrl = (id: string) => {
  return `/identity/users/${id}/roles`
}

export const assignRolesUser = async (
  id: string,
  assignRolesUserBody: AssignRolesUserBody,
  options?: RequestInit
): Promise<assignRolesUserResponse> => {
  return customInstance<assignRolesUserResponse>(getAssignRolesUserUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(assignRolesUserBody),
  })
}

export const getAssignRolesUserMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assignRolesUser>>,
    TError,
    { id: string; data: AssignRolesUserBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof assignRolesUser>>,
  TError,
  { id: string; data: AssignRolesUserBody },
  TContext
> => {
  const mutationKey = ['assignRolesUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assignRolesUser>>,
    { id: string; data: AssignRolesUserBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return assignRolesUser(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssignRolesUserMutationResult = NonNullable<Awaited<ReturnType<typeof assignRolesUser>>>
export type AssignRolesUserMutationBody = AssignRolesUserBody
export type AssignRolesUserMutationError = DtoErrorResponse

/**
 * @summary Assign roles to a user
 */
export const useAssignRolesUser = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assignRolesUser>>,
      TError,
      { id: string; data: AssignRolesUserBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof assignRolesUser>>,
  TError,
  { id: string; data: AssignRolesUserBody },
  TContext
> => {
  return useMutation(getAssignRolesUserMutationOptions(options), queryClient)
}
/**
 * Unlock a locked user account
 * @summary Unlock a user
 */
export type unlockUserResponse200 = {
  data: HandlerAPIResponseHandlerUserResponse
  status: 200
}

export type unlockUserResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type unlockUserResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type unlockUserResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type unlockUserResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type unlockUserResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type unlockUserResponseSuccess = unlockUserResponse200 & {
  headers: Headers
}
export type unlockUserResponseError = (
  | unlockUserResponse400
  | unlockUserResponse401
  | unlockUserResponse404
  | unlockUserResponse422
  | unlockUserResponse500
) & {
  headers: Headers
}

export type unlockUserResponse = unlockUserResponseSuccess | unlockUserResponseError

export const getUnlockUserUrl = (id: string) => {
  return `/identity/users/${id}/unlock`
}

export const unlockUser = async (
  id: string,
  unlockUserBody: UnlockUserBody,
  options?: RequestInit
): Promise<unlockUserResponse> => {
  return customInstance<unlockUserResponse>(getUnlockUserUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(unlockUserBody),
  })
}

export const getUnlockUserMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unlockUser>>,
    TError,
    { id: string; data: UnlockUserBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof unlockUser>>,
  TError,
  { id: string; data: UnlockUserBody },
  TContext
> => {
  const mutationKey = ['unlockUser']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unlockUser>>,
    { id: string; data: UnlockUserBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return unlockUser(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UnlockUserMutationResult = NonNullable<Awaited<ReturnType<typeof unlockUser>>>
export type UnlockUserMutationBody = UnlockUserBody
export type UnlockUserMutationError = DtoErrorResponse

/**
 * @summary Unlock a user
 */
export const useUnlockUser = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof unlockUser>>,
      TError,
      { id: string; data: UnlockUserBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof unlockUser>>,
  TError,
  { id: string; data: UnlockUserBody },
  TContext
> => {
  return useMutation(getUnlockUserMutationOptions(options), queryClient)
}
/**
 * Get the total number of users
 * @summary Get user count
 */
export type countUsersResponse200 = {
  data: HandlerAPIResponseHandlerCountData
  status: 200
}

export type countUsersResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type countUsersResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type countUsersResponseSuccess = countUsersResponse200 & {
  headers: Headers
}
export type countUsersResponseError = (countUsersResponse401 | countUsersResponse500) & {
  headers: Headers
}

export type countUsersResponse = countUsersResponseSuccess | countUsersResponseError

export const getCountUsersUrl = () => {
  return `/identity/users/stats/count`
}

export const countUsers = async (options?: RequestInit): Promise<countUsersResponse> => {
  return customInstance<countUsersResponse>(getCountUsersUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getCountUsersQueryKey = () => {
  return [`/identity/users/stats/count`] as const
}

export const getCountUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof countUsers>>,
  TError = DtoErrorResponse,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof countUsers>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getCountUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countUsers>>> = ({ signal }) =>
    countUsers({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof countUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CountUsersQueryResult = NonNullable<Awaited<ReturnType<typeof countUsers>>>
export type CountUsersQueryError = DtoErrorResponse

export function useCountUsers<
  TData = Awaited<ReturnType<typeof countUsers>>,
  TError = DtoErrorResponse,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof countUsers>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof countUsers>>,
          TError,
          Awaited<ReturnType<typeof countUsers>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCountUsers<
  TData = Awaited<ReturnType<typeof countUsers>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof countUsers>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof countUsers>>,
          TError,
          Awaited<ReturnType<typeof countUsers>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCountUsers<
  TData = Awaited<ReturnType<typeof countUsers>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof countUsers>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user count
 */

export function useCountUsers<
  TData = Awaited<ReturnType<typeof countUsers>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof countUsers>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCountUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

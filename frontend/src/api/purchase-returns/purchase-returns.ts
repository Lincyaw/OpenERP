/**
 * // This file is auto-generated by orval
 * // Do not edit manually
 *
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  AddPurchaseReturnItemBody,
  ApprovePurchaseReturnBody,
  CancelPurchaseReturnBody,
  CompletePurchaseReturnBody,
  CreatePurchaseReturnBody,
  DtoErrorResponse,
  HandlerAPIResponseArrayHandlerPurchaseReturnListResponse,
  HandlerAPIResponseHandlerPurchaseReturnResponse,
  HandlerAPIResponseHandlerPurchaseReturnStatusSummaryResponse,
  ListPurchaseReturnsParams,
  RejectPurchaseReturnBody,
  ShipPurchaseReturnBody,
  SubmitPurchaseReturnBody,
  UpdatePurchaseReturnBody,
  UpdatePurchaseReturnItemBody,
} from '.././models'

import { customInstance } from '../../services/axios-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Retrieve a paginated list of purchase returns with optional filtering
 * @summary List purchase returns
 */
export type listPurchaseReturnsResponse200 = {
  data: HandlerAPIResponseArrayHandlerPurchaseReturnListResponse
  status: 200
}

export type listPurchaseReturnsResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listPurchaseReturnsResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listPurchaseReturnsResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listPurchaseReturnsResponseSuccess = listPurchaseReturnsResponse200 & {
  headers: Headers
}
export type listPurchaseReturnsResponseError = (
  | listPurchaseReturnsResponse400
  | listPurchaseReturnsResponse401
  | listPurchaseReturnsResponse500
) & {
  headers: Headers
}

export type listPurchaseReturnsResponse =
  | listPurchaseReturnsResponseSuccess
  | listPurchaseReturnsResponseError

export const getListPurchaseReturnsUrl = (params?: ListPurchaseReturnsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/trade/purchase-returns?${stringifiedParams}`
    : `/trade/purchase-returns`
}

export const listPurchaseReturns = async (
  params?: ListPurchaseReturnsParams,
  options?: RequestInit
): Promise<listPurchaseReturnsResponse> => {
  return customInstance<listPurchaseReturnsResponse>(getListPurchaseReturnsUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getListPurchaseReturnsQueryKey = (params?: ListPurchaseReturnsParams) => {
  return [`/trade/purchase-returns`, ...(params ? [params] : [])] as const
}

export const getListPurchaseReturnsQueryOptions = <
  TData = Awaited<ReturnType<typeof listPurchaseReturns>>,
  TError = DtoErrorResponse,
>(
  params?: ListPurchaseReturnsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listPurchaseReturns>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListPurchaseReturnsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listPurchaseReturns>>> = ({ signal }) =>
    listPurchaseReturns(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listPurchaseReturns>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPurchaseReturnsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listPurchaseReturns>>
>
export type ListPurchaseReturnsQueryError = DtoErrorResponse

export function useListPurchaseReturns<
  TData = Awaited<ReturnType<typeof listPurchaseReturns>>,
  TError = DtoErrorResponse,
>(
  params: undefined | ListPurchaseReturnsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listPurchaseReturns>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPurchaseReturns>>,
          TError,
          Awaited<ReturnType<typeof listPurchaseReturns>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPurchaseReturns<
  TData = Awaited<ReturnType<typeof listPurchaseReturns>>,
  TError = DtoErrorResponse,
>(
  params?: ListPurchaseReturnsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listPurchaseReturns>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPurchaseReturns>>,
          TError,
          Awaited<ReturnType<typeof listPurchaseReturns>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPurchaseReturns<
  TData = Awaited<ReturnType<typeof listPurchaseReturns>>,
  TError = DtoErrorResponse,
>(
  params?: ListPurchaseReturnsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listPurchaseReturns>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List purchase returns
 */

export function useListPurchaseReturns<
  TData = Awaited<ReturnType<typeof listPurchaseReturns>>,
  TError = DtoErrorResponse,
>(
  params?: ListPurchaseReturnsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listPurchaseReturns>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListPurchaseReturnsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Create a new purchase return from an existing purchase order
 * @summary Create a new purchase return
 */
export type createPurchaseReturnResponse201 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 201
}

export type createPurchaseReturnResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type createPurchaseReturnResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type createPurchaseReturnResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type createPurchaseReturnResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type createPurchaseReturnResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type createPurchaseReturnResponseSuccess = createPurchaseReturnResponse201 & {
  headers: Headers
}
export type createPurchaseReturnResponseError = (
  | createPurchaseReturnResponse400
  | createPurchaseReturnResponse401
  | createPurchaseReturnResponse404
  | createPurchaseReturnResponse422
  | createPurchaseReturnResponse500
) & {
  headers: Headers
}

export type createPurchaseReturnResponse =
  | createPurchaseReturnResponseSuccess
  | createPurchaseReturnResponseError

export const getCreatePurchaseReturnUrl = () => {
  return `/trade/purchase-returns`
}

export const createPurchaseReturn = async (
  createPurchaseReturnBody: CreatePurchaseReturnBody,
  options?: RequestInit
): Promise<createPurchaseReturnResponse> => {
  return customInstance<createPurchaseReturnResponse>(getCreatePurchaseReturnUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createPurchaseReturnBody),
  })
}

export const getCreatePurchaseReturnMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPurchaseReturn>>,
    TError,
    { data: CreatePurchaseReturnBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPurchaseReturn>>,
  TError,
  { data: CreatePurchaseReturnBody },
  TContext
> => {
  const mutationKey = ['createPurchaseReturn']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPurchaseReturn>>,
    { data: CreatePurchaseReturnBody }
  > = (props) => {
    const { data } = props ?? {}

    return createPurchaseReturn(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreatePurchaseReturnMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPurchaseReturn>>
>
export type CreatePurchaseReturnMutationBody = CreatePurchaseReturnBody
export type CreatePurchaseReturnMutationError = DtoErrorResponse

/**
 * @summary Create a new purchase return
 */
export const useCreatePurchaseReturn = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPurchaseReturn>>,
      TError,
      { data: CreatePurchaseReturnBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createPurchaseReturn>>,
  TError,
  { data: CreatePurchaseReturnBody },
  TContext
> => {
  return useMutation(getCreatePurchaseReturnMutationOptions(options), queryClient)
}
/**
 * Delete a purchase return (only allowed in DRAFT status)
 * @summary Delete a purchase return
 */
export type deletePurchaseReturnResponse204 = {
  data: void
  status: 204
}

export type deletePurchaseReturnResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type deletePurchaseReturnResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type deletePurchaseReturnResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type deletePurchaseReturnResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type deletePurchaseReturnResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type deletePurchaseReturnResponseSuccess = deletePurchaseReturnResponse204 & {
  headers: Headers
}
export type deletePurchaseReturnResponseError = (
  | deletePurchaseReturnResponse400
  | deletePurchaseReturnResponse401
  | deletePurchaseReturnResponse404
  | deletePurchaseReturnResponse422
  | deletePurchaseReturnResponse500
) & {
  headers: Headers
}

export type deletePurchaseReturnResponse =
  | deletePurchaseReturnResponseSuccess
  | deletePurchaseReturnResponseError

export const getDeletePurchaseReturnUrl = (id: string) => {
  return `/trade/purchase-returns/${id}`
}

export const deletePurchaseReturn = async (
  id: string,
  options?: RequestInit
): Promise<deletePurchaseReturnResponse> => {
  return customInstance<deletePurchaseReturnResponse>(getDeletePurchaseReturnUrl(id), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeletePurchaseReturnMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePurchaseReturn>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePurchaseReturn>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deletePurchaseReturn']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePurchaseReturn>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deletePurchaseReturn(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeletePurchaseReturnMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePurchaseReturn>>
>

export type DeletePurchaseReturnMutationError = DtoErrorResponse

/**
 * @summary Delete a purchase return
 */
export const useDeletePurchaseReturn = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deletePurchaseReturn>>,
      TError,
      { id: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deletePurchaseReturn>>,
  TError,
  { id: string },
  TContext
> => {
  return useMutation(getDeletePurchaseReturnMutationOptions(options), queryClient)
}
/**
 * Retrieve a purchase return by its ID
 * @summary Get purchase return by ID
 */
export type getPurchaseReturnByIdResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 200
}

export type getPurchaseReturnByIdResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getPurchaseReturnByIdResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getPurchaseReturnByIdResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getPurchaseReturnByIdResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getPurchaseReturnByIdResponseSuccess = getPurchaseReturnByIdResponse200 & {
  headers: Headers
}
export type getPurchaseReturnByIdResponseError = (
  | getPurchaseReturnByIdResponse400
  | getPurchaseReturnByIdResponse401
  | getPurchaseReturnByIdResponse404
  | getPurchaseReturnByIdResponse500
) & {
  headers: Headers
}

export type getPurchaseReturnByIdResponse =
  | getPurchaseReturnByIdResponseSuccess
  | getPurchaseReturnByIdResponseError

export const getGetPurchaseReturnByIdUrl = (id: string) => {
  return `/trade/purchase-returns/${id}`
}

export const getPurchaseReturnById = async (
  id: string,
  options?: RequestInit
): Promise<getPurchaseReturnByIdResponse> => {
  return customInstance<getPurchaseReturnByIdResponse>(getGetPurchaseReturnByIdUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetPurchaseReturnByIdQueryKey = (id: string) => {
  return [`/trade/purchase-returns/${id}`] as const
}

export const getGetPurchaseReturnByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getPurchaseReturnById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnById>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetPurchaseReturnByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPurchaseReturnById>>> = ({ signal }) =>
    getPurchaseReturnById(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPurchaseReturnById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPurchaseReturnByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPurchaseReturnById>>
>
export type GetPurchaseReturnByIdQueryError = DtoErrorResponse

export function useGetPurchaseReturnById<
  TData = Awaited<ReturnType<typeof getPurchaseReturnById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseReturnById>>,
          TError,
          Awaited<ReturnType<typeof getPurchaseReturnById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPurchaseReturnById<
  TData = Awaited<ReturnType<typeof getPurchaseReturnById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseReturnById>>,
          TError,
          Awaited<ReturnType<typeof getPurchaseReturnById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPurchaseReturnById<
  TData = Awaited<ReturnType<typeof getPurchaseReturnById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnById>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get purchase return by ID
 */

export function useGetPurchaseReturnById<
  TData = Awaited<ReturnType<typeof getPurchaseReturnById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnById>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPurchaseReturnByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Update a purchase return (only allowed in DRAFT status)
 * @summary Update a purchase return
 */
export type updatePurchaseReturnResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 200
}

export type updatePurchaseReturnResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type updatePurchaseReturnResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type updatePurchaseReturnResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type updatePurchaseReturnResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type updatePurchaseReturnResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type updatePurchaseReturnResponseSuccess = updatePurchaseReturnResponse200 & {
  headers: Headers
}
export type updatePurchaseReturnResponseError = (
  | updatePurchaseReturnResponse400
  | updatePurchaseReturnResponse401
  | updatePurchaseReturnResponse404
  | updatePurchaseReturnResponse422
  | updatePurchaseReturnResponse500
) & {
  headers: Headers
}

export type updatePurchaseReturnResponse =
  | updatePurchaseReturnResponseSuccess
  | updatePurchaseReturnResponseError

export const getUpdatePurchaseReturnUrl = (id: string) => {
  return `/trade/purchase-returns/${id}`
}

export const updatePurchaseReturn = async (
  id: string,
  updatePurchaseReturnBody: UpdatePurchaseReturnBody,
  options?: RequestInit
): Promise<updatePurchaseReturnResponse> => {
  return customInstance<updatePurchaseReturnResponse>(getUpdatePurchaseReturnUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updatePurchaseReturnBody),
  })
}

export const getUpdatePurchaseReturnMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePurchaseReturn>>,
    TError,
    { id: string; data: UpdatePurchaseReturnBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePurchaseReturn>>,
  TError,
  { id: string; data: UpdatePurchaseReturnBody },
  TContext
> => {
  const mutationKey = ['updatePurchaseReturn']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePurchaseReturn>>,
    { id: string; data: UpdatePurchaseReturnBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updatePurchaseReturn(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdatePurchaseReturnMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePurchaseReturn>>
>
export type UpdatePurchaseReturnMutationBody = UpdatePurchaseReturnBody
export type UpdatePurchaseReturnMutationError = DtoErrorResponse

/**
 * @summary Update a purchase return
 */
export const useUpdatePurchaseReturn = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePurchaseReturn>>,
      TError,
      { id: string; data: UpdatePurchaseReturnBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updatePurchaseReturn>>,
  TError,
  { id: string; data: UpdatePurchaseReturnBody },
  TContext
> => {
  return useMutation(getUpdatePurchaseReturnMutationOptions(options), queryClient)
}
/**
 * Approve a purchase return (transitions from PENDING to APPROVED)
 * @summary Approve a purchase return
 */
export type approvePurchaseReturnResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 200
}

export type approvePurchaseReturnResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type approvePurchaseReturnResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type approvePurchaseReturnResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type approvePurchaseReturnResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type approvePurchaseReturnResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type approvePurchaseReturnResponseSuccess = approvePurchaseReturnResponse200 & {
  headers: Headers
}
export type approvePurchaseReturnResponseError = (
  | approvePurchaseReturnResponse400
  | approvePurchaseReturnResponse401
  | approvePurchaseReturnResponse404
  | approvePurchaseReturnResponse422
  | approvePurchaseReturnResponse500
) & {
  headers: Headers
}

export type approvePurchaseReturnResponse =
  | approvePurchaseReturnResponseSuccess
  | approvePurchaseReturnResponseError

export const getApprovePurchaseReturnUrl = (id: string) => {
  return `/trade/purchase-returns/${id}/approve`
}

export const approvePurchaseReturn = async (
  id: string,
  approvePurchaseReturnBody: ApprovePurchaseReturnBody,
  options?: RequestInit
): Promise<approvePurchaseReturnResponse> => {
  return customInstance<approvePurchaseReturnResponse>(getApprovePurchaseReturnUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(approvePurchaseReturnBody),
  })
}

export const getApprovePurchaseReturnMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof approvePurchaseReturn>>,
    TError,
    { id: string; data: ApprovePurchaseReturnBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof approvePurchaseReturn>>,
  TError,
  { id: string; data: ApprovePurchaseReturnBody },
  TContext
> => {
  const mutationKey = ['approvePurchaseReturn']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof approvePurchaseReturn>>,
    { id: string; data: ApprovePurchaseReturnBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return approvePurchaseReturn(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ApprovePurchaseReturnMutationResult = NonNullable<
  Awaited<ReturnType<typeof approvePurchaseReturn>>
>
export type ApprovePurchaseReturnMutationBody = ApprovePurchaseReturnBody
export type ApprovePurchaseReturnMutationError = DtoErrorResponse

/**
 * @summary Approve a purchase return
 */
export const useApprovePurchaseReturn = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof approvePurchaseReturn>>,
      TError,
      { id: string; data: ApprovePurchaseReturnBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof approvePurchaseReturn>>,
  TError,
  { id: string; data: ApprovePurchaseReturnBody },
  TContext
> => {
  return useMutation(getApprovePurchaseReturnMutationOptions(options), queryClient)
}
/**
 * Cancel a purchase return (from DRAFT, PENDING, or APPROVED status - before shipping)
 * @summary Cancel a purchase return
 */
export type cancelPurchaseReturnResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 200
}

export type cancelPurchaseReturnResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type cancelPurchaseReturnResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type cancelPurchaseReturnResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type cancelPurchaseReturnResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type cancelPurchaseReturnResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type cancelPurchaseReturnResponseSuccess = cancelPurchaseReturnResponse200 & {
  headers: Headers
}
export type cancelPurchaseReturnResponseError = (
  | cancelPurchaseReturnResponse400
  | cancelPurchaseReturnResponse401
  | cancelPurchaseReturnResponse404
  | cancelPurchaseReturnResponse422
  | cancelPurchaseReturnResponse500
) & {
  headers: Headers
}

export type cancelPurchaseReturnResponse =
  | cancelPurchaseReturnResponseSuccess
  | cancelPurchaseReturnResponseError

export const getCancelPurchaseReturnUrl = (id: string) => {
  return `/trade/purchase-returns/${id}/cancel`
}

export const cancelPurchaseReturn = async (
  id: string,
  cancelPurchaseReturnBody: CancelPurchaseReturnBody,
  options?: RequestInit
): Promise<cancelPurchaseReturnResponse> => {
  return customInstance<cancelPurchaseReturnResponse>(getCancelPurchaseReturnUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(cancelPurchaseReturnBody),
  })
}

export const getCancelPurchaseReturnMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelPurchaseReturn>>,
    TError,
    { id: string; data: CancelPurchaseReturnBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelPurchaseReturn>>,
  TError,
  { id: string; data: CancelPurchaseReturnBody },
  TContext
> => {
  const mutationKey = ['cancelPurchaseReturn']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelPurchaseReturn>>,
    { id: string; data: CancelPurchaseReturnBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return cancelPurchaseReturn(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CancelPurchaseReturnMutationResult = NonNullable<
  Awaited<ReturnType<typeof cancelPurchaseReturn>>
>
export type CancelPurchaseReturnMutationBody = CancelPurchaseReturnBody
export type CancelPurchaseReturnMutationError = DtoErrorResponse

/**
 * @summary Cancel a purchase return
 */
export const useCancelPurchaseReturn = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cancelPurchaseReturn>>,
      TError,
      { id: string; data: CancelPurchaseReturnBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof cancelPurchaseReturn>>,
  TError,
  { id: string; data: CancelPurchaseReturnBody },
  TContext
> => {
  return useMutation(getCancelPurchaseReturnMutationOptions(options), queryClient)
}
/**
 * Mark a purchase return as completed after supplier confirms receipt (transitions from SHIPPED to COMPLETED)
 * @summary Complete a purchase return
 */
export type completePurchaseReturnResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 200
}

export type completePurchaseReturnResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type completePurchaseReturnResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type completePurchaseReturnResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type completePurchaseReturnResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type completePurchaseReturnResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type completePurchaseReturnResponseSuccess = completePurchaseReturnResponse200 & {
  headers: Headers
}
export type completePurchaseReturnResponseError = (
  | completePurchaseReturnResponse400
  | completePurchaseReturnResponse401
  | completePurchaseReturnResponse404
  | completePurchaseReturnResponse422
  | completePurchaseReturnResponse500
) & {
  headers: Headers
}

export type completePurchaseReturnResponse =
  | completePurchaseReturnResponseSuccess
  | completePurchaseReturnResponseError

export const getCompletePurchaseReturnUrl = (id: string) => {
  return `/trade/purchase-returns/${id}/complete`
}

export const completePurchaseReturn = async (
  id: string,
  completePurchaseReturnBody: CompletePurchaseReturnBody,
  options?: RequestInit
): Promise<completePurchaseReturnResponse> => {
  return customInstance<completePurchaseReturnResponse>(getCompletePurchaseReturnUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(completePurchaseReturnBody),
  })
}

export const getCompletePurchaseReturnMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof completePurchaseReturn>>,
    TError,
    { id: string; data: CompletePurchaseReturnBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof completePurchaseReturn>>,
  TError,
  { id: string; data: CompletePurchaseReturnBody },
  TContext
> => {
  const mutationKey = ['completePurchaseReturn']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof completePurchaseReturn>>,
    { id: string; data: CompletePurchaseReturnBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return completePurchaseReturn(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CompletePurchaseReturnMutationResult = NonNullable<
  Awaited<ReturnType<typeof completePurchaseReturn>>
>
export type CompletePurchaseReturnMutationBody = CompletePurchaseReturnBody
export type CompletePurchaseReturnMutationError = DtoErrorResponse

/**
 * @summary Complete a purchase return
 */
export const useCompletePurchaseReturn = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof completePurchaseReturn>>,
      TError,
      { id: string; data: CompletePurchaseReturnBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof completePurchaseReturn>>,
  TError,
  { id: string; data: CompletePurchaseReturnBody },
  TContext
> => {
  return useMutation(getCompletePurchaseReturnMutationOptions(options), queryClient)
}
/**
 * Add a new item to a purchase return (only allowed in DRAFT status)
 * @summary Add item to purchase return
 */
export type addPurchaseReturnItemResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 200
}

export type addPurchaseReturnItemResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type addPurchaseReturnItemResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type addPurchaseReturnItemResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type addPurchaseReturnItemResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type addPurchaseReturnItemResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type addPurchaseReturnItemResponseSuccess = addPurchaseReturnItemResponse200 & {
  headers: Headers
}
export type addPurchaseReturnItemResponseError = (
  | addPurchaseReturnItemResponse400
  | addPurchaseReturnItemResponse401
  | addPurchaseReturnItemResponse404
  | addPurchaseReturnItemResponse422
  | addPurchaseReturnItemResponse500
) & {
  headers: Headers
}

export type addPurchaseReturnItemResponse =
  | addPurchaseReturnItemResponseSuccess
  | addPurchaseReturnItemResponseError

export const getAddPurchaseReturnItemUrl = (id: string) => {
  return `/trade/purchase-returns/${id}/items`
}

export const addPurchaseReturnItem = async (
  id: string,
  addPurchaseReturnItemBody: AddPurchaseReturnItemBody,
  options?: RequestInit
): Promise<addPurchaseReturnItemResponse> => {
  return customInstance<addPurchaseReturnItemResponse>(getAddPurchaseReturnItemUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(addPurchaseReturnItemBody),
  })
}

export const getAddPurchaseReturnItemMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addPurchaseReturnItem>>,
    TError,
    { id: string; data: AddPurchaseReturnItemBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof addPurchaseReturnItem>>,
  TError,
  { id: string; data: AddPurchaseReturnItemBody },
  TContext
> => {
  const mutationKey = ['addPurchaseReturnItem']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addPurchaseReturnItem>>,
    { id: string; data: AddPurchaseReturnItemBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return addPurchaseReturnItem(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AddPurchaseReturnItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof addPurchaseReturnItem>>
>
export type AddPurchaseReturnItemMutationBody = AddPurchaseReturnItemBody
export type AddPurchaseReturnItemMutationError = DtoErrorResponse

/**
 * @summary Add item to purchase return
 */
export const useAddPurchaseReturnItem = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addPurchaseReturnItem>>,
      TError,
      { id: string; data: AddPurchaseReturnItemBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof addPurchaseReturnItem>>,
  TError,
  { id: string; data: AddPurchaseReturnItemBody },
  TContext
> => {
  return useMutation(getAddPurchaseReturnItemMutationOptions(options), queryClient)
}
/**
 * Remove an item from a purchase return (only allowed in DRAFT status)
 * @summary Remove item from purchase return
 */
export type removePurchaseReturnItemResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 200
}

export type removePurchaseReturnItemResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type removePurchaseReturnItemResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type removePurchaseReturnItemResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type removePurchaseReturnItemResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type removePurchaseReturnItemResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type removePurchaseReturnItemResponseSuccess = removePurchaseReturnItemResponse200 & {
  headers: Headers
}
export type removePurchaseReturnItemResponseError = (
  | removePurchaseReturnItemResponse400
  | removePurchaseReturnItemResponse401
  | removePurchaseReturnItemResponse404
  | removePurchaseReturnItemResponse422
  | removePurchaseReturnItemResponse500
) & {
  headers: Headers
}

export type removePurchaseReturnItemResponse =
  | removePurchaseReturnItemResponseSuccess
  | removePurchaseReturnItemResponseError

export const getRemovePurchaseReturnItemUrl = (id: string, itemId: string) => {
  return `/trade/purchase-returns/${id}/items/${itemId}`
}

export const removePurchaseReturnItem = async (
  id: string,
  itemId: string,
  options?: RequestInit
): Promise<removePurchaseReturnItemResponse> => {
  return customInstance<removePurchaseReturnItemResponse>(
    getRemovePurchaseReturnItemUrl(id, itemId),
    {
      ...options,
      method: 'DELETE',
    }
  )
}

export const getRemovePurchaseReturnItemMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removePurchaseReturnItem>>,
    TError,
    { id: string; itemId: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof removePurchaseReturnItem>>,
  TError,
  { id: string; itemId: string },
  TContext
> => {
  const mutationKey = ['removePurchaseReturnItem']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removePurchaseReturnItem>>,
    { id: string; itemId: string }
  > = (props) => {
    const { id, itemId } = props ?? {}

    return removePurchaseReturnItem(id, itemId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RemovePurchaseReturnItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof removePurchaseReturnItem>>
>

export type RemovePurchaseReturnItemMutationError = DtoErrorResponse

/**
 * @summary Remove item from purchase return
 */
export const useRemovePurchaseReturnItem = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removePurchaseReturnItem>>,
      TError,
      { id: string; itemId: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof removePurchaseReturnItem>>,
  TError,
  { id: string; itemId: string },
  TContext
> => {
  return useMutation(getRemovePurchaseReturnItemMutationOptions(options), queryClient)
}
/**
 * Update an item in a purchase return (only allowed in DRAFT status)
 * @summary Update return item
 */
export type updatePurchaseReturnItemResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 200
}

export type updatePurchaseReturnItemResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type updatePurchaseReturnItemResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type updatePurchaseReturnItemResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type updatePurchaseReturnItemResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type updatePurchaseReturnItemResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type updatePurchaseReturnItemResponseSuccess = updatePurchaseReturnItemResponse200 & {
  headers: Headers
}
export type updatePurchaseReturnItemResponseError = (
  | updatePurchaseReturnItemResponse400
  | updatePurchaseReturnItemResponse401
  | updatePurchaseReturnItemResponse404
  | updatePurchaseReturnItemResponse422
  | updatePurchaseReturnItemResponse500
) & {
  headers: Headers
}

export type updatePurchaseReturnItemResponse =
  | updatePurchaseReturnItemResponseSuccess
  | updatePurchaseReturnItemResponseError

export const getUpdatePurchaseReturnItemUrl = (id: string, itemId: string) => {
  return `/trade/purchase-returns/${id}/items/${itemId}`
}

export const updatePurchaseReturnItem = async (
  id: string,
  itemId: string,
  updatePurchaseReturnItemBody: UpdatePurchaseReturnItemBody,
  options?: RequestInit
): Promise<updatePurchaseReturnItemResponse> => {
  return customInstance<updatePurchaseReturnItemResponse>(
    getUpdatePurchaseReturnItemUrl(id, itemId),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(updatePurchaseReturnItemBody),
    }
  )
}

export const getUpdatePurchaseReturnItemMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePurchaseReturnItem>>,
    TError,
    { id: string; itemId: string; data: UpdatePurchaseReturnItemBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePurchaseReturnItem>>,
  TError,
  { id: string; itemId: string; data: UpdatePurchaseReturnItemBody },
  TContext
> => {
  const mutationKey = ['updatePurchaseReturnItem']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePurchaseReturnItem>>,
    { id: string; itemId: string; data: UpdatePurchaseReturnItemBody }
  > = (props) => {
    const { id, itemId, data } = props ?? {}

    return updatePurchaseReturnItem(id, itemId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdatePurchaseReturnItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePurchaseReturnItem>>
>
export type UpdatePurchaseReturnItemMutationBody = UpdatePurchaseReturnItemBody
export type UpdatePurchaseReturnItemMutationError = DtoErrorResponse

/**
 * @summary Update return item
 */
export const useUpdatePurchaseReturnItem = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePurchaseReturnItem>>,
      TError,
      { id: string; itemId: string; data: UpdatePurchaseReturnItemBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updatePurchaseReturnItem>>,
  TError,
  { id: string; itemId: string; data: UpdatePurchaseReturnItemBody },
  TContext
> => {
  return useMutation(getUpdatePurchaseReturnItemMutationOptions(options), queryClient)
}
/**
 * Reject a purchase return (transitions from PENDING to REJECTED)
 * @summary Reject a purchase return
 */
export type rejectPurchaseReturnResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 200
}

export type rejectPurchaseReturnResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type rejectPurchaseReturnResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type rejectPurchaseReturnResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type rejectPurchaseReturnResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type rejectPurchaseReturnResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type rejectPurchaseReturnResponseSuccess = rejectPurchaseReturnResponse200 & {
  headers: Headers
}
export type rejectPurchaseReturnResponseError = (
  | rejectPurchaseReturnResponse400
  | rejectPurchaseReturnResponse401
  | rejectPurchaseReturnResponse404
  | rejectPurchaseReturnResponse422
  | rejectPurchaseReturnResponse500
) & {
  headers: Headers
}

export type rejectPurchaseReturnResponse =
  | rejectPurchaseReturnResponseSuccess
  | rejectPurchaseReturnResponseError

export const getRejectPurchaseReturnUrl = (id: string) => {
  return `/trade/purchase-returns/${id}/reject`
}

export const rejectPurchaseReturn = async (
  id: string,
  rejectPurchaseReturnBody: RejectPurchaseReturnBody,
  options?: RequestInit
): Promise<rejectPurchaseReturnResponse> => {
  return customInstance<rejectPurchaseReturnResponse>(getRejectPurchaseReturnUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(rejectPurchaseReturnBody),
  })
}

export const getRejectPurchaseReturnMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rejectPurchaseReturn>>,
    TError,
    { id: string; data: RejectPurchaseReturnBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof rejectPurchaseReturn>>,
  TError,
  { id: string; data: RejectPurchaseReturnBody },
  TContext
> => {
  const mutationKey = ['rejectPurchaseReturn']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rejectPurchaseReturn>>,
    { id: string; data: RejectPurchaseReturnBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return rejectPurchaseReturn(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RejectPurchaseReturnMutationResult = NonNullable<
  Awaited<ReturnType<typeof rejectPurchaseReturn>>
>
export type RejectPurchaseReturnMutationBody = RejectPurchaseReturnBody
export type RejectPurchaseReturnMutationError = DtoErrorResponse

/**
 * @summary Reject a purchase return
 */
export const useRejectPurchaseReturn = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rejectPurchaseReturn>>,
      TError,
      { id: string; data: RejectPurchaseReturnBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof rejectPurchaseReturn>>,
  TError,
  { id: string; data: RejectPurchaseReturnBody },
  TContext
> => {
  return useMutation(getRejectPurchaseReturnMutationOptions(options), queryClient)
}
/**
 * Mark a purchase return as shipped back to supplier (transitions from APPROVED to SHIPPED, triggers inventory deduction)
 * @summary Ship a purchase return
 */
export type shipPurchaseReturnResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 200
}

export type shipPurchaseReturnResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type shipPurchaseReturnResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type shipPurchaseReturnResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type shipPurchaseReturnResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type shipPurchaseReturnResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type shipPurchaseReturnResponseSuccess = shipPurchaseReturnResponse200 & {
  headers: Headers
}
export type shipPurchaseReturnResponseError = (
  | shipPurchaseReturnResponse400
  | shipPurchaseReturnResponse401
  | shipPurchaseReturnResponse404
  | shipPurchaseReturnResponse422
  | shipPurchaseReturnResponse500
) & {
  headers: Headers
}

export type shipPurchaseReturnResponse =
  | shipPurchaseReturnResponseSuccess
  | shipPurchaseReturnResponseError

export const getShipPurchaseReturnUrl = (id: string) => {
  return `/trade/purchase-returns/${id}/ship`
}

export const shipPurchaseReturn = async (
  id: string,
  shipPurchaseReturnBody: ShipPurchaseReturnBody,
  options?: RequestInit
): Promise<shipPurchaseReturnResponse> => {
  return customInstance<shipPurchaseReturnResponse>(getShipPurchaseReturnUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(shipPurchaseReturnBody),
  })
}

export const getShipPurchaseReturnMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof shipPurchaseReturn>>,
    TError,
    { id: string; data: ShipPurchaseReturnBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof shipPurchaseReturn>>,
  TError,
  { id: string; data: ShipPurchaseReturnBody },
  TContext
> => {
  const mutationKey = ['shipPurchaseReturn']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof shipPurchaseReturn>>,
    { id: string; data: ShipPurchaseReturnBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return shipPurchaseReturn(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ShipPurchaseReturnMutationResult = NonNullable<
  Awaited<ReturnType<typeof shipPurchaseReturn>>
>
export type ShipPurchaseReturnMutationBody = ShipPurchaseReturnBody
export type ShipPurchaseReturnMutationError = DtoErrorResponse

/**
 * @summary Ship a purchase return
 */
export const useShipPurchaseReturn = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof shipPurchaseReturn>>,
      TError,
      { id: string; data: ShipPurchaseReturnBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof shipPurchaseReturn>>,
  TError,
  { id: string; data: ShipPurchaseReturnBody },
  TContext
> => {
  return useMutation(getShipPurchaseReturnMutationOptions(options), queryClient)
}
/**
 * Submit a purchase return for approval (transitions from DRAFT to PENDING)
 * @summary Submit a purchase return for approval
 */
export type submitPurchaseReturnResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 200
}

export type submitPurchaseReturnResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type submitPurchaseReturnResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type submitPurchaseReturnResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type submitPurchaseReturnResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type submitPurchaseReturnResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type submitPurchaseReturnResponseSuccess = submitPurchaseReturnResponse200 & {
  headers: Headers
}
export type submitPurchaseReturnResponseError = (
  | submitPurchaseReturnResponse400
  | submitPurchaseReturnResponse401
  | submitPurchaseReturnResponse404
  | submitPurchaseReturnResponse422
  | submitPurchaseReturnResponse500
) & {
  headers: Headers
}

export type submitPurchaseReturnResponse =
  | submitPurchaseReturnResponseSuccess
  | submitPurchaseReturnResponseError

export const getSubmitPurchaseReturnUrl = (id: string) => {
  return `/trade/purchase-returns/${id}/submit`
}

export const submitPurchaseReturn = async (
  id: string,
  submitPurchaseReturnBody: SubmitPurchaseReturnBody,
  options?: RequestInit
): Promise<submitPurchaseReturnResponse> => {
  return customInstance<submitPurchaseReturnResponse>(getSubmitPurchaseReturnUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(submitPurchaseReturnBody),
  })
}

export const getSubmitPurchaseReturnMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof submitPurchaseReturn>>,
    TError,
    { id: string; data: SubmitPurchaseReturnBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof submitPurchaseReturn>>,
  TError,
  { id: string; data: SubmitPurchaseReturnBody },
  TContext
> => {
  const mutationKey = ['submitPurchaseReturn']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof submitPurchaseReturn>>,
    { id: string; data: SubmitPurchaseReturnBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return submitPurchaseReturn(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SubmitPurchaseReturnMutationResult = NonNullable<
  Awaited<ReturnType<typeof submitPurchaseReturn>>
>
export type SubmitPurchaseReturnMutationBody = SubmitPurchaseReturnBody
export type SubmitPurchaseReturnMutationError = DtoErrorResponse

/**
 * @summary Submit a purchase return for approval
 */
export const useSubmitPurchaseReturn = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof submitPurchaseReturn>>,
      TError,
      { id: string; data: SubmitPurchaseReturnBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof submitPurchaseReturn>>,
  TError,
  { id: string; data: SubmitPurchaseReturnBody },
  TContext
> => {
  return useMutation(getSubmitPurchaseReturnMutationOptions(options), queryClient)
}
/**
 * Retrieve a purchase return by its return number
 * @summary Get purchase return by return number
 */
export type getPurchaseReturnByReturnNumberResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnResponse
  status: 200
}

export type getPurchaseReturnByReturnNumberResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getPurchaseReturnByReturnNumberResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getPurchaseReturnByReturnNumberResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getPurchaseReturnByReturnNumberResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getPurchaseReturnByReturnNumberResponseSuccess =
  getPurchaseReturnByReturnNumberResponse200 & {
    headers: Headers
  }
export type getPurchaseReturnByReturnNumberResponseError = (
  | getPurchaseReturnByReturnNumberResponse400
  | getPurchaseReturnByReturnNumberResponse401
  | getPurchaseReturnByReturnNumberResponse404
  | getPurchaseReturnByReturnNumberResponse500
) & {
  headers: Headers
}

export type getPurchaseReturnByReturnNumberResponse =
  | getPurchaseReturnByReturnNumberResponseSuccess
  | getPurchaseReturnByReturnNumberResponseError

export const getGetPurchaseReturnByReturnNumberUrl = (returnNumber: string) => {
  return `/trade/purchase-returns/number/${returnNumber}`
}

export const getPurchaseReturnByReturnNumber = async (
  returnNumber: string,
  options?: RequestInit
): Promise<getPurchaseReturnByReturnNumberResponse> => {
  return customInstance<getPurchaseReturnByReturnNumberResponse>(
    getGetPurchaseReturnByReturnNumberUrl(returnNumber),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getGetPurchaseReturnByReturnNumberQueryKey = (returnNumber: string) => {
  return [`/trade/purchase-returns/number/${returnNumber}`] as const
}

export const getGetPurchaseReturnByReturnNumberQueryOptions = <
  TData = Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>,
  TError = DtoErrorResponse,
>(
  returnNumber: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetPurchaseReturnByReturnNumberQueryKey(returnNumber)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>> = ({
    signal,
  }) => getPurchaseReturnByReturnNumber(returnNumber, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!returnNumber, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPurchaseReturnByReturnNumberQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>
>
export type GetPurchaseReturnByReturnNumberQueryError = DtoErrorResponse

export function useGetPurchaseReturnByReturnNumber<
  TData = Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>,
  TError = DtoErrorResponse,
>(
  returnNumber: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>,
          TError,
          Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPurchaseReturnByReturnNumber<
  TData = Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>,
  TError = DtoErrorResponse,
>(
  returnNumber: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>,
          TError,
          Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPurchaseReturnByReturnNumber<
  TData = Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>,
  TError = DtoErrorResponse,
>(
  returnNumber: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get purchase return by return number
 */

export function useGetPurchaseReturnByReturnNumber<
  TData = Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>,
  TError = DtoErrorResponse,
>(
  returnNumber: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnByReturnNumber>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPurchaseReturnByReturnNumberQueryOptions(returnNumber, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Get count of returns by status for dashboard
 * @summary Get return status summary
 */
export type getPurchaseReturnStatusSummaryResponse200 = {
  data: HandlerAPIResponseHandlerPurchaseReturnStatusSummaryResponse
  status: 200
}

export type getPurchaseReturnStatusSummaryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getPurchaseReturnStatusSummaryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getPurchaseReturnStatusSummaryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getPurchaseReturnStatusSummaryResponseSuccess =
  getPurchaseReturnStatusSummaryResponse200 & {
    headers: Headers
  }
export type getPurchaseReturnStatusSummaryResponseError = (
  | getPurchaseReturnStatusSummaryResponse400
  | getPurchaseReturnStatusSummaryResponse401
  | getPurchaseReturnStatusSummaryResponse500
) & {
  headers: Headers
}

export type getPurchaseReturnStatusSummaryResponse =
  | getPurchaseReturnStatusSummaryResponseSuccess
  | getPurchaseReturnStatusSummaryResponseError

export const getGetPurchaseReturnStatusSummaryUrl = () => {
  return `/trade/purchase-returns/stats/summary`
}

export const getPurchaseReturnStatusSummary = async (
  options?: RequestInit
): Promise<getPurchaseReturnStatusSummaryResponse> => {
  return customInstance<getPurchaseReturnStatusSummaryResponse>(
    getGetPurchaseReturnStatusSummaryUrl(),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getGetPurchaseReturnStatusSummaryQueryKey = () => {
  return [`/trade/purchase-returns/stats/summary`] as const
}

export const getGetPurchaseReturnStatusSummaryQueryOptions = <
  TData = Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>,
  TError = DtoErrorResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>, TError, TData>
  >
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetPurchaseReturnStatusSummaryQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>> = ({
    signal,
  }) => getPurchaseReturnStatusSummary({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPurchaseReturnStatusSummaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>
>
export type GetPurchaseReturnStatusSummaryQueryError = DtoErrorResponse

export function useGetPurchaseReturnStatusSummary<
  TData = Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>,
  TError = DtoErrorResponse,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>,
          TError,
          Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPurchaseReturnStatusSummary<
  TData = Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>,
          TError,
          Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPurchaseReturnStatusSummary<
  TData = Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get return status summary
 */

export function useGetPurchaseReturnStatusSummary<
  TData = Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPurchaseReturnStatusSummary>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPurchaseReturnStatusSummaryQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * // This file is auto-generated by orval
 * // Do not edit manually
 *
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  ActivateProductBody,
  CreateProductBody,
  DeactivateProductBody,
  DiscontinueProductBody,
  DtoErrorResponse,
  GetProductByCategoryParams,
  HandlerAPIResponseArrayHandlerProductListResponse,
  HandlerAPIResponseHandlerCountByStatusResponse,
  HandlerAPIResponseHandlerProductResponse,
  ListProductsParams,
  UpdateProductBody,
  UpdateProductCodeBody,
} from '.././models'

import { customInstance } from '../../services/axios-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Retrieve products belonging to a specific category
 * @summary Get products by category
 */
export type getProductByCategoryResponse200 = {
  data: HandlerAPIResponseArrayHandlerProductListResponse
  status: 200
}

export type getProductByCategoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getProductByCategoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getProductByCategoryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getProductByCategoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getProductByCategoryResponseSuccess = getProductByCategoryResponse200 & {
  headers: Headers
}
export type getProductByCategoryResponseError = (
  | getProductByCategoryResponse400
  | getProductByCategoryResponse401
  | getProductByCategoryResponse404
  | getProductByCategoryResponse500
) & {
  headers: Headers
}

export type getProductByCategoryResponse =
  | getProductByCategoryResponseSuccess
  | getProductByCategoryResponseError

export const getGetProductByCategoryUrl = (
  categoryId: string,
  params?: GetProductByCategoryParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/catalog/categories/${categoryId}/products?${stringifiedParams}`
    : `/catalog/categories/${categoryId}/products`
}

export const getProductByCategory = async (
  categoryId: string,
  params?: GetProductByCategoryParams,
  options?: RequestInit
): Promise<getProductByCategoryResponse> => {
  return customInstance<getProductByCategoryResponse>(
    getGetProductByCategoryUrl(categoryId, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getGetProductByCategoryQueryKey = (
  categoryId: string,
  params?: GetProductByCategoryParams
) => {
  return [`/catalog/categories/${categoryId}/products`, ...(params ? [params] : [])] as const
}

export const getGetProductByCategoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductByCategory>>,
  TError = DtoErrorResponse,
>(
  categoryId: string,
  params?: GetProductByCategoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProductByCategory>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProductByCategoryQueryKey(categoryId, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductByCategory>>> = ({ signal }) =>
    getProductByCategory(categoryId, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!categoryId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductByCategory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductByCategoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductByCategory>>
>
export type GetProductByCategoryQueryError = DtoErrorResponse

export function useGetProductByCategory<
  TData = Awaited<ReturnType<typeof getProductByCategory>>,
  TError = DtoErrorResponse,
>(
  categoryId: string,
  params: undefined | GetProductByCategoryParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProductByCategory>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductByCategory>>,
          TError,
          Awaited<ReturnType<typeof getProductByCategory>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProductByCategory<
  TData = Awaited<ReturnType<typeof getProductByCategory>>,
  TError = DtoErrorResponse,
>(
  categoryId: string,
  params?: GetProductByCategoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProductByCategory>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductByCategory>>,
          TError,
          Awaited<ReturnType<typeof getProductByCategory>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProductByCategory<
  TData = Awaited<ReturnType<typeof getProductByCategory>>,
  TError = DtoErrorResponse,
>(
  categoryId: string,
  params?: GetProductByCategoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProductByCategory>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get products by category
 */

export function useGetProductByCategory<
  TData = Awaited<ReturnType<typeof getProductByCategory>>,
  TError = DtoErrorResponse,
>(
  categoryId: string,
  params?: GetProductByCategoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProductByCategory>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProductByCategoryQueryOptions(categoryId, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Retrieve a paginated list of products with optional filtering
 * @summary List products
 */
export type listProductsResponse200 = {
  data: HandlerAPIResponseArrayHandlerProductListResponse
  status: 200
}

export type listProductsResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listProductsResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listProductsResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listProductsResponseSuccess = listProductsResponse200 & {
  headers: Headers
}
export type listProductsResponseError = (
  | listProductsResponse400
  | listProductsResponse401
  | listProductsResponse500
) & {
  headers: Headers
}

export type listProductsResponse = listProductsResponseSuccess | listProductsResponseError

export const getListProductsUrl = (params?: ListProductsParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/catalog/products?${stringifiedParams}`
    : `/catalog/products`
}

export const listProducts = async (
  params?: ListProductsParams,
  options?: RequestInit
): Promise<listProductsResponse> => {
  return customInstance<listProductsResponse>(getListProductsUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getListProductsQueryKey = (params?: ListProductsParams) => {
  return [`/catalog/products`, ...(params ? [params] : [])] as const
}

export const getListProductsQueryOptions = <
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = DtoErrorResponse,
>(
  params?: ListProductsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListProductsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listProducts>>> = ({ signal }) =>
    listProducts(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListProductsQueryResult = NonNullable<Awaited<ReturnType<typeof listProducts>>>
export type ListProductsQueryError = DtoErrorResponse

export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = DtoErrorResponse,
>(
  params: undefined | ListProductsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProducts>>,
          TError,
          Awaited<ReturnType<typeof listProducts>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = DtoErrorResponse,
>(
  params?: ListProductsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProducts>>,
          TError,
          Awaited<ReturnType<typeof listProducts>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = DtoErrorResponse,
>(
  params?: ListProductsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List products
 */

export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = DtoErrorResponse,
>(
  params?: ListProductsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListProductsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Create a new product in the catalog
 * @summary Create a new product
 */
export type createProductResponse201 = {
  data: HandlerAPIResponseHandlerProductResponse
  status: 201
}

export type createProductResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type createProductResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type createProductResponse409 = {
  data: DtoErrorResponse
  status: 409
}

export type createProductResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type createProductResponseSuccess = createProductResponse201 & {
  headers: Headers
}
export type createProductResponseError = (
  | createProductResponse400
  | createProductResponse401
  | createProductResponse409
  | createProductResponse500
) & {
  headers: Headers
}

export type createProductResponse = createProductResponseSuccess | createProductResponseError

export const getCreateProductUrl = () => {
  return `/catalog/products`
}

export const createProduct = async (
  createProductBody: CreateProductBody,
  options?: RequestInit
): Promise<createProductResponse> => {
  return customInstance<createProductResponse>(getCreateProductUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createProductBody),
  })
}

export const getCreateProductMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProduct>>,
    TError,
    { data: CreateProductBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { data: CreateProductBody },
  TContext
> => {
  const mutationKey = ['createProduct']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProduct>>,
    { data: CreateProductBody }
  > = (props) => {
    const { data } = props ?? {}

    return createProduct(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateProductMutationResult = NonNullable<Awaited<ReturnType<typeof createProduct>>>
export type CreateProductMutationBody = CreateProductBody
export type CreateProductMutationError = DtoErrorResponse

/**
 * @summary Create a new product
 */
export const useCreateProduct = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProduct>>,
      TError,
      { data: CreateProductBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { data: CreateProductBody },
  TContext
> => {
  return useMutation(getCreateProductMutationOptions(options), queryClient)
}
/**
 * Delete a product by ID
 * @summary Delete a product
 */
export type deleteProductResponse204 = {
  data: void
  status: 204
}

export type deleteProductResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type deleteProductResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type deleteProductResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type deleteProductResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type deleteProductResponseSuccess = deleteProductResponse204 & {
  headers: Headers
}
export type deleteProductResponseError = (
  | deleteProductResponse400
  | deleteProductResponse401
  | deleteProductResponse404
  | deleteProductResponse500
) & {
  headers: Headers
}

export type deleteProductResponse = deleteProductResponseSuccess | deleteProductResponseError

export const getDeleteProductUrl = (id: string) => {
  return `/catalog/products/${id}`
}

export const deleteProduct = async (
  id: string,
  options?: RequestInit
): Promise<deleteProductResponse> => {
  return customInstance<deleteProductResponse>(getDeleteProductUrl(id), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteProductMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProduct>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteProduct']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProduct>>, { id: string }> = (
    props
  ) => {
    const { id } = props ?? {}

    return deleteProduct(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteProductMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProduct>>>

export type DeleteProductMutationError = DtoErrorResponse

/**
 * @summary Delete a product
 */
export const useDeleteProduct = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProduct>>,
      TError,
      { id: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { id: string },
  TContext
> => {
  return useMutation(getDeleteProductMutationOptions(options), queryClient)
}
/**
 * Retrieve a product by its ID
 * @summary Get product by ID
 */
export type getProductByIdResponse200 = {
  data: HandlerAPIResponseHandlerProductResponse
  status: 200
}

export type getProductByIdResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getProductByIdResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getProductByIdResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getProductByIdResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getProductByIdResponseSuccess = getProductByIdResponse200 & {
  headers: Headers
}
export type getProductByIdResponseError = (
  | getProductByIdResponse400
  | getProductByIdResponse401
  | getProductByIdResponse404
  | getProductByIdResponse500
) & {
  headers: Headers
}

export type getProductByIdResponse = getProductByIdResponseSuccess | getProductByIdResponseError

export const getGetProductByIdUrl = (id: string) => {
  return `/catalog/products/${id}`
}

export const getProductById = async (
  id: string,
  options?: RequestInit
): Promise<getProductByIdResponse> => {
  return customInstance<getProductByIdResponse>(getGetProductByIdUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetProductByIdQueryKey = (id: string) => {
  return [`/catalog/products/${id}`] as const
}

export const getGetProductByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProductByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductById>>> = ({ signal }) =>
    getProductById(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProductById>>>
export type GetProductByIdQueryError = DtoErrorResponse

export function useGetProductById<
  TData = Awaited<ReturnType<typeof getProductById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductById>>,
          TError,
          Awaited<ReturnType<typeof getProductById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProductById<
  TData = Awaited<ReturnType<typeof getProductById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductById>>,
          TError,
          Awaited<ReturnType<typeof getProductById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProductById<
  TData = Awaited<ReturnType<typeof getProductById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get product by ID
 */

export function useGetProductById<
  TData = Awaited<ReturnType<typeof getProductById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProductByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Update an existing product's details
 * @summary Update a product
 */
export type updateProductResponse200 = {
  data: HandlerAPIResponseHandlerProductResponse
  status: 200
}

export type updateProductResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type updateProductResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type updateProductResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type updateProductResponse409 = {
  data: DtoErrorResponse
  status: 409
}

export type updateProductResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type updateProductResponseSuccess = updateProductResponse200 & {
  headers: Headers
}
export type updateProductResponseError = (
  | updateProductResponse400
  | updateProductResponse401
  | updateProductResponse404
  | updateProductResponse409
  | updateProductResponse500
) & {
  headers: Headers
}

export type updateProductResponse = updateProductResponseSuccess | updateProductResponseError

export const getUpdateProductUrl = (id: string) => {
  return `/catalog/products/${id}`
}

export const updateProduct = async (
  id: string,
  updateProductBody: UpdateProductBody,
  options?: RequestInit
): Promise<updateProductResponse> => {
  return customInstance<updateProductResponse>(getUpdateProductUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateProductBody),
  })
}

export const getUpdateProductMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProduct>>,
    TError,
    { id: string; data: UpdateProductBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { id: string; data: UpdateProductBody },
  TContext
> => {
  const mutationKey = ['updateProduct']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProduct>>,
    { id: string; data: UpdateProductBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateProduct(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateProductMutationResult = NonNullable<Awaited<ReturnType<typeof updateProduct>>>
export type UpdateProductMutationBody = UpdateProductBody
export type UpdateProductMutationError = DtoErrorResponse

/**
 * @summary Update a product
 */
export const useUpdateProduct = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProduct>>,
      TError,
      { id: string; data: UpdateProductBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { id: string; data: UpdateProductBody },
  TContext
> => {
  return useMutation(getUpdateProductMutationOptions(options), queryClient)
}
/**
 * Activate an inactive product
 * @summary Activate a product
 */
export type activateProductResponse200 = {
  data: HandlerAPIResponseHandlerProductResponse
  status: 200
}

export type activateProductResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type activateProductResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type activateProductResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type activateProductResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type activateProductResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type activateProductResponseSuccess = activateProductResponse200 & {
  headers: Headers
}
export type activateProductResponseError = (
  | activateProductResponse400
  | activateProductResponse401
  | activateProductResponse404
  | activateProductResponse422
  | activateProductResponse500
) & {
  headers: Headers
}

export type activateProductResponse = activateProductResponseSuccess | activateProductResponseError

export const getActivateProductUrl = (id: string) => {
  return `/catalog/products/${id}/activate`
}

export const activateProduct = async (
  id: string,
  activateProductBody: ActivateProductBody,
  options?: RequestInit
): Promise<activateProductResponse> => {
  return customInstance<activateProductResponse>(getActivateProductUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(activateProductBody),
  })
}

export const getActivateProductMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof activateProduct>>,
    TError,
    { id: string; data: ActivateProductBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof activateProduct>>,
  TError,
  { id: string; data: ActivateProductBody },
  TContext
> => {
  const mutationKey = ['activateProduct']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof activateProduct>>,
    { id: string; data: ActivateProductBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return activateProduct(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ActivateProductMutationResult = NonNullable<Awaited<ReturnType<typeof activateProduct>>>
export type ActivateProductMutationBody = ActivateProductBody
export type ActivateProductMutationError = DtoErrorResponse

/**
 * @summary Activate a product
 */
export const useActivateProduct = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof activateProduct>>,
      TError,
      { id: string; data: ActivateProductBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof activateProduct>>,
  TError,
  { id: string; data: ActivateProductBody },
  TContext
> => {
  return useMutation(getActivateProductMutationOptions(options), queryClient)
}
/**
 * Update a product's code (SKU)
 * @summary Update product code
 */
export type updateProductCodeResponse200 = {
  data: HandlerAPIResponseHandlerProductResponse
  status: 200
}

export type updateProductCodeResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type updateProductCodeResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type updateProductCodeResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type updateProductCodeResponse409 = {
  data: DtoErrorResponse
  status: 409
}

export type updateProductCodeResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type updateProductCodeResponseSuccess = updateProductCodeResponse200 & {
  headers: Headers
}
export type updateProductCodeResponseError = (
  | updateProductCodeResponse400
  | updateProductCodeResponse401
  | updateProductCodeResponse404
  | updateProductCodeResponse409
  | updateProductCodeResponse500
) & {
  headers: Headers
}

export type updateProductCodeResponse =
  | updateProductCodeResponseSuccess
  | updateProductCodeResponseError

export const getUpdateProductCodeUrl = (id: string) => {
  return `/catalog/products/${id}/code`
}

export const updateProductCode = async (
  id: string,
  updateProductCodeBody: UpdateProductCodeBody,
  options?: RequestInit
): Promise<updateProductCodeResponse> => {
  return customInstance<updateProductCodeResponse>(getUpdateProductCodeUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateProductCodeBody),
  })
}

export const getUpdateProductCodeMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProductCode>>,
    TError,
    { id: string; data: UpdateProductCodeBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProductCode>>,
  TError,
  { id: string; data: UpdateProductCodeBody },
  TContext
> => {
  const mutationKey = ['updateProductCode']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProductCode>>,
    { id: string; data: UpdateProductCodeBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateProductCode(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateProductCodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProductCode>>
>
export type UpdateProductCodeMutationBody = UpdateProductCodeBody
export type UpdateProductCodeMutationError = DtoErrorResponse

/**
 * @summary Update product code
 */
export const useUpdateProductCode = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProductCode>>,
      TError,
      { id: string; data: UpdateProductCodeBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateProductCode>>,
  TError,
  { id: string; data: UpdateProductCodeBody },
  TContext
> => {
  return useMutation(getUpdateProductCodeMutationOptions(options), queryClient)
}
/**
 * Deactivate an active product
 * @summary Deactivate a product
 */
export type deactivateProductResponse200 = {
  data: HandlerAPIResponseHandlerProductResponse
  status: 200
}

export type deactivateProductResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type deactivateProductResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type deactivateProductResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type deactivateProductResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type deactivateProductResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type deactivateProductResponseSuccess = deactivateProductResponse200 & {
  headers: Headers
}
export type deactivateProductResponseError = (
  | deactivateProductResponse400
  | deactivateProductResponse401
  | deactivateProductResponse404
  | deactivateProductResponse422
  | deactivateProductResponse500
) & {
  headers: Headers
}

export type deactivateProductResponse =
  | deactivateProductResponseSuccess
  | deactivateProductResponseError

export const getDeactivateProductUrl = (id: string) => {
  return `/catalog/products/${id}/deactivate`
}

export const deactivateProduct = async (
  id: string,
  deactivateProductBody: DeactivateProductBody,
  options?: RequestInit
): Promise<deactivateProductResponse> => {
  return customInstance<deactivateProductResponse>(getDeactivateProductUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(deactivateProductBody),
  })
}

export const getDeactivateProductMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deactivateProduct>>,
    TError,
    { id: string; data: DeactivateProductBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deactivateProduct>>,
  TError,
  { id: string; data: DeactivateProductBody },
  TContext
> => {
  const mutationKey = ['deactivateProduct']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deactivateProduct>>,
    { id: string; data: DeactivateProductBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return deactivateProduct(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeactivateProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof deactivateProduct>>
>
export type DeactivateProductMutationBody = DeactivateProductBody
export type DeactivateProductMutationError = DtoErrorResponse

/**
 * @summary Deactivate a product
 */
export const useDeactivateProduct = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deactivateProduct>>,
      TError,
      { id: string; data: DeactivateProductBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deactivateProduct>>,
  TError,
  { id: string; data: DeactivateProductBody },
  TContext
> => {
  return useMutation(getDeactivateProductMutationOptions(options), queryClient)
}
/**
 * Discontinue a product (cannot be reactivated)
 * @summary Discontinue a product
 */
export type discontinueProductResponse200 = {
  data: HandlerAPIResponseHandlerProductResponse
  status: 200
}

export type discontinueProductResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type discontinueProductResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type discontinueProductResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type discontinueProductResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type discontinueProductResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type discontinueProductResponseSuccess = discontinueProductResponse200 & {
  headers: Headers
}
export type discontinueProductResponseError = (
  | discontinueProductResponse400
  | discontinueProductResponse401
  | discontinueProductResponse404
  | discontinueProductResponse422
  | discontinueProductResponse500
) & {
  headers: Headers
}

export type discontinueProductResponse =
  | discontinueProductResponseSuccess
  | discontinueProductResponseError

export const getDiscontinueProductUrl = (id: string) => {
  return `/catalog/products/${id}/discontinue`
}

export const discontinueProduct = async (
  id: string,
  discontinueProductBody: DiscontinueProductBody,
  options?: RequestInit
): Promise<discontinueProductResponse> => {
  return customInstance<discontinueProductResponse>(getDiscontinueProductUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(discontinueProductBody),
  })
}

export const getDiscontinueProductMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof discontinueProduct>>,
    TError,
    { id: string; data: DiscontinueProductBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof discontinueProduct>>,
  TError,
  { id: string; data: DiscontinueProductBody },
  TContext
> => {
  const mutationKey = ['discontinueProduct']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof discontinueProduct>>,
    { id: string; data: DiscontinueProductBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return discontinueProduct(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DiscontinueProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof discontinueProduct>>
>
export type DiscontinueProductMutationBody = DiscontinueProductBody
export type DiscontinueProductMutationError = DtoErrorResponse

/**
 * @summary Discontinue a product
 */
export const useDiscontinueProduct = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof discontinueProduct>>,
      TError,
      { id: string; data: DiscontinueProductBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof discontinueProduct>>,
  TError,
  { id: string; data: DiscontinueProductBody },
  TContext
> => {
  return useMutation(getDiscontinueProductMutationOptions(options), queryClient)
}
/**
 * Retrieve a product by its code
 * @summary Get product by code
 */
export type getProductByCodeResponse200 = {
  data: HandlerAPIResponseHandlerProductResponse
  status: 200
}

export type getProductByCodeResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getProductByCodeResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getProductByCodeResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getProductByCodeResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getProductByCodeResponseSuccess = getProductByCodeResponse200 & {
  headers: Headers
}
export type getProductByCodeResponseError = (
  | getProductByCodeResponse400
  | getProductByCodeResponse401
  | getProductByCodeResponse404
  | getProductByCodeResponse500
) & {
  headers: Headers
}

export type getProductByCodeResponse =
  | getProductByCodeResponseSuccess
  | getProductByCodeResponseError

export const getGetProductByCodeUrl = (code: string) => {
  return `/catalog/products/code/${code}`
}

export const getProductByCode = async (
  code: string,
  options?: RequestInit
): Promise<getProductByCodeResponse> => {
  return customInstance<getProductByCodeResponse>(getGetProductByCodeUrl(code), {
    ...options,
    method: 'GET',
  })
}

export const getGetProductByCodeQueryKey = (code: string) => {
  return [`/catalog/products/code/${code}`] as const
}

export const getGetProductByCodeQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductByCode>>,
  TError = DtoErrorResponse,
>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCode>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProductByCodeQueryKey(code)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductByCode>>> = ({ signal }) =>
    getProductByCode(code, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!code, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductByCode>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductByCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getProductByCode>>>
export type GetProductByCodeQueryError = DtoErrorResponse

export function useGetProductByCode<
  TData = Awaited<ReturnType<typeof getProductByCode>>,
  TError = DtoErrorResponse,
>(
  code: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCode>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductByCode>>,
          TError,
          Awaited<ReturnType<typeof getProductByCode>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProductByCode<
  TData = Awaited<ReturnType<typeof getProductByCode>>,
  TError = DtoErrorResponse,
>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCode>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductByCode>>,
          TError,
          Awaited<ReturnType<typeof getProductByCode>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProductByCode<
  TData = Awaited<ReturnType<typeof getProductByCode>>,
  TError = DtoErrorResponse,
>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCode>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get product by code
 */

export function useGetProductByCode<
  TData = Awaited<ReturnType<typeof getProductByCode>>,
  TError = DtoErrorResponse,
>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductByCode>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProductByCodeQueryOptions(code, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Get the count of products grouped by status
 * @summary Get product counts by status
 */
export type countProductByStatusResponse200 = {
  data: HandlerAPIResponseHandlerCountByStatusResponse
  status: 200
}

export type countProductByStatusResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type countProductByStatusResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type countProductByStatusResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type countProductByStatusResponseSuccess = countProductByStatusResponse200 & {
  headers: Headers
}
export type countProductByStatusResponseError = (
  | countProductByStatusResponse400
  | countProductByStatusResponse401
  | countProductByStatusResponse500
) & {
  headers: Headers
}

export type countProductByStatusResponse =
  | countProductByStatusResponseSuccess
  | countProductByStatusResponseError

export const getCountProductByStatusUrl = () => {
  return `/catalog/products/stats/count`
}

export const countProductByStatus = async (
  options?: RequestInit
): Promise<countProductByStatusResponse> => {
  return customInstance<countProductByStatusResponse>(getCountProductByStatusUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getCountProductByStatusQueryKey = () => {
  return [`/catalog/products/stats/count`] as const
}

export const getCountProductByStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof countProductByStatus>>,
  TError = DtoErrorResponse,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof countProductByStatus>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getCountProductByStatusQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countProductByStatus>>> = ({ signal }) =>
    countProductByStatus({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof countProductByStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CountProductByStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof countProductByStatus>>
>
export type CountProductByStatusQueryError = DtoErrorResponse

export function useCountProductByStatus<
  TData = Awaited<ReturnType<typeof countProductByStatus>>,
  TError = DtoErrorResponse,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof countProductByStatus>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof countProductByStatus>>,
          TError,
          Awaited<ReturnType<typeof countProductByStatus>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCountProductByStatus<
  TData = Awaited<ReturnType<typeof countProductByStatus>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof countProductByStatus>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof countProductByStatus>>,
          TError,
          Awaited<ReturnType<typeof countProductByStatus>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCountProductByStatus<
  TData = Awaited<ReturnType<typeof countProductByStatus>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof countProductByStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get product counts by status
 */

export function useCountProductByStatus<
  TData = Awaited<ReturnType<typeof countProductByStatus>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof countProductByStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCountProductByStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

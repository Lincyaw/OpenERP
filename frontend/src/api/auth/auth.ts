/**
 * // This file is auto-generated by orval
 * // Do not edit manually
 *
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  ChangePasswordAuthBody,
  DtoErrorResponse,
  ForceLogoutAuthBody,
  HandlerAPIResponseHandlerCurrentUserResponse,
  HandlerAPIResponseHandlerForceLogoutResponse,
  HandlerAPIResponseHandlerLoginResponse,
  HandlerAPIResponseHandlerLogoutResponse,
  HandlerAPIResponseHandlerRefreshTokenResponse,
  HandlerSuccessResponse,
  LoginAuthBody,
  LogoutAuthBody,
  RefreshTokenAuthBody,
} from '.././models'

import { customInstance } from '../../services/axios-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Invalidate all sessions for a specific user. Requires user:force_logout permission.
 * @summary Force logout user (Admin)
 */
export type forceLogoutAuthResponse200 = {
  data: HandlerAPIResponseHandlerForceLogoutResponse
  status: 200
}

export type forceLogoutAuthResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type forceLogoutAuthResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type forceLogoutAuthResponse403 = {
  data: DtoErrorResponse
  status: 403
}

export type forceLogoutAuthResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type forceLogoutAuthResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type forceLogoutAuthResponseSuccess = forceLogoutAuthResponse200 & {
  headers: Headers
}
export type forceLogoutAuthResponseError = (
  | forceLogoutAuthResponse400
  | forceLogoutAuthResponse401
  | forceLogoutAuthResponse403
  | forceLogoutAuthResponse404
  | forceLogoutAuthResponse500
) & {
  headers: Headers
}

export type forceLogoutAuthResponse = forceLogoutAuthResponseSuccess | forceLogoutAuthResponseError

export const getForceLogoutAuthUrl = () => {
  return `/auth/force-logout`
}

export const forceLogoutAuth = async (
  forceLogoutAuthBody: ForceLogoutAuthBody,
  options?: RequestInit
): Promise<forceLogoutAuthResponse> => {
  return customInstance<forceLogoutAuthResponse>(getForceLogoutAuthUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(forceLogoutAuthBody),
  })
}

export const getForceLogoutAuthMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof forceLogoutAuth>>,
    TError,
    { data: ForceLogoutAuthBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof forceLogoutAuth>>,
  TError,
  { data: ForceLogoutAuthBody },
  TContext
> => {
  const mutationKey = ['forceLogoutAuth']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof forceLogoutAuth>>,
    { data: ForceLogoutAuthBody }
  > = (props) => {
    const { data } = props ?? {}

    return forceLogoutAuth(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ForceLogoutAuthMutationResult = NonNullable<Awaited<ReturnType<typeof forceLogoutAuth>>>
export type ForceLogoutAuthMutationBody = ForceLogoutAuthBody
export type ForceLogoutAuthMutationError = DtoErrorResponse

/**
 * @summary Force logout user (Admin)
 */
export const useForceLogoutAuth = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof forceLogoutAuth>>,
      TError,
      { data: ForceLogoutAuthBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof forceLogoutAuth>>,
  TError,
  { data: ForceLogoutAuthBody },
  TContext
> => {
  return useMutation(getForceLogoutAuthMutationOptions(options), queryClient)
}
/**
 * Authenticate user with username and password. Returns access token in response body and sets refresh token as httpOnly cookie.
 * @summary User login
 */
export type loginAuthResponse200 = {
  data: HandlerAPIResponseHandlerLoginResponse
  status: 200
}

export type loginAuthResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type loginAuthResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type loginAuthResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type loginAuthResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type loginAuthResponseSuccess = loginAuthResponse200 & {
  headers: Headers
}
export type loginAuthResponseError = (
  | loginAuthResponse400
  | loginAuthResponse401
  | loginAuthResponse422
  | loginAuthResponse500
) & {
  headers: Headers
}

export type loginAuthResponse = loginAuthResponseSuccess | loginAuthResponseError

export const getLoginAuthUrl = () => {
  return `/auth/login`
}

export const loginAuth = async (
  loginAuthBody: LoginAuthBody,
  options?: RequestInit
): Promise<loginAuthResponse> => {
  return customInstance<loginAuthResponse>(getLoginAuthUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(loginAuthBody),
  })
}

export const getLoginAuthMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof loginAuth>>,
    TError,
    { data: LoginAuthBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof loginAuth>>,
  TError,
  { data: LoginAuthBody },
  TContext
> => {
  const mutationKey = ['loginAuth']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof loginAuth>>,
    { data: LoginAuthBody }
  > = (props) => {
    const { data } = props ?? {}

    return loginAuth(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type LoginAuthMutationResult = NonNullable<Awaited<ReturnType<typeof loginAuth>>>
export type LoginAuthMutationBody = LoginAuthBody
export type LoginAuthMutationError = DtoErrorResponse

/**
 * @summary User login
 */
export const useLoginAuth = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof loginAuth>>,
      TError,
      { data: LoginAuthBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof loginAuth>>,
  TError,
  { data: LoginAuthBody },
  TContext
> => {
  return useMutation(getLoginAuthMutationOptions(options), queryClient)
}
/**
 * Logout and invalidate the current session. Clears refresh token cookie.
 * @summary User logout
 */
export type logoutAuthResponse200 = {
  data: HandlerAPIResponseHandlerLogoutResponse
  status: 200
}

export type logoutAuthResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type logoutAuthResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type logoutAuthResponseSuccess = logoutAuthResponse200 & {
  headers: Headers
}
export type logoutAuthResponseError = (logoutAuthResponse401 | logoutAuthResponse500) & {
  headers: Headers
}

export type logoutAuthResponse = logoutAuthResponseSuccess | logoutAuthResponseError

export const getLogoutAuthUrl = () => {
  return `/auth/logout`
}

export const logoutAuth = async (
  logoutAuthBody: LogoutAuthBody,
  options?: RequestInit
): Promise<logoutAuthResponse> => {
  return customInstance<logoutAuthResponse>(getLogoutAuthUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(logoutAuthBody),
  })
}

export const getLogoutAuthMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logoutAuth>>,
    TError,
    { data: LogoutAuthBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof logoutAuth>>,
  TError,
  { data: LogoutAuthBody },
  TContext
> => {
  const mutationKey = ['logoutAuth']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logoutAuth>>,
    { data: LogoutAuthBody }
  > = (props) => {
    const { data } = props ?? {}

    return logoutAuth(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type LogoutAuthMutationResult = NonNullable<Awaited<ReturnType<typeof logoutAuth>>>
export type LogoutAuthMutationBody = LogoutAuthBody
export type LogoutAuthMutationError = DtoErrorResponse

/**
 * @summary User logout
 */
export const useLogoutAuth = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof logoutAuth>>,
      TError,
      { data: LogoutAuthBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof logoutAuth>>,
  TError,
  { data: LogoutAuthBody },
  TContext
> => {
  return useMutation(getLogoutAuthMutationOptions(options), queryClient)
}
/**
 * Get the currently authenticated user's information
 * @summary Get current user
 */
export type getAuthCurrentUserResponse200 = {
  data: HandlerAPIResponseHandlerCurrentUserResponse
  status: 200
}

export type getAuthCurrentUserResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getAuthCurrentUserResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getAuthCurrentUserResponseSuccess = getAuthCurrentUserResponse200 & {
  headers: Headers
}
export type getAuthCurrentUserResponseError = (
  | getAuthCurrentUserResponse401
  | getAuthCurrentUserResponse500
) & {
  headers: Headers
}

export type getAuthCurrentUserResponse =
  | getAuthCurrentUserResponseSuccess
  | getAuthCurrentUserResponseError

export const getGetAuthCurrentUserUrl = () => {
  return `/auth/me`
}

export const getAuthCurrentUser = async (
  options?: RequestInit
): Promise<getAuthCurrentUserResponse> => {
  return customInstance<getAuthCurrentUserResponse>(getGetAuthCurrentUserUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getGetAuthCurrentUserQueryKey = () => {
  return [`/auth/me`] as const
}

export const getGetAuthCurrentUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthCurrentUser>>,
  TError = DtoErrorResponse,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthCurrentUser>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAuthCurrentUserQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthCurrentUser>>> = ({ signal }) =>
    getAuthCurrentUser({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthCurrentUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuthCurrentUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuthCurrentUser>>
>
export type GetAuthCurrentUserQueryError = DtoErrorResponse

export function useGetAuthCurrentUser<
  TData = Awaited<ReturnType<typeof getAuthCurrentUser>>,
  TError = DtoErrorResponse,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthCurrentUser>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getAuthCurrentUser>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthCurrentUser<
  TData = Awaited<ReturnType<typeof getAuthCurrentUser>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthCurrentUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getAuthCurrentUser>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthCurrentUser<
  TData = Awaited<ReturnType<typeof getAuthCurrentUser>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthCurrentUser>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user
 */

export function useGetAuthCurrentUser<
  TData = Awaited<ReturnType<typeof getAuthCurrentUser>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthCurrentUser>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Change the current user's password
 * @summary Change password
 */
export type changePasswordAuthResponse200 = {
  data: HandlerSuccessResponse
  status: 200
}

export type changePasswordAuthResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type changePasswordAuthResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type changePasswordAuthResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type changePasswordAuthResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type changePasswordAuthResponseSuccess = changePasswordAuthResponse200 & {
  headers: Headers
}
export type changePasswordAuthResponseError = (
  | changePasswordAuthResponse400
  | changePasswordAuthResponse401
  | changePasswordAuthResponse422
  | changePasswordAuthResponse500
) & {
  headers: Headers
}

export type changePasswordAuthResponse =
  | changePasswordAuthResponseSuccess
  | changePasswordAuthResponseError

export const getChangePasswordAuthUrl = () => {
  return `/auth/password`
}

export const changePasswordAuth = async (
  changePasswordAuthBody: ChangePasswordAuthBody,
  options?: RequestInit
): Promise<changePasswordAuthResponse> => {
  return customInstance<changePasswordAuthResponse>(getChangePasswordAuthUrl(), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(changePasswordAuthBody),
  })
}

export const getChangePasswordAuthMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof changePasswordAuth>>,
    TError,
    { data: ChangePasswordAuthBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof changePasswordAuth>>,
  TError,
  { data: ChangePasswordAuthBody },
  TContext
> => {
  const mutationKey = ['changePasswordAuth']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePasswordAuth>>,
    { data: ChangePasswordAuthBody }
  > = (props) => {
    const { data } = props ?? {}

    return changePasswordAuth(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ChangePasswordAuthMutationResult = NonNullable<
  Awaited<ReturnType<typeof changePasswordAuth>>
>
export type ChangePasswordAuthMutationBody = ChangePasswordAuthBody
export type ChangePasswordAuthMutationError = DtoErrorResponse

/**
 * @summary Change password
 */
export const useChangePasswordAuth = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof changePasswordAuth>>,
      TError,
      { data: ChangePasswordAuthBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof changePasswordAuth>>,
  TError,
  { data: ChangePasswordAuthBody },
  TContext
> => {
  return useMutation(getChangePasswordAuthMutationOptions(options), queryClient)
}
/**
 * Get new access token using refresh token from httpOnly cookie. Falls back to request body for backward compatibility.
 * @summary Refresh access token
 */
export type refreshTokenAuthResponse200 = {
  data: HandlerAPIResponseHandlerRefreshTokenResponse
  status: 200
}

export type refreshTokenAuthResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type refreshTokenAuthResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type refreshTokenAuthResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type refreshTokenAuthResponseSuccess = refreshTokenAuthResponse200 & {
  headers: Headers
}
export type refreshTokenAuthResponseError = (
  | refreshTokenAuthResponse400
  | refreshTokenAuthResponse401
  | refreshTokenAuthResponse500
) & {
  headers: Headers
}

export type refreshTokenAuthResponse =
  | refreshTokenAuthResponseSuccess
  | refreshTokenAuthResponseError

export const getRefreshTokenAuthUrl = () => {
  return `/auth/refresh`
}

export const refreshTokenAuth = async (
  refreshTokenAuthBody: RefreshTokenAuthBody,
  options?: RequestInit
): Promise<refreshTokenAuthResponse> => {
  return customInstance<refreshTokenAuthResponse>(getRefreshTokenAuthUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(refreshTokenAuthBody),
  })
}

export const getRefreshTokenAuthMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshTokenAuth>>,
    TError,
    { data: RefreshTokenAuthBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshTokenAuth>>,
  TError,
  { data: RefreshTokenAuthBody },
  TContext
> => {
  const mutationKey = ['refreshTokenAuth']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshTokenAuth>>,
    { data: RefreshTokenAuthBody }
  > = (props) => {
    const { data } = props ?? {}

    return refreshTokenAuth(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RefreshTokenAuthMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshTokenAuth>>
>
export type RefreshTokenAuthMutationBody = RefreshTokenAuthBody
export type RefreshTokenAuthMutationError = DtoErrorResponse

/**
 * @summary Refresh access token
 */
export const useRefreshTokenAuth = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refreshTokenAuth>>,
      TError,
      { data: RefreshTokenAuthBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof refreshTokenAuth>>,
  TError,
  { data: RefreshTokenAuthBody },
  TContext
> => {
  return useMutation(getRefreshTokenAuthMutationOptions(options), queryClient)
}

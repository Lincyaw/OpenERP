/**
 * // This file is auto-generated by orval
 * // Do not edit manually
 *
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  AdjustBalanceBody,
  DtoErrorResponse,
  HandlerAPIResponseArrayHandlerBalanceTransactionResponse,
  HandlerAPIResponseHandlerBalanceData,
  HandlerAPIResponseHandlerBalanceSummaryResponse,
  HandlerAPIResponseHandlerBalanceTransactionResponse,
  ListBalanceTransactionsParams,
  RechargeBalanceBody,
} from '.././models'

import { customInstance } from '../../services/axios-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Get a specific balance transaction by its ID
 * @summary Get balance transaction by ID
 */
export type getBalanceTransactionResponse200 = {
  data: HandlerAPIResponseHandlerBalanceTransactionResponse
  status: 200
}

export type getBalanceTransactionResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getBalanceTransactionResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getBalanceTransactionResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getBalanceTransactionResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getBalanceTransactionResponseSuccess = getBalanceTransactionResponse200 & {
  headers: Headers
}
export type getBalanceTransactionResponseError = (
  | getBalanceTransactionResponse400
  | getBalanceTransactionResponse401
  | getBalanceTransactionResponse404
  | getBalanceTransactionResponse500
) & {
  headers: Headers
}

export type getBalanceTransactionResponse =
  | getBalanceTransactionResponseSuccess
  | getBalanceTransactionResponseError

export const getGetBalanceTransactionUrl = (id: string) => {
  return `/partner/balance/transactions/${id}`
}

export const getBalanceTransaction = async (
  id: string,
  options?: RequestInit
): Promise<getBalanceTransactionResponse> => {
  return customInstance<getBalanceTransactionResponse>(getGetBalanceTransactionUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetBalanceTransactionQueryKey = (id: string) => {
  return [`/partner/balance/transactions/${id}`] as const
}

export const getGetBalanceTransactionQueryOptions = <
  TData = Awaited<ReturnType<typeof getBalanceTransaction>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBalanceTransaction>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetBalanceTransactionQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBalanceTransaction>>> = ({ signal }) =>
    getBalanceTransaction(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBalanceTransaction>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBalanceTransactionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBalanceTransaction>>
>
export type GetBalanceTransactionQueryError = DtoErrorResponse

export function useGetBalanceTransaction<
  TData = Awaited<ReturnType<typeof getBalanceTransaction>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBalanceTransaction>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBalanceTransaction>>,
          TError,
          Awaited<ReturnType<typeof getBalanceTransaction>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBalanceTransaction<
  TData = Awaited<ReturnType<typeof getBalanceTransaction>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBalanceTransaction>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBalanceTransaction>>,
          TError,
          Awaited<ReturnType<typeof getBalanceTransaction>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBalanceTransaction<
  TData = Awaited<ReturnType<typeof getBalanceTransaction>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBalanceTransaction>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get balance transaction by ID
 */

export function useGetBalanceTransaction<
  TData = Awaited<ReturnType<typeof getBalanceTransaction>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBalanceTransaction>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBalanceTransactionQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Get the current balance for a customer
 * @summary Get customer balance
 */
export type getBalanceBalanceResponse200 = {
  data: HandlerAPIResponseHandlerBalanceData
  status: 200
}

export type getBalanceBalanceResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getBalanceBalanceResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getBalanceBalanceResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getBalanceBalanceResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getBalanceBalanceResponseSuccess = getBalanceBalanceResponse200 & {
  headers: Headers
}
export type getBalanceBalanceResponseError = (
  | getBalanceBalanceResponse400
  | getBalanceBalanceResponse401
  | getBalanceBalanceResponse404
  | getBalanceBalanceResponse500
) & {
  headers: Headers
}

export type getBalanceBalanceResponse =
  | getBalanceBalanceResponseSuccess
  | getBalanceBalanceResponseError

export const getGetBalanceBalanceUrl = (id: string) => {
  return `/partner/customers/${id}/balance`
}

export const getBalanceBalance = async (
  id: string,
  options?: RequestInit
): Promise<getBalanceBalanceResponse> => {
  return customInstance<getBalanceBalanceResponse>(getGetBalanceBalanceUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetBalanceBalanceQueryKey = (id: string) => {
  return [`/partner/customers/${id}/balance`] as const
}

export const getGetBalanceBalanceQueryOptions = <
  TData = Awaited<ReturnType<typeof getBalanceBalance>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBalanceBalance>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetBalanceBalanceQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBalanceBalance>>> = ({ signal }) =>
    getBalanceBalance(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBalanceBalance>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBalanceBalanceQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBalanceBalance>>
>
export type GetBalanceBalanceQueryError = DtoErrorResponse

export function useGetBalanceBalance<
  TData = Awaited<ReturnType<typeof getBalanceBalance>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBalanceBalance>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBalanceBalance>>,
          TError,
          Awaited<ReturnType<typeof getBalanceBalance>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBalanceBalance<
  TData = Awaited<ReturnType<typeof getBalanceBalance>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBalanceBalance>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBalanceBalance>>,
          TError,
          Awaited<ReturnType<typeof getBalanceBalance>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBalanceBalance<
  TData = Awaited<ReturnType<typeof getBalanceBalance>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBalanceBalance>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get customer balance
 */

export function useGetBalanceBalance<
  TData = Awaited<ReturnType<typeof getBalanceBalance>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBalanceBalance>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBalanceBalanceQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Manually adjust a customer's balance (increase or decrease)
 * @summary Adjust customer balance
 */
export type adjustBalanceResponse201 = {
  data: HandlerAPIResponseHandlerBalanceTransactionResponse
  status: 201
}

export type adjustBalanceResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type adjustBalanceResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type adjustBalanceResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type adjustBalanceResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type adjustBalanceResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type adjustBalanceResponseSuccess = adjustBalanceResponse201 & {
  headers: Headers
}
export type adjustBalanceResponseError = (
  | adjustBalanceResponse400
  | adjustBalanceResponse401
  | adjustBalanceResponse404
  | adjustBalanceResponse422
  | adjustBalanceResponse500
) & {
  headers: Headers
}

export type adjustBalanceResponse = adjustBalanceResponseSuccess | adjustBalanceResponseError

export const getAdjustBalanceUrl = (id: string) => {
  return `/partner/customers/${id}/balance/adjust`
}

export const adjustBalance = async (
  id: string,
  adjustBalanceBody: AdjustBalanceBody,
  options?: RequestInit
): Promise<adjustBalanceResponse> => {
  return customInstance<adjustBalanceResponse>(getAdjustBalanceUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(adjustBalanceBody),
  })
}

export const getAdjustBalanceMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adjustBalance>>,
    TError,
    { id: string; data: AdjustBalanceBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof adjustBalance>>,
  TError,
  { id: string; data: AdjustBalanceBody },
  TContext
> => {
  const mutationKey = ['adjustBalance']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adjustBalance>>,
    { id: string; data: AdjustBalanceBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return adjustBalance(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AdjustBalanceMutationResult = NonNullable<Awaited<ReturnType<typeof adjustBalance>>>
export type AdjustBalanceMutationBody = AdjustBalanceBody
export type AdjustBalanceMutationError = DtoErrorResponse

/**
 * @summary Adjust customer balance
 */
export const useAdjustBalance = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof adjustBalance>>,
      TError,
      { id: string; data: AdjustBalanceBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof adjustBalance>>,
  TError,
  { id: string; data: AdjustBalanceBody },
  TContext
> => {
  return useMutation(getAdjustBalanceMutationOptions(options), queryClient)
}
/**
 * Add funds to a customer's prepaid balance
 * @summary Recharge customer balance
 */
export type rechargeBalanceResponse201 = {
  data: HandlerAPIResponseHandlerBalanceTransactionResponse
  status: 201
}

export type rechargeBalanceResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type rechargeBalanceResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type rechargeBalanceResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type rechargeBalanceResponse422 = {
  data: DtoErrorResponse
  status: 422
}

export type rechargeBalanceResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type rechargeBalanceResponseSuccess = rechargeBalanceResponse201 & {
  headers: Headers
}
export type rechargeBalanceResponseError = (
  | rechargeBalanceResponse400
  | rechargeBalanceResponse401
  | rechargeBalanceResponse404
  | rechargeBalanceResponse422
  | rechargeBalanceResponse500
) & {
  headers: Headers
}

export type rechargeBalanceResponse = rechargeBalanceResponseSuccess | rechargeBalanceResponseError

export const getRechargeBalanceUrl = (id: string) => {
  return `/partner/customers/${id}/balance/recharge`
}

export const rechargeBalance = async (
  id: string,
  rechargeBalanceBody: RechargeBalanceBody,
  options?: RequestInit
): Promise<rechargeBalanceResponse> => {
  return customInstance<rechargeBalanceResponse>(getRechargeBalanceUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(rechargeBalanceBody),
  })
}

export const getRechargeBalanceMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rechargeBalance>>,
    TError,
    { id: string; data: RechargeBalanceBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof rechargeBalance>>,
  TError,
  { id: string; data: RechargeBalanceBody },
  TContext
> => {
  const mutationKey = ['rechargeBalance']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rechargeBalance>>,
    { id: string; data: RechargeBalanceBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return rechargeBalance(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RechargeBalanceMutationResult = NonNullable<Awaited<ReturnType<typeof rechargeBalance>>>
export type RechargeBalanceMutationBody = RechargeBalanceBody
export type RechargeBalanceMutationError = DtoErrorResponse

/**
 * @summary Recharge customer balance
 */
export const useRechargeBalance = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rechargeBalance>>,
      TError,
      { id: string; data: RechargeBalanceBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof rechargeBalance>>,
  TError,
  { id: string; data: RechargeBalanceBody },
  TContext
> => {
  return useMutation(getRechargeBalanceMutationOptions(options), queryClient)
}
/**
 * Get balance summary including total recharge, consume, and refund
 * @summary Get customer balance summary
 */
export type getBalanceBalanceSummaryResponse200 = {
  data: HandlerAPIResponseHandlerBalanceSummaryResponse
  status: 200
}

export type getBalanceBalanceSummaryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getBalanceBalanceSummaryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getBalanceBalanceSummaryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getBalanceBalanceSummaryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getBalanceBalanceSummaryResponseSuccess = getBalanceBalanceSummaryResponse200 & {
  headers: Headers
}
export type getBalanceBalanceSummaryResponseError = (
  | getBalanceBalanceSummaryResponse400
  | getBalanceBalanceSummaryResponse401
  | getBalanceBalanceSummaryResponse404
  | getBalanceBalanceSummaryResponse500
) & {
  headers: Headers
}

export type getBalanceBalanceSummaryResponse =
  | getBalanceBalanceSummaryResponseSuccess
  | getBalanceBalanceSummaryResponseError

export const getGetBalanceBalanceSummaryUrl = (id: string) => {
  return `/partner/customers/${id}/balance/summary`
}

export const getBalanceBalanceSummary = async (
  id: string,
  options?: RequestInit
): Promise<getBalanceBalanceSummaryResponse> => {
  return customInstance<getBalanceBalanceSummaryResponse>(getGetBalanceBalanceSummaryUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetBalanceBalanceSummaryQueryKey = (id: string) => {
  return [`/partner/customers/${id}/balance/summary`] as const
}

export const getGetBalanceBalanceSummaryQueryOptions = <
  TData = Awaited<ReturnType<typeof getBalanceBalanceSummary>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBalanceBalanceSummary>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetBalanceBalanceSummaryQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBalanceBalanceSummary>>> = ({
    signal,
  }) => getBalanceBalanceSummary(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBalanceBalanceSummary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBalanceBalanceSummaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBalanceBalanceSummary>>
>
export type GetBalanceBalanceSummaryQueryError = DtoErrorResponse

export function useGetBalanceBalanceSummary<
  TData = Awaited<ReturnType<typeof getBalanceBalanceSummary>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBalanceBalanceSummary>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBalanceBalanceSummary>>,
          TError,
          Awaited<ReturnType<typeof getBalanceBalanceSummary>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBalanceBalanceSummary<
  TData = Awaited<ReturnType<typeof getBalanceBalanceSummary>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBalanceBalanceSummary>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBalanceBalanceSummary>>,
          TError,
          Awaited<ReturnType<typeof getBalanceBalanceSummary>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBalanceBalanceSummary<
  TData = Awaited<ReturnType<typeof getBalanceBalanceSummary>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBalanceBalanceSummary>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get customer balance summary
 */

export function useGetBalanceBalanceSummary<
  TData = Awaited<ReturnType<typeof getBalanceBalanceSummary>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBalanceBalanceSummary>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBalanceBalanceSummaryQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * List balance transactions for a customer with optional filtering
 * @summary List balance transactions
 */
export type listBalanceTransactionsResponse200 = {
  data: HandlerAPIResponseArrayHandlerBalanceTransactionResponse
  status: 200
}

export type listBalanceTransactionsResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listBalanceTransactionsResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listBalanceTransactionsResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type listBalanceTransactionsResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listBalanceTransactionsResponseSuccess = listBalanceTransactionsResponse200 & {
  headers: Headers
}
export type listBalanceTransactionsResponseError = (
  | listBalanceTransactionsResponse400
  | listBalanceTransactionsResponse401
  | listBalanceTransactionsResponse404
  | listBalanceTransactionsResponse500
) & {
  headers: Headers
}

export type listBalanceTransactionsResponse =
  | listBalanceTransactionsResponseSuccess
  | listBalanceTransactionsResponseError

export const getListBalanceTransactionsUrl = (
  id: string,
  params?: ListBalanceTransactionsParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/partner/customers/${id}/balance/transactions?${stringifiedParams}`
    : `/partner/customers/${id}/balance/transactions`
}

export const listBalanceTransactions = async (
  id: string,
  params?: ListBalanceTransactionsParams,
  options?: RequestInit
): Promise<listBalanceTransactionsResponse> => {
  return customInstance<listBalanceTransactionsResponse>(
    getListBalanceTransactionsUrl(id, params),
    {
      ...options,
      method: 'GET',
    }
  )
}

export const getListBalanceTransactionsQueryKey = (
  id: string,
  params?: ListBalanceTransactionsParams
) => {
  return [`/partner/customers/${id}/balance/transactions`, ...(params ? [params] : [])] as const
}

export const getListBalanceTransactionsQueryOptions = <
  TData = Awaited<ReturnType<typeof listBalanceTransactions>>,
  TError = DtoErrorResponse,
>(
  id: string,
  params?: ListBalanceTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBalanceTransactions>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListBalanceTransactionsQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listBalanceTransactions>>> = ({
    signal,
  }) => listBalanceTransactions(id, params, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listBalanceTransactions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListBalanceTransactionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listBalanceTransactions>>
>
export type ListBalanceTransactionsQueryError = DtoErrorResponse

export function useListBalanceTransactions<
  TData = Awaited<ReturnType<typeof listBalanceTransactions>>,
  TError = DtoErrorResponse,
>(
  id: string,
  params: undefined | ListBalanceTransactionsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBalanceTransactions>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBalanceTransactions>>,
          TError,
          Awaited<ReturnType<typeof listBalanceTransactions>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBalanceTransactions<
  TData = Awaited<ReturnType<typeof listBalanceTransactions>>,
  TError = DtoErrorResponse,
>(
  id: string,
  params?: ListBalanceTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBalanceTransactions>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBalanceTransactions>>,
          TError,
          Awaited<ReturnType<typeof listBalanceTransactions>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBalanceTransactions<
  TData = Awaited<ReturnType<typeof listBalanceTransactions>>,
  TError = DtoErrorResponse,
>(
  id: string,
  params?: ListBalanceTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBalanceTransactions>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List balance transactions
 */

export function useListBalanceTransactions<
  TData = Awaited<ReturnType<typeof listBalanceTransactions>>,
  TError = DtoErrorResponse,
>(
  id: string,
  params?: ListBalanceTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listBalanceTransactions>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListBalanceTransactionsQueryOptions(id, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

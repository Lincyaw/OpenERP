/**
 * // This file is auto-generated by orval
 * // Do not edit manually
 *
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  ActivateCategoryBody,
  CreateCategoryBody,
  DeactivateCategoryBody,
  DtoErrorResponse,
  HandlerAPIResponseArrayHandlerCategoryListResponse,
  HandlerAPIResponseArrayHandlerCategoryTreeNode,
  HandlerAPIResponseHandlerCategoryResponse,
  ListCategoriesParams,
  MoveCategoryBody,
  UpdateCategoryBody,
} from '.././models'

import { customInstance } from '../../services/axios-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Retrieve a paginated list of categories
 * @summary List categories
 */
export type listCategoriesResponse200 = {
  data: HandlerAPIResponseArrayHandlerCategoryListResponse
  status: 200
}

export type listCategoriesResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type listCategoriesResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type listCategoriesResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type listCategoriesResponseSuccess = listCategoriesResponse200 & {
  headers: Headers
}
export type listCategoriesResponseError = (
  | listCategoriesResponse400
  | listCategoriesResponse401
  | listCategoriesResponse500
) & {
  headers: Headers
}

export type listCategoriesResponse = listCategoriesResponseSuccess | listCategoriesResponseError

export const getListCategoriesUrl = (params?: ListCategoriesParams) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/catalog/categories?${stringifiedParams}`
    : `/catalog/categories`
}

export const listCategories = async (
  params?: ListCategoriesParams,
  options?: RequestInit
): Promise<listCategoriesResponse> => {
  return customInstance<listCategoriesResponse>(getListCategoriesUrl(params), {
    ...options,
    method: 'GET',
  })
}

export const getListCategoriesQueryKey = (params?: ListCategoriesParams) => {
  return [`/catalog/categories`, ...(params ? [params] : [])] as const
}

export const getListCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = DtoErrorResponse,
>(
  params?: ListCategoriesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListCategoriesQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listCategories>>> = ({ signal }) =>
    listCategories(params, { signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof listCategories>>>
export type ListCategoriesQueryError = DtoErrorResponse

export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = DtoErrorResponse,
>(
  params: undefined | ListCategoriesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCategories>>,
          TError,
          Awaited<ReturnType<typeof listCategories>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = DtoErrorResponse,
>(
  params?: ListCategoriesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCategories>>,
          TError,
          Awaited<ReturnType<typeof listCategories>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = DtoErrorResponse,
>(
  params?: ListCategoriesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List categories
 */

export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = DtoErrorResponse,
>(
  params?: ListCategoriesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListCategoriesQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Create a new product category. Can be a root category or a child of an existing category.
 * @summary Create a new category
 */
export type createCategoryResponse201 = {
  data: HandlerAPIResponseHandlerCategoryResponse
  status: 201
}

export type createCategoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type createCategoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type createCategoryResponse409 = {
  data: DtoErrorResponse
  status: 409
}

export type createCategoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type createCategoryResponseSuccess = createCategoryResponse201 & {
  headers: Headers
}
export type createCategoryResponseError = (
  | createCategoryResponse400
  | createCategoryResponse401
  | createCategoryResponse409
  | createCategoryResponse500
) & {
  headers: Headers
}

export type createCategoryResponse = createCategoryResponseSuccess | createCategoryResponseError

export const getCreateCategoryUrl = () => {
  return `/catalog/categories`
}

export const createCategory = async (
  createCategoryBody: CreateCategoryBody,
  options?: RequestInit
): Promise<createCategoryResponse> => {
  return customInstance<createCategoryResponse>(getCreateCategoryUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createCategoryBody),
  })
}

export const getCreateCategoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCategory>>,
    TError,
    { data: CreateCategoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: CreateCategoryBody },
  TContext
> => {
  const mutationKey = ['createCategory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCategory>>,
    { data: CreateCategoryBody }
  > = (props) => {
    const { data } = props ?? {}

    return createCategory(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof createCategory>>>
export type CreateCategoryMutationBody = CreateCategoryBody
export type CreateCategoryMutationError = DtoErrorResponse

/**
 * @summary Create a new category
 */
export const useCreateCategory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCategory>>,
      TError,
      { data: CreateCategoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: CreateCategoryBody },
  TContext
> => {
  return useMutation(getCreateCategoryMutationOptions(options), queryClient)
}
/**
 * Delete a category. Category must have no children and no associated products.
 * @summary Delete a category
 */
export type deleteCategoryResponse204 = {
  data: void
  status: 204
}

export type deleteCategoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type deleteCategoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type deleteCategoryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type deleteCategoryResponse409 = {
  data: DtoErrorResponse
  status: 409
}

export type deleteCategoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type deleteCategoryResponseSuccess = deleteCategoryResponse204 & {
  headers: Headers
}
export type deleteCategoryResponseError = (
  | deleteCategoryResponse400
  | deleteCategoryResponse401
  | deleteCategoryResponse404
  | deleteCategoryResponse409
  | deleteCategoryResponse500
) & {
  headers: Headers
}

export type deleteCategoryResponse = deleteCategoryResponseSuccess | deleteCategoryResponseError

export const getDeleteCategoryUrl = (id: string) => {
  return `/catalog/categories/${id}`
}

export const deleteCategory = async (
  id: string,
  options?: RequestInit
): Promise<deleteCategoryResponse> => {
  return customInstance<deleteCategoryResponse>(getDeleteCategoryUrl(id), {
    ...options,
    method: 'DELETE',
  })
}

export const getDeleteCategoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCategory>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteCategory>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteCategory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCategory>>, { id: string }> = (
    props
  ) => {
    const { id } = props ?? {}

    return deleteCategory(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCategory>>>

export type DeleteCategoryMutationError = DtoErrorResponse

/**
 * @summary Delete a category
 */
export const useDeleteCategory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteCategory>>,
      TError,
      { id: string },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteCategory>>,
  TError,
  { id: string },
  TContext
> => {
  return useMutation(getDeleteCategoryMutationOptions(options), queryClient)
}
/**
 * Retrieve a category by its ID
 * @summary Get category by ID
 */
export type getCategoryByIdResponse200 = {
  data: HandlerAPIResponseHandlerCategoryResponse
  status: 200
}

export type getCategoryByIdResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getCategoryByIdResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getCategoryByIdResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getCategoryByIdResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getCategoryByIdResponseSuccess = getCategoryByIdResponse200 & {
  headers: Headers
}
export type getCategoryByIdResponseError = (
  | getCategoryByIdResponse400
  | getCategoryByIdResponse401
  | getCategoryByIdResponse404
  | getCategoryByIdResponse500
) & {
  headers: Headers
}

export type getCategoryByIdResponse = getCategoryByIdResponseSuccess | getCategoryByIdResponseError

export const getGetCategoryByIdUrl = (id: string) => {
  return `/catalog/categories/${id}`
}

export const getCategoryById = async (
  id: string,
  options?: RequestInit
): Promise<getCategoryByIdResponse> => {
  return customInstance<getCategoryByIdResponse>(getGetCategoryByIdUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetCategoryByIdQueryKey = (id: string) => {
  return [`/catalog/categories/${id}`] as const
}

export const getGetCategoryByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) =>
    getCategoryById(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategoryById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdQueryError = DtoErrorResponse

export function useGetCategoryById<
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById<
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById<
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get category by ID
 */

export function useGetCategoryById<
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoryByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Update an existing category's information
 * @summary Update a category
 */
export type updateCategoryResponse200 = {
  data: HandlerAPIResponseHandlerCategoryResponse
  status: 200
}

export type updateCategoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type updateCategoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type updateCategoryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type updateCategoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type updateCategoryResponseSuccess = updateCategoryResponse200 & {
  headers: Headers
}
export type updateCategoryResponseError = (
  | updateCategoryResponse400
  | updateCategoryResponse401
  | updateCategoryResponse404
  | updateCategoryResponse500
) & {
  headers: Headers
}

export type updateCategoryResponse = updateCategoryResponseSuccess | updateCategoryResponseError

export const getUpdateCategoryUrl = (id: string) => {
  return `/catalog/categories/${id}`
}

export const updateCategory = async (
  id: string,
  updateCategoryBody: UpdateCategoryBody,
  options?: RequestInit
): Promise<updateCategoryResponse> => {
  return customInstance<updateCategoryResponse>(getUpdateCategoryUrl(id), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateCategoryBody),
  })
}

export const getUpdateCategoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCategory>>,
    TError,
    { id: string; data: UpdateCategoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { id: string; data: UpdateCategoryBody },
  TContext
> => {
  const mutationKey = ['updateCategory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCategory>>,
    { id: string; data: UpdateCategoryBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateCategory(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof updateCategory>>>
export type UpdateCategoryMutationBody = UpdateCategoryBody
export type UpdateCategoryMutationError = DtoErrorResponse

/**
 * @summary Update a category
 */
export const useUpdateCategory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCategory>>,
      TError,
      { id: string; data: UpdateCategoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { id: string; data: UpdateCategoryBody },
  TContext
> => {
  return useMutation(getUpdateCategoryMutationOptions(options), queryClient)
}
/**
 * Activate an inactive category
 * @summary Activate a category
 */
export type activateCategoryResponse200 = {
  data: HandlerAPIResponseHandlerCategoryResponse
  status: 200
}

export type activateCategoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type activateCategoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type activateCategoryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type activateCategoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type activateCategoryResponseSuccess = activateCategoryResponse200 & {
  headers: Headers
}
export type activateCategoryResponseError = (
  | activateCategoryResponse400
  | activateCategoryResponse401
  | activateCategoryResponse404
  | activateCategoryResponse500
) & {
  headers: Headers
}

export type activateCategoryResponse =
  | activateCategoryResponseSuccess
  | activateCategoryResponseError

export const getActivateCategoryUrl = (id: string) => {
  return `/catalog/categories/${id}/activate`
}

export const activateCategory = async (
  id: string,
  activateCategoryBody: ActivateCategoryBody,
  options?: RequestInit
): Promise<activateCategoryResponse> => {
  return customInstance<activateCategoryResponse>(getActivateCategoryUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(activateCategoryBody),
  })
}

export const getActivateCategoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof activateCategory>>,
    TError,
    { id: string; data: ActivateCategoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof activateCategory>>,
  TError,
  { id: string; data: ActivateCategoryBody },
  TContext
> => {
  const mutationKey = ['activateCategory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof activateCategory>>,
    { id: string; data: ActivateCategoryBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return activateCategory(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ActivateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof activateCategory>>
>
export type ActivateCategoryMutationBody = ActivateCategoryBody
export type ActivateCategoryMutationError = DtoErrorResponse

/**
 * @summary Activate a category
 */
export const useActivateCategory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof activateCategory>>,
      TError,
      { id: string; data: ActivateCategoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof activateCategory>>,
  TError,
  { id: string; data: ActivateCategoryBody },
  TContext
> => {
  return useMutation(getActivateCategoryMutationOptions(options), queryClient)
}
/**
 * Retrieve direct children of a specific category
 * @summary Get children of a category
 */
export type getCategoryChildrenResponse200 = {
  data: HandlerAPIResponseArrayHandlerCategoryListResponse
  status: 200
}

export type getCategoryChildrenResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getCategoryChildrenResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getCategoryChildrenResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type getCategoryChildrenResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getCategoryChildrenResponseSuccess = getCategoryChildrenResponse200 & {
  headers: Headers
}
export type getCategoryChildrenResponseError = (
  | getCategoryChildrenResponse400
  | getCategoryChildrenResponse401
  | getCategoryChildrenResponse404
  | getCategoryChildrenResponse500
) & {
  headers: Headers
}

export type getCategoryChildrenResponse =
  | getCategoryChildrenResponseSuccess
  | getCategoryChildrenResponseError

export const getGetCategoryChildrenUrl = (id: string) => {
  return `/catalog/categories/${id}/children`
}

export const getCategoryChildren = async (
  id: string,
  options?: RequestInit
): Promise<getCategoryChildrenResponse> => {
  return customInstance<getCategoryChildrenResponse>(getGetCategoryChildrenUrl(id), {
    ...options,
    method: 'GET',
  })
}

export const getGetCategoryChildrenQueryKey = (id: string) => {
  return [`/catalog/categories/${id}/children`] as const
}

export const getGetCategoryChildrenQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoryChildren>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryChildren>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCategoryChildrenQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryChildren>>> = ({ signal }) =>
    getCategoryChildren(id, { signal, ...requestOptions })

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategoryChildren>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryChildrenQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoryChildren>>
>
export type GetCategoryChildrenQueryError = DtoErrorResponse

export function useGetCategoryChildren<
  TData = Awaited<ReturnType<typeof getCategoryChildren>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCategoryChildren>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryChildren>>,
          TError,
          Awaited<ReturnType<typeof getCategoryChildren>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryChildren<
  TData = Awaited<ReturnType<typeof getCategoryChildren>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCategoryChildren>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryChildren>>,
          TError,
          Awaited<ReturnType<typeof getCategoryChildren>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryChildren<
  TData = Awaited<ReturnType<typeof getCategoryChildren>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryChildren>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get children of a category
 */

export function useGetCategoryChildren<
  TData = Awaited<ReturnType<typeof getCategoryChildren>>,
  TError = DtoErrorResponse,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryChildren>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoryChildrenQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Deactivate an active category
 * @summary Deactivate a category
 */
export type deactivateCategoryResponse200 = {
  data: HandlerAPIResponseHandlerCategoryResponse
  status: 200
}

export type deactivateCategoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type deactivateCategoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type deactivateCategoryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type deactivateCategoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type deactivateCategoryResponseSuccess = deactivateCategoryResponse200 & {
  headers: Headers
}
export type deactivateCategoryResponseError = (
  | deactivateCategoryResponse400
  | deactivateCategoryResponse401
  | deactivateCategoryResponse404
  | deactivateCategoryResponse500
) & {
  headers: Headers
}

export type deactivateCategoryResponse =
  | deactivateCategoryResponseSuccess
  | deactivateCategoryResponseError

export const getDeactivateCategoryUrl = (id: string) => {
  return `/catalog/categories/${id}/deactivate`
}

export const deactivateCategory = async (
  id: string,
  deactivateCategoryBody: DeactivateCategoryBody,
  options?: RequestInit
): Promise<deactivateCategoryResponse> => {
  return customInstance<deactivateCategoryResponse>(getDeactivateCategoryUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(deactivateCategoryBody),
  })
}

export const getDeactivateCategoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deactivateCategory>>,
    TError,
    { id: string; data: DeactivateCategoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deactivateCategory>>,
  TError,
  { id: string; data: DeactivateCategoryBody },
  TContext
> => {
  const mutationKey = ['deactivateCategory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deactivateCategory>>,
    { id: string; data: DeactivateCategoryBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return deactivateCategory(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeactivateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deactivateCategory>>
>
export type DeactivateCategoryMutationBody = DeactivateCategoryBody
export type DeactivateCategoryMutationError = DtoErrorResponse

/**
 * @summary Deactivate a category
 */
export const useDeactivateCategory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deactivateCategory>>,
      TError,
      { id: string; data: DeactivateCategoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deactivateCategory>>,
  TError,
  { id: string; data: DeactivateCategoryBody },
  TContext
> => {
  return useMutation(getDeactivateCategoryMutationOptions(options), queryClient)
}
/**
 * Move a category to a new parent (or make it a root category)
 * @summary Move a category
 */
export type moveCategoryResponse200 = {
  data: HandlerAPIResponseHandlerCategoryResponse
  status: 200
}

export type moveCategoryResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type moveCategoryResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type moveCategoryResponse404 = {
  data: DtoErrorResponse
  status: 404
}

export type moveCategoryResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type moveCategoryResponseSuccess = moveCategoryResponse200 & {
  headers: Headers
}
export type moveCategoryResponseError = (
  | moveCategoryResponse400
  | moveCategoryResponse401
  | moveCategoryResponse404
  | moveCategoryResponse500
) & {
  headers: Headers
}

export type moveCategoryResponse = moveCategoryResponseSuccess | moveCategoryResponseError

export const getMoveCategoryUrl = (id: string) => {
  return `/catalog/categories/${id}/move`
}

export const moveCategory = async (
  id: string,
  moveCategoryBody: MoveCategoryBody,
  options?: RequestInit
): Promise<moveCategoryResponse> => {
  return customInstance<moveCategoryResponse>(getMoveCategoryUrl(id), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(moveCategoryBody),
  })
}

export const getMoveCategoryMutationOptions = <
  TError = DtoErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moveCategory>>,
    TError,
    { id: string; data: MoveCategoryBody },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof moveCategory>>,
  TError,
  { id: string; data: MoveCategoryBody },
  TContext
> => {
  const mutationKey = ['moveCategory']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moveCategory>>,
    { id: string; data: MoveCategoryBody }
  > = (props) => {
    const { id, data } = props ?? {}

    return moveCategory(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MoveCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof moveCategory>>>
export type MoveCategoryMutationBody = MoveCategoryBody
export type MoveCategoryMutationError = DtoErrorResponse

/**
 * @summary Move a category
 */
export const useMoveCategory = <TError = DtoErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof moveCategory>>,
      TError,
      { id: string; data: MoveCategoryBody },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof moveCategory>>,
  TError,
  { id: string; data: MoveCategoryBody },
  TContext
> => {
  return useMutation(getMoveCategoryMutationOptions(options), queryClient)
}
/**
 * Retrieve all root (top-level) categories
 * @summary Get root categories
 */
export type getCategoryRootsResponse200 = {
  data: HandlerAPIResponseArrayHandlerCategoryListResponse
  status: 200
}

export type getCategoryRootsResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getCategoryRootsResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getCategoryRootsResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getCategoryRootsResponseSuccess = getCategoryRootsResponse200 & {
  headers: Headers
}
export type getCategoryRootsResponseError = (
  | getCategoryRootsResponse400
  | getCategoryRootsResponse401
  | getCategoryRootsResponse500
) & {
  headers: Headers
}

export type getCategoryRootsResponse =
  | getCategoryRootsResponseSuccess
  | getCategoryRootsResponseError

export const getGetCategoryRootsUrl = () => {
  return `/catalog/categories/roots`
}

export const getCategoryRoots = async (
  options?: RequestInit
): Promise<getCategoryRootsResponse> => {
  return customInstance<getCategoryRootsResponse>(getGetCategoryRootsUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getGetCategoryRootsQueryKey = () => {
  return [`/catalog/categories/roots`] as const
}

export const getGetCategoryRootsQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoryRoots>>,
  TError = DtoErrorResponse,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryRoots>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCategoryRootsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryRoots>>> = ({ signal }) =>
    getCategoryRoots({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategoryRoots>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryRootsQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryRoots>>>
export type GetCategoryRootsQueryError = DtoErrorResponse

export function useGetCategoryRoots<
  TData = Awaited<ReturnType<typeof getCategoryRoots>>,
  TError = DtoErrorResponse,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryRoots>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryRoots>>,
          TError,
          Awaited<ReturnType<typeof getCategoryRoots>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryRoots<
  TData = Awaited<ReturnType<typeof getCategoryRoots>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryRoots>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryRoots>>,
          TError,
          Awaited<ReturnType<typeof getCategoryRoots>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryRoots<
  TData = Awaited<ReturnType<typeof getCategoryRoots>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryRoots>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get root categories
 */

export function useGetCategoryRoots<
  TData = Awaited<ReturnType<typeof getCategoryRoots>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryRoots>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoryRootsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}

/**
 * Retrieve all categories as a hierarchical tree structure
 * @summary Get category tree
 */
export type getCategoryTreeResponse200 = {
  data: HandlerAPIResponseArrayHandlerCategoryTreeNode
  status: 200
}

export type getCategoryTreeResponse400 = {
  data: DtoErrorResponse
  status: 400
}

export type getCategoryTreeResponse401 = {
  data: DtoErrorResponse
  status: 401
}

export type getCategoryTreeResponse500 = {
  data: DtoErrorResponse
  status: 500
}

export type getCategoryTreeResponseSuccess = getCategoryTreeResponse200 & {
  headers: Headers
}
export type getCategoryTreeResponseError = (
  | getCategoryTreeResponse400
  | getCategoryTreeResponse401
  | getCategoryTreeResponse500
) & {
  headers: Headers
}

export type getCategoryTreeResponse = getCategoryTreeResponseSuccess | getCategoryTreeResponseError

export const getGetCategoryTreeUrl = () => {
  return `/catalog/categories/tree`
}

export const getCategoryTree = async (options?: RequestInit): Promise<getCategoryTreeResponse> => {
  return customInstance<getCategoryTreeResponse>(getGetCategoryTreeUrl(), {
    ...options,
    method: 'GET',
  })
}

export const getGetCategoryTreeQueryKey = () => {
  return [`/catalog/categories/tree`] as const
}

export const getGetCategoryTreeQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoryTree>>,
  TError = DtoErrorResponse,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryTree>>, TError, TData>>
  request?: SecondParameter<typeof customInstance>
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCategoryTreeQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryTree>>> = ({ signal }) =>
    getCategoryTree({ signal, ...requestOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategoryTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryTree>>>
export type GetCategoryTreeQueryError = DtoErrorResponse

export function useGetCategoryTree<
  TData = Awaited<ReturnType<typeof getCategoryTree>>,
  TError = DtoErrorResponse,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryTree>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryTree>>,
          TError,
          Awaited<ReturnType<typeof getCategoryTree>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryTree<
  TData = Awaited<ReturnType<typeof getCategoryTree>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryTree>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryTree>>,
          TError,
          Awaited<ReturnType<typeof getCategoryTree>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryTree<
  TData = Awaited<ReturnType<typeof getCategoryTree>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryTree>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get category tree
 */

export function useGetCategoryTree<
  TData = Awaited<ReturnType<typeof getCategoryTree>>,
  TError = DtoErrorResponse,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryTree>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoryTreeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  return { ...query, queryKey: queryOptions.queryKey }
}
